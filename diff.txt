diff --git a/.deepsource.toml b/.deepsource.toml
index d985f45..aebeb0f 100644
--- a/.deepsource.toml
+++ b/.deepsource.toml
@@ -5,8 +5,4 @@ name = "python"
 enabled = true
 
   [analyzers.meta]
-  runtime_version = "3.x.x"
-
-[[analyzers]]
-name = "shell"
-enabled = true
\ No newline at end of file
+  runtime_version = "3.x.x"
\ No newline at end of file
diff --git a/.dockerignore b/.dockerignore
new file mode 100644
index 0000000..3432d64
--- /dev/null
+++ b/.dockerignore
@@ -0,0 +1,157 @@
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+pip-wheel-metadata/
+share/python-wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+MANIFEST
+
+# PyInstaller
+#  Usually these files are written by a python script from a template
+#  before PyInstaller builds the exe, so as to inject date/other infos into it.
+*.manifest
+*.spec
+
+# Installer logs
+pip-log.txt
+pip-delete-this-directory.txt
+
+# Unit test / coverage reports
+htmlcov/
+.tox/
+.nox/
+.coverage
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*.cover
+*.py,cover
+.hypothesis/
+.pytest_cache/
+
+# Translations
+*.mo
+*.pot
+
+# Django stuff:
+*.log
+local_settings.py
+db.sqlite3
+db.sqlite3-journal
+
+# Flask stuff:
+instance/
+.webassets-cache
+
+# Scrapy stuff:
+.scrapy
+
+# Sphinx documentation
+docs/_build/
+
+# PyBuilder
+target/
+
+# Jupyter Notebook
+.ipynb_checkpoints
+
+# IPython
+profile_default/
+ipython_config.py
+
+# pyenv
+.python-version
+
+# pipenv
+#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
+#   However, in case of collaboration, if having platform-specific dependencies or dependencies
+#   having no cross-platform support, pipenv may install dependencies that don't work, or not
+#   install all needed dependencies.
+#Pipfile.lock
+
+# PEP 582; used by e.g. github.com/David-OConnor/pyflow
+__pypackages__/
+
+# Celery stuff
+celerybeat-schedule
+celerybeat.pid
+
+# SageMath parsed files
+*.sage.py
+
+# Environments
+.env
+.venv
+env/
+venv/
+ENV/
+env.bak/
+venv.bak/
+
+# Spyder project settings
+.spyderproject
+.spyproject
+
+# Rope project settings
+.ropeproject
+
+# mkdocs documentation
+/site
+
+# mypy
+.mypy_cache/
+.dmypy.json
+dmypy.json
+
+# Pyre type checker
+.pyre/
+
+
+*__pycache__
+*.pyc
+hikka/api_token.py
+hikka/loaded_modules
+hikka*.session*
+database-*.json
+*.swp
+.setup_complete
+.tox
+.idea/
+venv/
+data/
+api_token.txt
+.coverage
+.vscode/
+ftg-install.log
+config.ini
+.cache
+config-*.json
+config.json
+*cache*.json
+*.png
+*.jpg
+*.jpeg
+*.webp
+*.webm
\ No newline at end of file
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
deleted file mode 100755
index 6f68d04..0000000
--- a/.github/dependabot.yml
+++ /dev/null
@@ -1,11 +0,0 @@
-version: 2
-updates:
-  - package-ecosystem: pip
-    directory: "/"
-    schedule:
-      interval: daily
-    automerged_updates:
-      - match:
-          dependency_type: "production"
-          update_type: "all"
-    open-pull-requests-limit: 10
diff --git a/.github/workflows/python-app.yml b/.github/workflows/python-app.yml
deleted file mode 100755
index 4a327be..0000000
--- a/.github/workflows/python-app.yml
+++ /dev/null
@@ -1,28 +0,0 @@
-name: Python application
-
-on:
-  push:
-    branches: [ master ]
-  pull_request:
-    branches: [ master ]
-
-jobs:
-  build:
-
-    runs-on: ubuntu-latest
-
-    steps:
-      - uses: actions/checkout@v2
-      - name: Set up Python 3.9
-        uses: actions/setup-python@v2
-        with:
-          python-version: 3.9
-      - name: Install dependencies
-        run: |
-          python -m pip install --upgrade pip
-          pip install flake8 pytest
-          pip install -r requirements.txt
-      - name: Lint with flake8
-        run: |
-          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
-          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics --extend-ignore=E203,C901,E501
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
index 3a8d548..bb9f17b
--- a/.gitignore
+++ b/.gitignore
@@ -1,9 +1,139 @@
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+pip-wheel-metadata/
+share/python-wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+MANIFEST
+
+# PyInstaller
+#  Usually these files are written by a python script from a template
+#  before PyInstaller builds the exe, so as to inject date/other infos into it.
+*.manifest
+*.spec
+
+# Installer logs
+pip-log.txt
+pip-delete-this-directory.txt
+
+# Unit test / coverage reports
+htmlcov/
+.tox/
+.nox/
+.coverage
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*.cover
+*.py,cover
+.hypothesis/
+.pytest_cache/
+
+# Translations
+*.mo
+*.pot
+
+# Django stuff:
+*.log
+local_settings.py
+db.sqlite3
+db.sqlite3-journal
+
+# Flask stuff:
+instance/
+.webassets-cache
+
+# Scrapy stuff:
+.scrapy
+
+# Sphinx documentation
+docs/_build/
+
+# PyBuilder
+target/
+
+# Jupyter Notebook
+.ipynb_checkpoints
+
+# IPython
+profile_default/
+ipython_config.py
+
+# pyenv
+.python-version
+
+# pipenv
+#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
+#   However, in case of collaboration, if having platform-specific dependencies or dependencies
+#   having no cross-platform support, pipenv may install dependencies that don't work, or not
+#   install all needed dependencies.
+#Pipfile.lock
+
+# PEP 582; used by e.g. github.com/David-OConnor/pyflow
+__pypackages__/
+
+# Celery stuff
+celerybeat-schedule
+celerybeat.pid
+
+# SageMath parsed files
+*.sage.py
+
+# Environments
+.env
+.venv
+env/
+venv/
+ENV/
+env.bak/
+venv.bak/
+
+# Spyder project settings
+.spyderproject
+.spyproject
+
+# Rope project settings
+.ropeproject
+
+# mkdocs documentation
+/site
+
+# mypy
+.mypy_cache/
+.dmypy.json
+dmypy.json
+
+# Pyre type checker
+.pyre/
+
+
 *__pycache__
 *.pyc
-friendly-telegram/api_token.py
-friendly-telegram/FTG-Modules
-friendly-telegram/loaded_modules
-friendly-telegram*.session*
+hikka/api_token.py
+hikka/loaded_modules
+hikka*.session*
 database-*.json
 *.swp
 .setup_complete
@@ -11,8 +141,6 @@ database-*.json
 .idea/
 venv/
 data/
-mishase_cache/
-translations/
 api_token.txt
 .coverage
 .vscode/
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..b9e9034
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,6 @@
+FROM python:3.8
+ADD . /
+ENV OKTETO=true
+RUN pip install -r requirements.txt
+EXPOSE 8080
+CMD ["python3", "-m", "hikka"]
\ No newline at end of file
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Procfile b/Procfile
deleted file mode 100644
index 20cf404..0000000
--- a/Procfile
+++ /dev/null
@@ -1,3 +0,0 @@
-worker-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK: python3 -m friendly-telegram
-web: python3 -m friendly-telegram --heroku-web-internal
-restarter-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK: python3 -m friendly-telegram --heroku-restart-internal
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
index 43b972f..6b5fceb
--- a/README.md
+++ b/README.md
@@ -1,51 +1,95 @@
-![image](https://user-images.githubusercontent.com/36935426/158629190-e1d54442-f480-4ce2-a58c-6d9f1d3055e8.png)
+<a href="https://github.com/hikariatama/Hikka/blob/master/README_ru.md"><img src="https://img.icons8.com/external-justicon-flat-justicon/344/external-russia-countrys-flags-justicon-flat-justicon.png" width="32" align="middle"> –†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã</a>
+<hr>
+<h2><img src="https://github.com/hikariatama/assets/raw/master/1326-command-window-line-flat.webp" height="54" align="middle"> Installation</h2>
+<img src="https://github.com/hikariatama/assets/raw/master/install.gif">
 
-A fast, easy to set up telegram userbot running Python 3 which runs on custom version
-the [Telethon](https://github.com/GeekTG/Telethon) Library.
+<a href="https://cloud.okteto.com/#/deploy?repository=https://github.com/hikariatama/Hikka"><img src="https://user-images.githubusercontent.com/36935426/159979786-61a598ef-83c8-4c53-9cda-9aea31d61587.png" height="60"></a>
 
-[![DeepSource](https://deepsource.io/gh/GeekTG/Friendly-Telegram.svg/?label=active+issues&show_trend=true&token=9Zxse6cjEZ0Hwh1PJJ3mMTWw)](https://deepsource.io/gh/GeekTG/Friendly-Telegram/?ref=repository-badge)
+<hr>
+<h2><img src="https://github.com/hikariatama/assets/raw/master/35-edit-flat.webp" height="54" align="middle"> Changes</h2>
 
-## Changes
+<ul>
+	<li>üÜï Latest Telegram Layers with reactions, video stickers and other stuff</li>
+	<li>üîì Security improvements</li>
+	<li>üé® UI/UX improvements</li>
+	<li>üìº New core modules</li>
+	<li>‚òÅÔ∏è Okteto cloud deployment support</li>
+	<li>‚è± Quick bug fixes (compared to official FTG)</li>
+	<li>‚ñ∂Ô∏è Inline Buttons, available not only for core modules, but for every developer</li>
+	<li>üñº Inline Galleries for every developer</li>
+	<li>üîÅ Full backward compatibility with older version and with official FTG\GeekTG modules</li>
+</ul>
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/1312-micro-sd-card-flat.webp" height="54" align="middle"> Requirements</h2>
+<ul>
+	<li>Python 3.8 or above</li>
+	<li>Requirements from <code>requirements.txt</code></li>
+	<li>Optional: API ID and Hash from <a href="https://my.telegram.org/apps" color="#2594cb">Telegram</a> or default ones, if your Telegram account is old enough</li>
+	<li>Optional: Some basic knowledge of terminal</li>
+</ul>
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/680-it-developer-flat.webp" height="54" align="middle"> Documentation</h2>
 
-- Latest Telegram Layers with reactions, video stickers and other stuff
-- Security improvements
-- UI/UX improvements
-- New core modules
-- Native FFmpeg support for Heroku
-- Quick bug fixes (compared to official FTG)
-- Inline Buttons, available not only for core modules, but for every developer
-- Inline Galleries for every developer
-- Full backward compatibility with older version and with official FTG modules
+Check out the folder <code>docs</code> for developers' documentation
+User docs will be available soon
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/981-consultation-flat.webp" height="54" align="middle"> <a href="https://t.me/hikka_talks">Support</a></h2>
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/541-hand-washing-step-12-flat.webp" height="54" align="middle"> Features</h2>
+<table>
+	<tr>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/1286-three-3-key-flat.webp" height="32" align="middle"><b> Forms - bored of writing? Use buttons!</b>
+		</td>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/61-camera-flat.webp" height="32" align="middle"><b> Galleries - scroll your favorite photos in Telegram</b>
+		</td>
+	</tr>
+	<tr>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475881-8463537a-265e-472a-9b1e-ede8b1cc3380.gif">
+		</td>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475809-c171c5ff-010c-472c-903a-de9b8a2c61cc.gif">
+		</td>
+	</tr>
+</table>
+<table>
+	<tr>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/216-arrow-5-flat.webp" height="32" align="middle"><b> Inline - share userbot with your friends</b>
+		</td>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/1054-amazon-echo-speaker-flat.webp" height="32" align="middle"><b> Bot interactions - "No PM"? No problem. Feedback bot at your service</b>
+		</td>
+	</tr>
+	<tr>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475934-02e6df9d-e73a-42fc-99c7-8b12d1015336.gif">
+		</td>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160476037-9537f1c7-8b72-408f-b84c-b89825930bf5.gif">
+		</td>
+	</tr>
+</table>
+<table>
+	<tr>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/1140-error-flat.webp" height="32" align="middle"><b> InlineLogs - traceback directly in message, caused error</b>
+		</td>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/35-edit-flat.webp" height="32" align="middle"><b> Grep - execute command and get only required lines</b>
+		</td>
+	</tr>
+	<tr>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475684-86d11e83-832e-43fc-89d8-fd7bc85b1857.gif">
+		</td>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475710-2adb0f11-afb6-4860-b1cd-85ccc5421d22.gif">
+		</td>
+	</tr>
+</table>
 
-![img](https://user-images.githubusercontent.com/36935426/158634458-424021a3-27c4-494f-9db2-1266f161e7a2.png)
-
-
-## Small, but useful
-
-### InlineLogs - traceback directly in message, caused error
-![img2](https://user-images.githubusercontent.com/36935426/158635869-cc08a053-3bac-4d2e-ad50-30aa77c757fd.png)
----
-### Grep - execute command and get only required lines
-![img3](https://user-images.githubusercontent.com/36935426/158636369-389241e6-bb9c-474b-bcfd-7493503d91dd.png)
----
-### NoNick, NoNickUser, NoNickCmd - enable global nonickname feature
-![img4](https://user-images.githubusercontent.com/36935426/158637220-00495363-cf4a-4e6f-a4b2-51d693906ead.png)
----
-### Requirements
-
-- Python 3.8 or above
-- Requirements from `requirements.txt`
-- API ID and Hash from [Telegram](https://my.telegram.org/apps) or use default ones
-- Some basic knowledge of terminal
-
-### Documentation
-
-We've made docs to help you to set up the bot. They can be found [here](https://ftg.geektg.ml).
-Also, check out the folder `docs` for developers' documentation
-
-### Support
-
-We also have a dedicated Telegram support group. Got any doubts or issues while setting-up? Shoot 'em here! **Please
-read the docs first** tho, to make sure your question isn't already answered!
-
-[GeekTG Support Group](https://t.me/chat_ftg "Telegram").
+<b>üë®‚Äçüë¶ NoNick, NoNickUser, NoNickCmd - use another account for userbot</b>
+<img src="https://user-images.githubusercontent.com/36935426/158637220-00495363-cf4a-4e6f-a4b2-51d693906ead.png">
diff --git a/README_ru.md b/README_ru.md
new file mode 100644
index 0000000..4d73e2f
--- /dev/null
+++ b/README_ru.md
@@ -0,0 +1,95 @@
+<a href="https://github.com/hikariatama/Hikka/blob/master/README.md"><img src="https://img.icons8.com/external-justicon-flat-justicon/344/external-uk-flag-countrys-flags-justicon-flat-justicon.png" width="32" align="middle"> English page version</a>
+<hr>
+<h2><img src="https://github.com/hikariatama/assets/raw/master/1326-command-window-line-flat.webp" height="54" align="middle"> –£—Å—Ç–∞–Ω–æ–≤–∫–∞</h2>
+<img src="https://github.com/hikariatama/assets/raw/master/install.gif">
+
+<a href="https://cloud.okteto.com/#/deploy?repository=https://github.com/hikariatama/Hikka"><img src="https://user-images.githubusercontent.com/36935426/159979786-61a598ef-83c8-4c53-9cda-9aea31d61587.png" height="60"></a>
+
+<hr>
+<h2><img src="https://github.com/hikariatama/assets/raw/master/35-edit-flat.webp" height="54" align="middle"> –ò–∑–º–µ–Ω–µ–Ω–∏—è</h2>
+
+<ul>
+	<li>üÜï –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–ª–æ–∏ –¢–µ–ª–µ–≥—Ä–∞–º —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–µ–∞–∫—Ü–∏–π, –≤–∏–¥–µ–æ—Å—Ç–∏–∫–µ—Ä–æ–≤ –∏ –º–Ω–æ–≥–∏–º –¥—Ä—É–≥–∏–º</li>
+	<li>üîì –ü–∞—Ç—á–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</li>
+	<li>üé® –£–ª—É—á—à–µ–Ω–Ω—ã–µ UI/UX</li>
+	<li>üìº –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –º–æ–¥—É–ª–∏</li>
+	<li>‚òÅÔ∏è –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞ Okteto Cloud</li>
+	<li>‚è± –ë—ã—Å—Ç—Ä—ã–µ —Ñ–∏–∫—Å—ã –±–∞–≥–æ–≤ (–≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏ —Å FTG)</li>
+	<li>‚ñ∂Ô∏è –ò–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏, –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–ª—è –≤—Å–µ—Ö —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤</li>
+	<li>üñº –ò–Ω–ª–∞–π–Ω-–≥–∞–ª–µ—Ä–µ–∏, –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–ª—è –≤—Å–µ—Ö —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤</li>
+	<li>üîÅ –ü–æ–ª–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –ø—Ä–æ—à–ª—ã–º–∏ –≤–µ—Ä—Å–∏—è–º–∏ Hikka, –∞ —Ç–∞–∫–∂–µ –º–æ–¥—É–ª—è–º–∏ FTG\GeekTG</li>
+</ul>
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/1312-micro-sd-card-flat.webp" height="54" align="middle"> –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏</h2>
+<ul>
+	<li>Python 3.8 –∏–ª–∏ –≤—ã—à–µ</li>
+	<li>–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏–∑ <code>requirements.txt</code></li>
+	<li>–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ: API ID –∏ Hash –∏–∑ <a href="https://my.telegram.org/apps" color="#2594cb">Telegram</a> (–º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ, –µ—Å–ª–∏ –∞–∫–∫–∞—É–Ω—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ç–∞—Ä—ã–π)</li>
+	<li>–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ: –ó–Ω–∞–Ω–∏–µ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞</li>
+</ul>
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/680-it-developer-flat.webp" height="54" align="middle"> –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è</h2>
+
+–°–º–æ—Ç—Ä–∏ –ø–∞–ø–∫—É <code>docs</code> –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
+–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/981-consultation-flat.webp" height="54" align="middle"> <a href="https://t.me/hikka_talks">–ü–æ–º–æ—â—å</a></h2>
+<hr>
+<h2 border="none"><img src="https://github.com/hikariatama/assets/raw/master/541-hand-washing-step-12-flat.webp" height="54" align="middle"> –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏</h2>
+<table>
+	<tr>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/1286-three-3-key-flat.webp" height="32" align="middle"><b> –§–æ—Ä–º—ã - –£—Å—Ç–∞–ª –ø–∏—Å–∞—Ç—å? –ñ–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫–∏!</b>
+		</td>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/61-camera-flat.webp" height="32" align="middle"><b> –ì–∞–ª–µ—Ä–µ–∏ - –õ–∏—Å—Ç–∞–π –ª—é–±–∏–º—ã–µ —Ñ–æ—Ç–æ –ø—Ä—è–º–æ –≤ Telegram</b>
+		</td>
+	</tr>
+	<tr>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475881-8463537a-265e-472a-9b1e-ede8b1cc3380.gif">
+		</td>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475809-c171c5ff-010c-472c-903a-de9b8a2c61cc.gif">
+		</td>
+	</tr>
+</table>
+<table>
+	<tr>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/216-arrow-5-flat.webp" height="32" align="middle"><b> –ò–Ω–ª–∞–π–Ω - –ü–æ–¥–µ–ª–∏—Å—å —é–∑–µ—Ä–±–æ—Ç–æ–º —Å –¥—Ä—É–∑—å—è–º–∏</b>
+		</td>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/1054-amazon-echo-speaker-flat.webp" height="32" align="middle"><b> –ë–æ—Ç - –ù–µ –ø—Ä–∏–Ω–∏–º–∞–µ—à—å –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è? –ù–µ –ø—Ä–æ–±–ª–µ–º–∞. –§–∏–¥–±–µ–∫-–±–æ—Ç –∫ –≤–∞—à–∏–º —É—Å–ª—É–≥–∞–º</b>
+		</td>
+	</tr>
+	<tr>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475934-02e6df9d-e73a-42fc-99c7-8b12d1015336.gif">
+		</td>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160476037-9537f1c7-8b72-408f-b84c-b89825930bf5.gif">
+		</td>
+	</tr>
+</table>
+<table>
+	<tr>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/1140-error-flat.webp" height="32" align="middle"><b> –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –ª–æ–≥–∏ - –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –ø—Ä—è–º–æ –≤ —Å–æ–æ–±—â–µ–Ω–Ω–∏–∏, –≤—ã–∑–≤–∞–≤—à–µ–º –∏—Ö</b>
+		</td>
+		<td>
+			<img src="https://github.com/hikariatama/assets/raw/master/35-edit-flat.webp" height="32" align="middle"><b> Grep - –ü–æ–ª—É—á–∏—Ç—å —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤—ã–≤–æ–¥–∞ –∫–æ–º–∞–Ω–¥—ã</b>
+		</td>
+	</tr>
+	<tr>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475684-86d11e83-832e-43fc-89d8-fd7bc85b1857.gif">
+		</td>
+		<td>
+			<img src="https://user-images.githubusercontent.com/36935426/160475710-2adb0f11-afb6-4860-b1cd-85ccc5421d22.gif">
+		</td>
+	</tr>
+</table>
+
+<b>üë®‚Äçüë¶ NoNick, NoNickUser, NoNickCmd - –ò—Å–ø–æ–ª—å–∑—É–π –¥—Ä—É–≥–æ–π –∞–∫–∫–∞—É–Ω—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ —é–∑–µ—Ä–±–æ—Ç–∞</b>
+<img src="https://user-images.githubusercontent.com/36935426/158637220-00495363-cf4a-4e6f-a4b2-51d693906ead.png">
diff --git a/app.json b/app.json
old mode 100644
new mode 100755
diff --git a/assets/bot_pfp.png b/assets/bot_pfp.png
new file mode 100644
index 0000000..ffbe272
Binary files /dev/null and b/assets/bot_pfp.png differ
diff --git a/assets/hikka_pfp.png b/assets/hikka_pfp.png
new file mode 100644
index 0000000..140b89d
Binary files /dev/null and b/assets/hikka_pfp.png differ
diff --git a/assets/noface.json b/assets/noface.json
new file mode 100644
index 0000000..9dda827
--- /dev/null
+++ b/assets/noface.json
@@ -0,0 +1 @@
+{"v":"5.9.1","fr":60,"ip":0,"op":492,"w":1600,"h":1200,"nm":"NoFace","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Rock1","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":430,"s":[100]},{"t":508,"s":[0]}],"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":257,"s":[0]},{"t":349,"s":[360]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":257,"s":[525.972,782.257,0],"to":[0,0,0],"ti":[54.965,-30.577,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":277,"s":[466.133,739.409,0],"to":[-98.805,54.966,0],"ti":[-4.408,-170.931,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":311,"s":[364.416,1083.594,0],"to":[-26.972,-67.795,0],"ti":[0,0,0]},{"t":338,"s":[313.528,1081.581,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-309.375,151.676,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.55,0.55,0.55],"y":[1,1,1]},"o":{"x":[0.45,0.45,0.45],"y":[0,0,0]},"t":252,"s":[0,0,100]},{"t":294,"s":[142.6,142.6,100]}],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[1,-3],[-1,-4.5],[-7,1.5],[0,0]],"o":[[0,0],[-1,3],[1,4.5],[7,-1.5],[0,0]],"v":[[-314,135],[-327,145],[-327,161.5],[-306.5,168],[-291,154]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.797550156537,0.414031862745,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":245,"op":492,"st":26,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"ROckShadow1","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":277,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":311,"s":[100]},{"t":508,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":277,"s":[463.711,1103.926,0],"to":[-16.333,0,0],"ti":[23.5,0,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":312,"s":[365.711,1103.926,0],"to":[-23.5,0,0],"ti":[7.167,0,0]},{"t":338,"s":[322.711,1103.926,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-492.289,503.926,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[80.961,19.203],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.513771446078,0.282776088341,0.21249739703,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-492.289,503.926],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[69.88,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":277,"op":492,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Rock2","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":430,"s":[100]},{"t":508,"s":[0]}],"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":227,"s":[0]},{"t":319,"s":[360]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":227,"s":[507.295,794.058,0],"to":[0,0,0],"ti":[34.254,-19.056,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":247,"s":[470.004,767.355,0],"to":[-61.574,34.254,0],"ti":[-2.747,-106.522,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":281,"s":[406.615,1019.239,0],"to":[-16.809,-42.249,0],"ti":[0,0,0]},{"t":308,"s":[374.903,1017.985,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-309.375,151.676,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.55,0.55,0.55],"y":[1,1,1]},"o":{"x":[0.45,0.45,0.45],"y":[0,0,0]},"t":222,"s":[0,0,100]},{"t":264,"s":[88.867,88.867,100]}],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[1,-3],[-1,-4.5],[-7,1.5],[0,0]],"o":[[0,0],[-1,3],[1,4.5],[7,-1.5],[0,0]],"v":[[-314,135],[-327,145],[-327,161.5],[-306.5,168],[-291,154]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.797550156537,0.414031862745,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":214,"op":492,"st":-4,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"ROckShadow2","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":277,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":311,"s":[100]},{"t":508,"s":[0]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":277,"s":[409.661,1031.926,0],"to":[-5.906,0,0],"ti":[5.325,0,0]},{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":312,"s":[374.228,1031.926,0],"to":[-5.325,0,0],"ti":[-0.581,0,0]},{"t":338,"s":[377.711,1031.926,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-492.289,503.926,0],"ix":1,"l":2},"s":{"a":0,"k":[61.667,61.667,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[80.961,19.203],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.513771446078,0.282776088341,0.21249739703,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-492.289,503.926],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[69.88,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":277,"op":492,"st":0,"bm":0},{"ddd":0,"ind":5,"ty":4,"nm":"Lhand 2","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[73.045,90.412,0],"to":[-15.301,0,0],"ti":[15.301,0,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-18.758,90.412,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[-18.758,90.412,0],"to":[0,-9.516,0],"ti":[0,9.516,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":110,"s":[-18.758,33.317,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[-18.758,33.317,0],"to":[0,9.516,0],"ti":[0,-9.516,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":183,"s":[-18.758,90.412,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-18.758,90.412,0],"to":[15.301,0,0],"ti":[-15.301,0,0]},{"t":488,"s":[73.045,90.412,0]}],"ix":2,"l":2},"a":{"a":0,"k":[301.272,119.066,0],"ix":1,"l":2},"s":{"a":0,"k":[63.918,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[9,13.5],[5.5,-12.5],[3.5,-14.5],[-9,0.5],[0,7],[-7,7]],"o":[[-9,-13.5],[-5.5,12.5],[-3.5,14.5],[9,-0.5],[0,-7],[7,-7]],"v":[[325.5,80],[298,109],[272.5,144.5],[282,161.5],[287.514,141.308],[320.013,114.886]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.532843137255,0.532843137255,0.532843137255,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":6,"ty":4,"nm":"Lhand","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.63,"y":0},"t":7,"s":[-54.46,90.412,0],"to":[-9.457,0,0],"ti":[9.457,0,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-111.2,90.412,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[-111.2,90.412,0],"to":[1.594,-9.516,0],"ti":[-1.594,9.516,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":110,"s":[-101.637,33.317,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[-101.637,33.317,0],"to":[-2.125,9.516,0],"ti":[2.125,-9.516,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":183,"s":[-114.387,90.412,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-114.387,90.412,0],"to":[9.988,0,0],"ti":[-9.988,0,0]},{"t":488,"s":[-54.46,90.412,0]}],"ix":2,"l":2},"a":{"a":0,"k":[301.272,119.066,0],"ix":1,"l":2},"s":{"a":0,"k":[63.918,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[{"i":[[14.673,-6.925],[0.412,-7.408],[-4.182,-14.318],[-9.022,-0.37],[0,7],[-0.537,9.885]],"o":[[-17.114,8.078],[-0.758,13.635],[3.47,11.881],[9.006,0.37],[0,-7],[0.841,-15.486]],"v":[[298.57,83.653],[293.013,115.209],[320.376,145.231],[332.868,161.5],[340.876,144.231],[318.018,114.886]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":55,"s":[{"i":[[9,13.5],[5.5,-12.5],[3.5,-14.5],[-9,0.5],[0,7],[-7,7]],"o":[[-9,-13.5],[-5.5,12.5],[-3.5,14.5],[9,-0.5],[0,-7],[7,-7]],"v":[[325.5,80],[298,109],[272.5,144.5],[282,161.5],[293,143.5],[325,120]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":187,"s":[{"i":[[9,13.5],[5.5,-12.5],[3.5,-14.5],[-9,0.5],[0,7],[-7,7]],"o":[[-9,-13.5],[-5.5,12.5],[-3.5,14.5],[9,-0.5],[0,-7],[7,-7]],"v":[[325.5,80],[298,109],[272.5,144.5],[282,161.5],[293,143.5],[325,120]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":211,"s":[{"i":[[9,13.5],[5.5,-12.5],[3.5,-14.5],[-9,0.5],[0,7],[-7,7]],"o":[[-9,-13.5],[-5.5,12.5],[-3.5,14.5],[9,-0.5],[0,-7],[7,-7]],"v":[[325.5,80],[298,109],[272.5,144.5],[282,161.5],[293,143.5],[325,120]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":251,"s":[{"i":[[13.573,8.889],[17.289,-13.617],[24.835,-9.669],[-8.996,0.571],[-6.636,0.097],[-7,7]],"o":[[-12.206,-7.994],[-9.361,7.373],[-13.9,5.412],[17.33,-1.101],[11.663,-0.171],[7,-7]],"v":[[330.487,81.461],[287.029,107.539],[211.658,124.045],[213.179,140.315],[233.155,128.89],[310.039,118.539]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":285,"s":[{"i":[[13.575,8.892],[17.289,-13.615],[24.835,-9.669],[-8.996,0.571],[-6.636,0.097],[-7,7]],"o":[[-12.206,-7.994],[-9.361,7.372],[-13.9,5.412],[17.33,-1.101],[11.663,-0.171],[7,-7]],"v":[[330.488,88.035],[294.009,115.573],[223.625,137.921],[225.145,154.191],[245.122,142.765],[317.02,126.573]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":319,"s":[{"i":[[22.769,27.798],[21.948,-1.602],[24.835,-9.669],[-8.996,0.571],[-6.636,0.097],[-7,7]],"o":[[-9.246,-11.287],[-12.692,0.926],[-13.9,5.412],[17.33,-1.101],[11.663,-0.171],[7,-7]],"v":[[337.399,75.619],[285.094,102.496],[210.764,111.749],[212.285,128.018],[232.261,116.593],[310.099,118.608]],"c":true}]},{"i":{"x":0.6,"y":1},"o":{"x":0.167,"y":0},"t":353,"s":[{"i":[[13.573,8.889],[17.289,-13.617],[24.835,-9.669],[-8.996,0.571],[-6.636,0.097],[-7,7]],"o":[[-12.206,-7.994],[-9.361,7.373],[-13.9,5.412],[17.33,-1.101],[11.663,-0.171],[7,-7]],"v":[[338.466,85.844],[294.01,115.575],[223.627,137.925],[225.147,154.195],[245.124,142.769],[317.021,126.575]],"c":true}]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[{"i":[[13.573,8.889],[17.289,-13.617],[24.835,-9.669],[-8.996,0.571],[-6.636,0.097],[-7,7]],"o":[[-12.206,-7.994],[-9.361,7.373],[-13.9,5.412],[17.33,-1.101],[11.663,-0.171],[7,-7]],"v":[[338.466,85.844],[294.01,115.575],[223.627,137.925],[225.147,154.195],[245.124,142.769],[317.021,126.575]],"c":true}]},{"t":488,"s":[{"i":[[14.673,-6.925],[0.412,-7.408],[-4.182,-14.318],[-9.022,-0.37],[0,7],[-0.537,9.885]],"o":[[-17.114,8.078],[-0.758,13.635],[3.47,11.881],[9.006,0.37],[0,-7],[0.841,-15.486]],"v":[[298.57,83.653],[293.013,115.209],[320.376,145.231],[332.868,161.5],[340.876,144.231],[318.018,114.886]],"c":true}]}],"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.532843137255,0.532843137255,0.532843137255,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":7,"ty":4,"nm":"Mouth","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":80,"s":[0]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":110,"s":[6]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":150,"s":[6]},{"t":183,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[42.112,-135.582,0],"to":[-24.545,3.172,0],"ti":[24.545,-3.172,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-105.157,-116.55,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[-105.157,-116.55,0],"to":[2.55,-15.86,0],"ti":[-2.55,15.86,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":110,"s":[-89.856,-211.708,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[-89.856,-211.708,0],"to":[-2.55,15.86,0],"ti":[2.55,-15.86,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":183,"s":[-105.157,-116.55,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-105.157,-116.55,0],"to":[24.545,-3.172,0],"ti":[-24.545,3.172,0]},{"t":488,"s":[42.112,-135.582,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-116.317,-197.453,0],"ix":1,"l":2},"s":{"a":0,"k":[87.27,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,-3.563],[3.563,0],[0,0],[0,3.563],[-3.563,0],[0,0]],"o":[[0,3.563],[0,0],[-6.225,-0.115],[0,-3.563],[0,0],[3.563,0]],"v":[[23.822,-0.731],[8.24,7.182],[-7.692,7.547],[-24.005,-0.548],[-15.91,-5.355],[16.093,-5.173]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-116.226,-198.549],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":8,"ty":4,"nm":"MouthShadow","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":80,"s":[0]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":110,"s":[6]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":150,"s":[6]},{"t":183,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[42.532,-110.445,0],"to":[-24.545,2.696,0],"ti":[24.545,-2.696,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-104.737,-94.268,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[-104.737,-94.268,0],"to":[2.125,-15.384,0],"ti":[-2.125,15.384,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":110,"s":[-91.986,-186.572,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[-91.986,-186.572,0],"to":[-2.125,15.384,0],"ti":[2.125,-15.384,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":183,"s":[-104.737,-94.268,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-104.737,-94.268,0],"to":[24.545,-2.696,0],"ti":[-24.545,2.696,0]},{"t":488,"s":[42.532,-110.445,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-116.502,-198.532,0],"ix":1,"l":2},"s":{"a":0,"k":[80.778,77.774,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[2.559,-2.48],[8.027,-0.729],[0,0],[0,3.563],[-3.563,0],[0,0]],"o":[[-4.049,3.924],[0,0],[-3.563,0],[0,-3.563],[0,0],[3.563,0]],"v":[[18.774,-0.5],[0.948,6.484],[-0.448,6.18],[-20.774,-1.375],[-16.823,-6.451],[16.823,-6.451]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-116.226,-198.549],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":9,"ty":4,"nm":"R_Eye","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[-6.906,-269.509,0],"to":[-24.545,2.855,0],"ti":[24.545,-2.855,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-154.174,-252.38,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[-154.174,-252.38,0],"to":[7.225,-16.895,0],"ti":[-7.225,16.895,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":110,"s":[-110.822,-353.748,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[-110.822,-353.748,0],"to":[-7.225,16.895,0],"ti":[7.225,-16.895,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":183,"s":[-154.174,-252.38,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-154.174,-252.38,0],"to":[24.545,-2.855,0],"ti":[-24.545,2.855,0]},{"t":488,"s":[-6.906,-269.509,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-73.684,-307.572,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.54,0.54,0.54],"y":[1,1,1]},"o":{"x":[0.46,0.46,0.46],"y":[0,0,0]},"t":80,"s":[-93.088,130.261,100]},{"i":{"x":[0.54,0.54,0.54],"y":[1,1,1]},"o":{"x":[0.46,0.46,0.46],"y":[0,0,0]},"t":110,"s":[-79.289,114.273,100]},{"i":{"x":[0.54,0.54,0.54],"y":[1,1,1]},"o":{"x":[0.46,0.46,0.46],"y":[0,0,0]},"t":150,"s":[-79.289,114.273,100]},{"t":183,"s":[-93.088,130.261,100]}],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-10.206,0],[0,-5.767],[10.206,0],[0,5.767]],"o":[[10.206,0],[0,5.767],[-10.206,0],[0,-5.767]],"v":[[0,-1.066],[17.464,5.429],[0.287,15.871],[-16.239,6.416]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-73.578,-297.757],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[76.739,50.657],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 2","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[36.961,20.885],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-73.684,-314.985],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":10,"ty":4,"nm":"R_Upper 2","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":180,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[-6.959,-338.166,0],"to":[-24.864,3.172,0],"ti":[24.864,-3.172,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-156.14,-319.134,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":80,"s":[-156.14,-319.134,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":150,"s":[-156.14,-319.134,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-156.14,-319.134,0],"to":[24.864,-3.172,0],"ti":[-24.864,3.172,0]},{"t":488,"s":[-6.959,-338.166,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-75.876,-259.03,0],"ix":1,"l":2},"s":{"a":0,"k":[84.727,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-10,9.5]],"o":[[-1.229,-4.022],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":110,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-10,9.5]],"o":[[-1.229,-4.022],[-0.918,20.986],[10,-9.5]],"v":[[2.312,-199.679],[-16.938,-199.179],[-15.201,-165.636]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-10,9.5]],"o":[[-1.229,-4.022],[-0.918,20.986],[10,-9.5]],"v":[[2.312,-199.679],[-16.938,-199.179],[-15.201,-165.636]],"c":true}]},{"t":183,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-10,9.5]],"o":[[-1.229,-4.022],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]}],"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.582996503045,0.498070002537,0.662132352941,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-125.969,-6.787],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":11,"ty":4,"nm":"R_Lower 2","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[-4.632,-200.089,0],"to":[-24.651,3.172,0],"ti":[24.651,-3.172,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-152.538,-181.057,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":80,"s":[-152.538,-181.057,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":150,"s":[-152.538,-181.057,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-152.538,-181.057,0],"to":[24.651,-3.172,0],"ti":[-24.651,3.172,0]},{"t":488,"s":[-4.632,-200.089,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-75.876,-259.03,0],"ix":1,"l":2},"s":{"a":0,"k":[-93.088,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[{"i":[[1.719,13.287],[0.469,-10.713],[-10,9.5]],"o":[[-1.171,-9.049],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":110,"s":[{"i":[[1.719,13.287],[-1.243,-4.279],[-0.445,-11.025]],"o":[[-1.171,-9.049],[5.055,17.404],[0.556,13.782]],"v":[[23.952,-353.818],[4.702,-353.318],[14.996,-312.105]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[{"i":[[1.719,13.287],[-1.243,-4.279],[-0.445,-11.025]],"o":[[-1.171,-9.049],[5.055,17.404],[0.556,13.782]],"v":[[23.952,-353.818],[4.702,-353.318],[14.996,-312.105]],"c":true}]},{"t":183,"s":[{"i":[[1.719,13.287],[0.469,-10.713],[-10,9.5]],"o":[[-1.171,-9.049],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]}],"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.582996503045,0.498070002537,0.662132352941,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-125.969,-6.787],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":12,"ty":4,"nm":"L_Eye","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":60,"s":[0]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":69,"s":[0]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":99,"s":[6]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":444,"s":[6]},{"t":488,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[83.347,-269.509,0],"to":[-25.395,1.586,0],"ti":[19.763,5.234,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":55,"s":[-69.022,-259.993,0],"to":[-0.638,-0.476,0],"ti":[-0.638,-0.476,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[-69.022,-259.993,0],"to":[-0.638,-0.476,0],"ti":[-5.836,14.597,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":110,"s":[-34.008,-347.576,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[-34.008,-347.576,0],"to":[-5.836,14.597,0],"ti":[-0.638,-0.476,0]},{"i":{"x":0.6,"y":1},"o":{"x":0.46,"y":0},"t":183,"s":[-69.022,-259.993,0],"to":[-0.638,-0.476,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-69.022,-259.993,0],"to":[0,0,0],"ti":[-25.395,1.586,0]},{"t":488,"s":[83.347,-269.509,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-73.684,-307.572,0],"ix":1,"l":2},"s":{"a":0,"k":[87.27,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-10.206,0],[0,-5.767],[10.206,0],[0,5.767]],"o":[[10.206,0],[0,5.767],[-10.206,0],[0,-5.767]],"v":[[0,-1.066],[17.464,5.429],[0.287,15.871],[-16.239,6.416]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-73.578,-297.757],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[76.739,50.657],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 2","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[36.961,20.885],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-73.684,-314.985],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":13,"ty":4,"nm":"L_Upper","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":-180,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.64,"y":0},"t":7,"s":[84.035,-338.166,0],"to":[-25.501,1.586,0],"ti":[25.501,-1.586,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":55,"s":[-68.971,-328.65,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-68.971,-328.65,0],"to":[25.501,-1.586,0],"ti":[-25.501,1.586,0]},{"t":488,"s":[84.035,-338.166,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-75.876,-259.03,0],"ix":1,"l":2},"s":{"a":0,"k":[-79.432,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-10,9.5]],"o":[[-1.229,-4.022],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":110,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-3.779,1.74]],"o":[[-1.229,-4.022],[-0.918,20.986],[12.529,-5.768]],"v":[[111.617,-208.445],[92.367,-207.945],[106.696,-175.133]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-3.779,1.74]],"o":[[-1.229,-4.022],[-0.918,20.986],[12.529,-5.768]],"v":[[111.617,-208.445],[92.367,-207.945],[106.696,-175.133]],"c":true}]},{"t":183,"s":[{"i":[[3.916,12.813],[0.442,-2.522],[-10,9.5]],"o":[[-1.229,-4.022],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]}],"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.582996503045,0.498070002537,0.662132352941,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-125.969,-6.787],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":14,"ty":4,"nm":"L_Lower","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.63,"y":0},"t":7,"s":[81.853,-200.089,0],"to":[-24.439,1.586,0],"ti":[24.439,-1.586,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":55,"s":[-64.778,-190.573,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-64.778,-190.573,0],"to":[24.439,-1.586,0],"ti":[-24.439,1.586,0]},{"t":488,"s":[81.853,-200.089,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-75.876,-259.03,0],"ix":1,"l":2},"s":{"a":0,"k":[87.27,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[{"i":[[1.719,13.287],[0.469,-10.713],[-10,9.5]],"o":[[-1.171,-9.049],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":110,"s":[{"i":[[1.719,13.287],[0.5,-7.799],[-10,9.5]],"o":[[-1.171,-9.049],[-1.344,20.963],[10,-9.5]],"v":[[88.74,-337.016],[68.029,-339.438],[68.416,-294.938]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[{"i":[[1.719,13.287],[0.5,-7.799],[-10,9.5]],"o":[[-1.171,-9.049],[-1.344,20.963],[10,-9.5]],"v":[[88.74,-337.016],[68.029,-339.438],[68.416,-294.938]],"c":true}]},{"t":183,"s":[{"i":[[1.719,13.287],[0.469,-10.713],[-10,9.5]],"o":[[-1.171,-9.049],[-0.918,20.986],[10,-9.5]],"v":[[60.25,-272],[41,-271.5],[46.5,-227]],"c":true}]}],"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.582996503045,0.498070002537,0.662132352941,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-125.969,-6.787],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":15,"ty":4,"nm":"FACE","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":55,"s":[0]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":80,"s":[0]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":110,"s":[12.88]},{"i":{"x":[0.54],"y":[1]},"o":{"x":[0.46],"y":[0]},"t":150,"s":[12.88]},{"t":183,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.62,"y":0},"t":7,"s":[32.797,-250.117,0],"to":[0,3.172,0],"ti":[0,-3.172,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[32.797,-231.085,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[32.797,-231.085,0],"to":[5.313,-6.897,0],"ti":[-5.313,6.897,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":110,"s":[64.673,-272.466,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[64.673,-272.466,0],"to":[-5.313,6.897,0],"ti":[5.313,-6.897,0]},{"i":{"x":0.6,"y":0.6},"o":{"x":0.46,"y":0.46},"t":183,"s":[32.797,-231.085,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[32.797,-231.085,0],"to":[0,-3.172,0],"ti":[0,3.172,0]},{"t":488,"s":[32.797,-250.117,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-119.685,-285.38,0],"ix":1,"l":2},"s":{"a":0,"k":[87.27,130.261,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.62,"y":0},"t":7,"s":[{"i":[[-71.889,0],[4.926,-74.609],[57.097,1.316],[8.628,74.952]],"o":[[66.119,0],[-4.97,75.283],[-52.889,-1.219],[-8.703,-75.609]],"v":[[0,-136.609],[86.186,0],[0,136.609],[-86.186,0]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":55,"s":[{"i":[[-71.889,0],[4.926,-74.609],[57.097,1.316],[8.628,74.952]],"o":[[66.119,0],[-4.97,75.283],[-52.889,-1.219],[-8.703,-75.609]],"v":[[-156.331,-123.438],[-73.068,13.171],[-149.026,149.781],[-235.212,13.171]],"c":true}]},{"i":{"x":0.6,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[{"i":[[-71.889,0],[4.926,-74.609],[57.097,1.316],[8.628,74.952]],"o":[[66.119,0],[-4.97,75.283],[-52.889,-1.219],[-8.703,-75.609]],"v":[[-156.331,-123.438],[-73.068,13.171],[-149.026,149.781],[-235.212,13.171]],"c":true}]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[{"i":[[-71.889,0],[4.926,-74.609],[57.097,1.316],[8.628,74.952]],"o":[[66.119,0],[-4.97,75.283],[-52.889,-1.219],[-8.703,-75.609]],"v":[[-156.331,-123.438],[-73.068,13.171],[-149.026,149.781],[-235.212,13.171]],"c":true}]},{"t":488,"s":[{"i":[[-71.889,0],[4.926,-74.609],[57.097,1.316],[8.628,74.952]],"o":[[66.119,0],[-4.97,75.283],[-52.889,-1.219],[-8.703,-75.609]],"v":[[0,-136.609],[86.186,0],[0,136.609],[-86.186,0]],"c":true}]}],"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.005,0.837,0.837,0.837,0.503,0.919,0.919,0.919,1,1,1,1],"ix":9}},"s":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.62,"y":0},"t":7,"s":[-91.338,60.022],"to":[-23.056,-2.507],"ti":[23.056,2.507]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-229.674,44.982],"to":[0,0],"ti":[0,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":150,"s":[-229.674,44.982],"to":[0,0],"ti":[0,0]},{"i":{"x":0.38,"y":1},"o":{"x":0.46,"y":0},"t":444,"s":[-229.674,44.982],"to":[23.056,2.507],"ti":[-23.056,-2.507]},{"t":488,"s":[-91.338,60.022]}],"ix":5},"e":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.62,"y":0},"t":7,"s":[7.247,37.022],"to":[-28.745,-0.203],"ti":[28.745,0.203]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":55,"s":[-165.224,35.805],"to":[0,0],"ti":[0,0]},{"i":{"x":0.54,"y":0.54},"o":{"x":0.46,"y":0.46},"t":150,"s":[-165.224,35.805],"to":[0,0],"ti":[0,0]},{"i":{"x":0.38,"y":1},"o":{"x":0.46,"y":0},"t":444,"s":[-165.224,35.805],"to":[28.745,0.203],"ti":[-28.745,-0.203]},{"t":488,"s":[7.247,37.022]}],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-119.111,-285.391],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,99.832],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":16,"ty":4,"nm":"FaceSHADOW","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.5],"y":[1]},"o":{"x":[0.5],"y":[0]},"t":80,"s":[0]},{"i":{"x":[0.5],"y":[1]},"o":{"x":[0.5],"y":[0]},"t":110,"s":[6.308]},{"i":{"x":[0.5],"y":[1]},"o":{"x":[0.5],"y":[0]},"t":150,"s":[6.308]},{"t":183,"s":[0]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.62,"y":0},"t":7,"s":[27.737,-205.767,0],"to":[-16.115,0,0],"ti":[16.115,0,0]},{"i":{"x":0.5,"y":0.5},"o":{"x":0.46,"y":0.46},"t":55,"s":[-68.954,-205.767,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.5,"y":1},"o":{"x":0.5,"y":0},"t":80,"s":[-68.954,-205.767,0],"to":[3.573,-9.202,0],"ti":[-3.573,9.202,0]},{"i":{"x":0.5,"y":0.5},"o":{"x":0.5,"y":0.5},"t":110,"s":[-47.514,-260.977,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.5,"y":1},"o":{"x":0.5,"y":0},"t":150,"s":[-47.514,-260.977,0],"to":[-5.698,12.374,0],"ti":[3.573,-9.202,0]},{"i":{"x":0.6,"y":1},"o":{"x":0.5,"y":0},"t":183,"s":[-81.705,-186.735,0],"to":[-3.573,9.202,0],"ti":[-17.851,6.344,0]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[-68.954,-205.767,0],"to":[17.851,-6.344,0],"ti":[-15.726,3.172,0]},{"t":488,"s":[25.4,-224.798,0]}],"ix":2,"l":2},"a":{"a":0,"k":[-125.729,-285.38,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.5,0.5,0.5],"y":[1,1,1]},"o":{"x":[0.5,0.5,0.5],"y":[0,0,0]},"t":110,"s":[82.424,137.914,100]},{"i":{"x":[0.6,0.6,0.6],"y":[1,1,1]},"o":{"x":[0.5,0.5,0.5],"y":[0,0,0]},"t":150,"s":[82.424,137.914,100]},{"i":{"x":[0.7,0.7,0.7],"y":[1,1,1]},"o":{"x":[0.4,0.4,0.4],"y":[0,0,0]},"t":444,"s":[63.29,121.577,100]},{"t":488,"s":[86.324,121.577,100]}],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-71.889,0],[4.926,-74.609],[57.097,1.316],[8.628,74.952]],"o":[[66.119,0],[-4.97,75.283],[-52.889,-1.219],[-8.703,-75.609]],"v":[[0,-136.609],[86.186,0],[0,136.609],[-86.186,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.005,0,0,0,0.503,0,0,0,1,0,0,0,0.012,0,0.506,0.5,1,1],"ix":9}},"s":{"a":0,"k":[-21.946,160.597],"ix":5},"e":{"a":0,"k":[27.373,-98.146],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[-125.111,-285.391],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[107.719,104.845],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":0,"bm":0},{"ddd":0,"ind":17,"ty":4,"nm":"Body","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.63,"y":0},"t":7,"s":[787.294,649.466,0],"to":[0,-1.333,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":68,"s":[787.294,641.466,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":124,"s":[787.294,649.466,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":180.572,"s":[787.294,641.466,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":232.428,"s":[787.294,649.466,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":289,"s":[787.294,641.466,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":335,"s":[787.294,649.466,0],"to":[0,0,0],"ti":[0,0,0]},{"i":{"x":0.37,"y":1},"o":{"x":0.46,"y":0},"t":391.572,"s":[787.294,641.466,0],"to":[0,0,0],"ti":[0,-1.333,0]},{"t":476,"s":[787.294,649.466,0]}],"ix":2,"l":2},"a":{"a":0,"k":[6.327,3.861,0],"ix":1,"l":2},"s":{"a":0,"k":[156.856,105.088,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":1,"k":[{"i":{"x":0.54,"y":1},"o":{"x":0.63,"y":0},"t":7,"s":[{"i":[[109.176,9.464],[10.546,-223.953],[0,0],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[0,0],[4.362,148.868]],"o":[[-109.669,-9.506],[-4.529,96.17],[0,0],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0,0],[-4.686,-159.931]],"v":[[25.301,-445.624],[-104.499,-93.818],[-115.003,93.831],[-113.99,269.491],[-49.394,313.745],[75.533,314.457],[130.443,244.613],[120.195,77.344],[115.894,-102.955]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":55,"s":[{"i":[[113.077,-5.486],[-22.411,-50.104],[0.65,-73.896],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[-0.054,71.337],[22.839,65.643]],"o":[[-127.984,6.209],[43.316,96.841],[-0.515,58.621],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0.061,-80.14],[-45.365,-130.389]],"v":[[-93.279,-409.905],[-147.213,-126.29],[-102.253,88.96],[-112.715,230.525],[-67.244,312.121],[81.908,314.457],[145.744,275.461],[138.046,40.001],[96.769,-216.607]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":80,"s":[{"i":[[113.077,-5.486],[-22.411,-50.104],[0.65,-73.896],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[-0.054,71.337],[22.839,65.643]],"o":[[-127.984,6.209],[43.316,96.841],[-0.515,58.621],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0.061,-80.14],[-45.365,-130.389]],"v":[[-93.279,-409.905],[-147.213,-126.29],[-102.253,88.96],[-112.715,230.525],[-67.244,312.121],[81.908,314.457],[145.744,275.461],[138.046,40.001],[96.769,-216.607]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":110,"s":[{"i":[[110.716,-23.632],[-26.236,-81.999],[0.65,-73.896],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[-0.054,71.337],[18.697,55.658]],"o":[[-93.558,19.969],[19.735,61.68],[-0.515,58.621],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0.061,-80.139],[-46.446,-138.264]],"v":[[-58.853,-460.236],[-124.9,-150.644],[-109.903,85.713],[-113.627,295.468],[-53.219,313.745],[81.908,314.457],[147.005,273.838],[143.146,36.754],[110.794,-198.747]],"c":true}]},{"i":{"x":0.54,"y":1},"o":{"x":0.46,"y":0},"t":150,"s":[{"i":[[110.716,-23.632],[-26.236,-81.999],[0.65,-73.896],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[-0.054,71.337],[18.697,55.658]],"o":[[-93.558,19.969],[19.735,61.68],[-0.515,58.621],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0.061,-80.139],[-46.446,-138.264]],"v":[[-58.853,-460.236],[-124.9,-150.644],[-109.903,85.713],[-113.627,295.468],[-53.219,313.745],[81.908,314.457],[147.005,273.838],[143.146,36.754],[110.794,-198.747]],"c":true}]},{"i":{"x":0.6,"y":1},"o":{"x":0.46,"y":0},"t":183,"s":[{"i":[[74.749,-0.299],[-32.611,-56.612],[0.65,-73.896],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[-0.054,71.337],[22.839,65.643]],"o":[[-128.133,0.512],[52.954,91.926],[-0.515,58.621],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0.061,-80.14],[-45.365,-130.389]],"v":[[-93.279,-409.905],[-147.851,-111.678],[-102.252,88.96],[-112.715,230.525],[-67.244,312.121],[81.908,314.458],[145.744,275.461],[138.046,40.001],[96.769,-216.607]],"c":true}]},{"i":{"x":0.7,"y":1},"o":{"x":0.4,"y":0},"t":444,"s":[{"i":[[74.749,-0.299],[-32.611,-56.612],[0.65,-73.896],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[-0.054,71.337],[22.839,65.643]],"o":[[-128.133,0.512],[52.954,91.926],[-0.515,58.621],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0.061,-80.14],[-45.365,-130.389]],"v":[[-93.279,-409.905],[-147.851,-111.678],[-102.252,88.96],[-112.715,230.525],[-67.244,312.121],[81.908,314.458],[145.744,275.461],[138.046,40.001],[96.769,-216.607]],"c":true}]},{"t":488,"s":[{"i":[[109.176,9.464],[10.546,-223.953],[0,0],[0,0],[-69.749,-15.294],[-39.244,9.613],[0,0],[0,0],[4.362,148.868]],"o":[[-109.669,-9.506],[-4.529,96.17],[0,0],[0,0],[44.695,9.801],[68.949,-16.889],[0,0],[0,0],[-4.686,-159.931]],"v":[[25.301,-445.624],[-104.499,-93.818],[-115.003,93.831],[-113.99,269.491],[-49.394,313.745],[75.533,314.457],[130.443,244.613],[120.195,77.344],[115.894,-102.955]],"c":true}]}],"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"gf","o":{"a":0,"k":100,"ix":10},"r":1,"bm":0,"g":{"p":3,"k":{"a":0,"k":[0.005,0.084,0.133,0.345,0.503,0.144,0.278,0.461,1,0.203,0.423,0.576],"ix":9}},"s":{"a":0,"k":[12.462,76.207],"ix":5},"e":{"a":0,"k":[-0.769,938.446],"ix":6},"t":1,"nm":"Gradient Fill 1","mn":"ADBE Vector Graphic - G-Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[1.081,77.907],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,117.22],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Shape 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":492,"st":3,"bm":0},{"ddd":0,"ind":18,"ty":4,"nm":"Circle","sr":1,"ks":{"o":{"a":0,"k":52,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[772,608,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[99.339,99.339,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[865.141,865.141],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.948315010819,0.90793504902,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[20.57,-31.43],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":492,"op":492,"st":0,"bm":0,"hidden":0},{"ddd":0,"ind":19,"ty":4,"nm":"BG","parent":17,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[52.679,-24.178,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[63.753,95.158,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ty":"rc","d":1,"s":{"a":0,"k":[1755.547,1295.344],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"r":{"a":0,"k":0,"ix":4},"nm":"Rectangle Path 1","mn":"ADBE Vector Shape - Rect","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.272141460344,0.799970260321,0.878431372549,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[17.773,27.672],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Rectangle 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":492,"op":492,"st":0,"bm":0,"hidden":0}],"markers":[]}
\ No newline at end of file
diff --git a/docs/inline.md b/docs/inline.md
old mode 100644
new mode 100755
index 0f2d466..ec96fee
--- a/docs/inline.md
+++ b/docs/inline.md
@@ -1,42 +1,41 @@
-# GeekTG.inline Docs [beta]
+# Hikka.inline Docs [beta]
 ## –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –±—É–¥–µ—Ç –ø–æ–ø–æ–ª–Ω—è—Ç—å—Å—è
 ### –ü—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–æ @hikariatama —Å –ª—é–±–æ–≤—å—é –∏ –∑–∞–±–æ—Ç–æ–π :ÔΩ•Ôæü‚úß(Íàç·¥óÍàç)‚úßÔΩ•Ôæü:
-–ù–∞—á–∏–Ω–∞—è —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è **GeekTG 3.0.0**, –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –¥–æ—Å—Ç—É–ø–Ω—ã –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ **inline**.
-
 –î–ª—è –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–æ—Å—Ç—É–ø–µ–Ω –∞—Ç—Ä–∏–±—É—Ç `inline`. –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è —á–µ—Ä–µ–∑ –Ω–µ–≥–æ.
 
 ## –°–∫–æ–ø—ã
 –ú–æ–¥—É–ª–∏, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ **–ª—é–±—ã–µ** –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —ç—Ç–æ–≥–æ —Ä–µ–∂–∏–º–∞ –¥–æ–ª–∂–Ω—ã —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–∫–æ–ø—É (–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π):
 `# scope: inline`
 –ï—Å–ª–∏ –≤—ã **–Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å** –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –º–æ–¥—É–ª—è –Ω–∞ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–º FTG (`if hasattr(self, 'inline')`), –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ç–∞–∫–∂–µ —É–∫–∞–∑–∞—Ç—å —Å–∫–æ–ø (–Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —é–∑–µ—Ä–±–æ—Ç–æ–º, –Ω–æ –ø–æ–º–æ–≥–∞–µ—Ç –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞–º –º–æ–¥—É–ª–µ–π):
-`# scope: geektg_only`
-–ï—Å–ª–∏ –≤ –º–æ–¥—É–ª–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è **–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è** –≤–µ—Ä—Å–∏—è GeekTG, –¥–ª—è —ç—Ç–æ–≥–æ —Ç–æ–∂–µ –µ—Å—Ç—å —Å–∫–æ–ø (–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è **—Ç–æ–ª—å–∫–æ** –Ω–∞ GeekTG 3.1.15+):
-`# scope: geektg_min 3.1.15`
+`# scope: hikka_only`
+–ï—Å–ª–∏ –≤ –º–æ–¥—É–ª–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è **–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è** –≤–µ—Ä—Å–∏—è Hikka, –¥–ª—è —ç—Ç–æ–≥–æ —Ç–æ–∂–µ –µ—Å—Ç—å —Å–∫–æ–ø:
+`# scope: hikka_min 1.0.0`
 
 ## –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–æ—Ä–º—ã
-–î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–Ω–æ–ø–æ–∫ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏, –∏—Å–ø–æ–ª—å–∑—É–π –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π **–º–µ–Ω–µ–¥–∂–µ—Ä —Ñ–æ—Ä–º**:
+–î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–Ω–æ–ø–æ–∫ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏, –∏—Å–ø–æ–ª—å–∑—É–π –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π [–º–µ–Ω–µ–¥–∂–µ—Ä —Ñ–æ—Ä–º](https://github.com/hikariatama/Hikka/blob/master/hikka/inline/form.py#L40):
 
 ### –†–µ—Ñ–µ—Ä–µ–Ω—Å:
 ```python
 async def form(
-        self,
-        text: str,
-        message: Union[Message, int],
-        reply_markup: List[List[dict]] = None,
-        force_me: bool = True,
-        always_allow: List[int] = None,
-        ttl: Union[int, bool] = False,
-    ) -> Union[str, bool]:
+    self,
+    text: str,
+    message: Union[Message, int],
+    reply_markup: List[List[dict]] = None,
+    force_me: bool = True,
+    always_allow: Union[List[list], None] = None,
+    ttl: Union[int, bool] = False,
+    on_unload: Union[FunctionType, None] = None,
+) -> Union[str, bool]:
 ```
 ### –ü—Ä–∏–º–µ—Ä:
 ```python
 await self.inline.form(
-    text="üìä Poll GeekTG vs. FTG\nüï∂ GeekTG: No votes\nüòî FTG: No votes",
+    text="üìä Poll Hikka vs. FTG\nüë©‚Äçüé§ Hikka: No votes\nüòî FTG: No votes",
     message=message,
     reply_markup=[
         [
             {
-                "text": "GeekTG",
+                "text": "Hikka",
                 "callback": self.vote,
                 "args": [False]
             }
@@ -97,8 +96,26 @@ await self.inline.form(
 > ‚ö†Ô∏è **–ü—Ä–∏ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–∏ –æ—à–∏–±–∫–∏ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ñ–æ—Ä–º—ã, exception –Ω–µ –ø–æ–¥–Ω–∏–º–∞–µ—Ç—Å—è!**
 
 ## –ì–∞–ª–µ—Ä–µ—è
-–ù–∞—á–∏–Ω–∞—è —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è 3.1.22 –≤ GeekTG –¥–æ—Å—Ç—É–ø–Ω—ã inline-–≥–∞–ª–µ—Ä–µ–∏. –í—ã–∑–≤–∞—Ç—å –µ–µ –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ:
+–í Hikka –¥–æ—Å—Ç—É–ø–Ω—ã [inline-–≥–∞–ª–µ—Ä–µ–∏](https://github.com/hikariatama/Hikka/blob/master/hikka/inline/gallery.py#L42). –í—ã–∑–≤–∞—Ç—å –µ–µ –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ:
 
+### –†–µ—Ñ–µ—Ä–µ–Ω—Å:
+```python
+async def gallery(
+    self,
+    message: Union[Message, int],
+    next_handler: Union[FunctionType, List[str]],
+    caption: Union[str, FunctionType] = "",
+    *,
+    force_me: bool = True,
+    always_allow: Union[list, None] = None,
+    ttl: Union[int, bool] = False,
+    on_unload: Union[FunctionType, None] = None,
+    preload: Union[bool, int] = False,
+    gif: bool = False,
+    _reattempt: bool = False,
+) -> Union[bool, str]:
+```
+### –ü—Ä–∏–º–µ—Ä
 ```python
 def generate_caption() -> str:
     return random.choice(["–î–∞", "–ù–µ—Ç"])
@@ -107,14 +124,52 @@ async def photo() -> str:
     return (await utils.run_sync(requests.get, "https://api.catboys.com/img")).json()["url"]
 
 await self.inline.gallery(
-    caption=generate_caption,
     message=message,
     next_handler=photo,
+    caption=generate_caption,
 )
 ```
 –ó–¥–µ—Å—å `generate_caption` - —Ñ—É–Ω–∫—Ü–∏—è, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–æ—Ç–æ
 `photo` - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –≤–æ–∑–≤—Ä–∞—â–∞—è —Å–ª–µ–¥—É—é—â—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É (–ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É Next)
 > –í–º–µ—Å—Ç–æ —Ñ—É–Ω–∫—Ü–∏–∏ `generate_caption` –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –æ–±—ã—á–Ω—É—é —Å—Ç—Ä–æ–∫—É –∏–ª–∏ –ª—è–º–±–¥–∞-—Ñ—É–Ω–∫—Ü–∏—é
+## –ò–Ω–ª–∞–π–Ω-–≥–∞–ª–µ—Ä–µ—è
+–ï—Å–ª–∏ —Ç—ã —Ö–æ—á–µ—à—å, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–≥ –≤—ã–∑–≤–∞—Ç—å –≥–∞–ª–µ—Ä–µ—é —á–µ—Ä–µ–∑ –∏–Ω–ª–∞–π–Ω-–∑–∞–ø—Ä–æ—Å –∫ –±–æ—Ç—É (@hikka_xxxxxx_bot), –∏—Å–ø–æ–ª—å–∑—É–π (–≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –≥–∞–ª–µ—Ä–µ–∏)[https://github.com/hikariatama/Hikka/blob/master/hikka/inline/gallery.py#L253]
+
+### –†–µ—Ñ–µ—Ä–µ–Ω—Å:
+```python
+async def query_gallery(
+    self,
+    query: InlineQuery,
+    items: List[dict],
+    *,
+    force_me: bool = True,
+    always_allow: Union[list, None] = None,
+) -> None:
+```
+### –ü—Ä–∏–º–µ—Ä
+```python
+async def catboy_inline_handler(self, query: InlineQuery) -> None:
+    """
+    Send Catboys
+    """
+    await self.inline.query_gallery(
+        query,
+        [
+            {
+                "title": "üë©‚Äçüé§ Catboy",
+                "description": "Send catboy photo",
+                "next_handler": photo,
+                "thumb_handler": photo,  # Optional
+                "caption": lambda: f"<i>Enjoy! {utils.escape_html(utils.ascii_face())}</i>",  # Optional
+                # Because of ^ this lambda, face will be generated every time the photo is switched
+
+                # "caption": f"<i>Enjoy! {utils.escape_html(utils.ascii_face())}</i>",
+                # If you make it without lambda ^, it will be generated once
+            }
+        ],
+    )
+
+```
 
 ## –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π (–≤–∞—Ä–∏–∞–Ω—Ç 1)
 –ï—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞–∂–∞—Ç–∏–π. –ï—Å–ª–∏ —Ç—ã —Ö–æ—á–µ—à—å, —á—Ç–æ–±—ã –∫–Ω–æ–ø–∫–∞ –∂–∏–ª–∞ **–±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ** –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ä–µ–º–µ–Ω–∏, —Ç—ã –º–æ–∂–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø—Ü–∏—é `data`.
@@ -187,11 +242,11 @@ call.form  # optional: Contains info about form
 > ‚ö†Ô∏è **–≠—Ç–∏ –∞—Ç—Ä–∏–±—É—Ç—ã –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –≤ –æ–±—ã—á–Ω–æ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ.** –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –Ω—É–∂–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å—Ä–µ–¥—Å—Ç–≤–∞–º–∏ aiogram –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Ä—É—á–Ω—É—é, –∏—Å–ø–æ–ª—å–∑—É—è `await self.inline._bot.edit_message_text`!
 
 ## Inline –∫–æ–º–∞–Ω–¥—ã (@bot ...)
-–î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–Ω–ª–∞–π–Ω –∫–æ–º–∞–Ω–¥ GeekTG –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏, —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –ø–æ —à–∞–±–ª–æ–Ω—É, –Ω–∞–ø–æ–¥–æ–±–∏–µ –∫–æ–º–∞–Ω–¥–∞–º.
+–î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–Ω–ª–∞–π–Ω –∫–æ–º–∞–Ω–¥ Hikka –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏, —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –ø–æ —à–∞–±–ª–æ–Ω—É, –Ω–∞–ø–æ–¥–æ–±–∏–µ –∫–æ–º–∞–Ω–¥–∞–º.
 ```python
-from ..inline import GeekInlineQuery
+from ..inline import InlineQuery
 
-async def <name>_inline_handler(self, query: GeekInlineQuery) -> None:
+async def <name>_inline_handler(self, query: InlineQuery) -> None:
     # Process request
 ```
 –í–Ω—É—Ç—Ä–∏ –æ–±—ä–µ–∫—Ç–∞ query –¥–æ—Å—Ç—É–ø–µ–Ω –∞—Ç—Ä–∏–±—É—Ç args, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –≤ —Å–µ–±–µ —Ç–µ–∫—Å—Ç, —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã (@bot <name> **some text here**)
@@ -203,7 +258,7 @@ async def <name>_inline_handler(self, query: GeekInlineQuery) -> None:
 await query.answer(
     [
         InlineQueryResultArticle(
-            id=rand(20),
+            id=utils.rand(20),
             title="Show available inline commands",
             description=f"You have {len(_help.splitlines())} available command(-s)",
             input_message_content=InputTextMessageContent(
@@ -221,8 +276,16 @@ await query.answer(
 ```
 –í –∫–∞–∂–¥–æ–º –∏–∑ —Ç–∞–∫–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑—ã–≤–∞—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä. –ß—Ç–æ–±—ã –Ω–µ —É—Å–ª–æ–∂–Ω—è—Ç—å –∂–∏–∑–Ω—å, –º–æ–∂–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏–∑ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –º–æ–¥—É–ª—è:
 ```python
-from ..inline import rand
+from .. import utils
 ```
 –ó–∞—Ç–µ–º –º–æ–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å rand(20) –≤ –∑–Ω–∞—á–µ–Ω–∏–∏ –∞—Ç—Ä–∏–±—É—Ç–∞ id
 
+### –ü–æ–ª–µ–∑–Ω—ã–µ —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è
+
+`await query.e400()` - –ù–µ–≤–µ—Ä–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
+`await query.e403()` - –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ä–µ—Å—É—Ä—Å—É
+`await query.e404()` - –¢—Ä–µ–±—É–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
+`await query.e426()` - –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —é–∑–µ—Ä–±–æ—Ç–∞
+`await query.e500()` - –û—à–∏–±–∫–∞ –º–æ–¥—É–ª—è. –°–º–æ—Ç—Ä–∏ –ª–æ–≥–∏
+
 
diff --git a/docs/mods.md b/docs/mods.md
old mode 100644
new mode 100755
index 50e419b..bd840b6
--- a/docs/mods.md
+++ b/docs/mods.md
@@ -37,7 +37,7 @@ async def client_ready(self, client, db) -> None:
 ```python
 async def on_unload(self) -> None:
 ```
-–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –≤ –º–æ–º–µ–Ω—Ç –≤—ã–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª—è. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è - 5 —Å–µ–∫—É–Ω–¥, –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –∫–æ–¥ –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Å–±—Ä–æ—Å–∞ –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ –∏ –¥—Ä—É–≥–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π, –Ω—É–∂–Ω—ã—Ö –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ \ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è. –ú–µ—Ç–æ–¥ –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –≤ **GeekTG 2.0.4+**
+–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –≤ –º–æ–º–µ–Ω—Ç –≤—ã–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª—è. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è - 5 —Å–µ–∫—É–Ω–¥, –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –∫–æ–¥ –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Å–±—Ä–æ—Å–∞ –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ –∏ –¥—Ä—É–≥–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π, –Ω—É–∂–Ω—ã—Ö –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ \ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è.
 
 ```python
 async def testcmd(self, message: Message) -> None:
@@ -109,26 +109,53 @@ run_sync(func: FunctionType, *args, **kwargs) -> coroutine
 
 –†–µ–ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –∏—Ö —Å–º–µ—â–µ–Ω–∏–π
 ```python
-relocate_entities(entities: ListLike, offset: int, text: str = None) -> list
+def relocate_entities(
+    entities: list,
+    offset: int,
+    text: Union[str, None] = None,
+) -> list:
 ```
 ---
 
-–û–¥–∏–Ω –∏–∑ —Å–∞–º—ã—Ö —á–∞—Å—Ç–æ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –º–µ—Ç–æ–¥–æ–≤. –û—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –∑–∞–¥–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –ï—Å–ª–∏ –æ–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ, —Ç–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç, –µ—Å–ª–∏ –ø–æ–ª—É—á–µ–Ω–æ, —Ç–æ –æ—Ç–≤–µ—á–∞–µ—Ç.
+–û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ (—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å, –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ, –∏–Ω–∞—á–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ)
 ```python
-answer(message: Message, response: str, *args, **kwargs) -> Many
+async def answer(message: Message, response: str, **kwargs) -> list:
 ```
 ---
 
-–ü–æ–ª—É—á–∞–µ—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π —Ü–µ–ª—å—é –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã
+–ü–æ–ª—É—á–∏—Ç—å ID –≤–µ—Ä–æ—è—Ç–Ω–æ–π —Ü–µ–ª–∏
 ```python
-get_target(message: Message, arg_no: int = 0) -> int or None
+async def get_target(message: Message, arg_no: int = 0) -> Union[int, None]:
 ```
 ---
 
-–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–≤—É—Ö —Å–ª–æ–≤–∞—Ä–µ–π
+–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ —Å–ª–æ–≤–∞—Ä—è
 ```python
-merge(a: dict, b: dict) -> dict
+def merge(a: dict, b: dict) -> dict:
 ```
+---
+
+–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª (–µ—Å–ª–∏ —ç—Ç–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è), –∏ –≤–µ—Ä–Ω—É—Ç—å –µ–≥–æ entity
+```python
+async def asset_channel(
+    client: "TelegramClient",  # noqa: F821
+    title: str,
+    description: str,
+) -> Tuple[Channel, bool]
+```
+---
+
+–ü–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–º–∞–ª–∏–Ω–∫ –Ω–∞ entity
+```python
+get_link(a: dict, b: dict) -> dict
+```
+---
+
+–†–∞–∑–¥–µ–ª–∏—Ç—å `_list` –Ω–∞ —á–∞–Ω–∫–∏ –ø–æ `n`
+```python
+chunks(a: dict, b: dict) -> dict
+```
+
 
 
 ## strings
diff --git a/friendly-telegram/__init__.py b/friendly-telegram/__init__.py
deleted file mode 100755
index c2b5de6..0000000
--- a/friendly-telegram/__init__.py
+++ /dev/null
@@ -1,3 +0,0 @@
-# pylint: skip-file # This file is empty, no need to lint it
-# Otherwise we get warnings about invalid-name because the module is called friendly-telegram not friendly_telegram
-# Placeholder to make this a module, so we can do relative imports
diff --git a/friendly-telegram/bot_avatar.png b/friendly-telegram/bot_avatar.png
deleted file mode 100755
index 68701c6..0000000
Binary files a/friendly-telegram/bot_avatar.png and /dev/null differ
diff --git a/friendly-telegram/database/backend.py b/friendly-telegram/database/backend.py
deleted file mode 100755
index 7acae9b..0000000
--- a/friendly-telegram/database/backend.py
+++ /dev/null
@@ -1,237 +0,0 @@
-import asyncio
-import logging
-
-import telethon
-from telethon.errors.rpcerrorlist import (
-    MessageEditTimeExpiredError,
-    MessageNotModifiedError,
-)
-from telethon.tl.custom import Message as CustomMessage
-from telethon.tl.functions.channels import CreateChannelRequest, DeleteChannelRequest
-from telethon.tl.types import Message
-import json
-import os
-
-from .. import main, utils
-
-ORIGIN = "/".join(main.__file__.split("/")[:-2])
-
-logger = logging.getLogger(__name__)
-
-
-class CloudBackend:
-    def __init__(self, client):
-        self._client = client
-        self._me = None
-        self.db = None
-        self._assets = None
-        self._anti_double_lock = asyncio.Lock()
-        self._anti_double_asset_lock = asyncio.Lock()
-        self._data_already_exists = False
-        self._assets_already_exists = False
-        self.close = lambda: None
-
-    async def init(self, trigger_refresh):
-        self._me = await self._client.get_me(True)
-        self._db_path = os.path.join(ORIGIN, f"config-{self._me.user_id}.json")
-        self._callback = trigger_refresh
-
-    async def _find_data_channel(self):
-        async for dialog in self._client.iter_dialogs(None, ignore_migrated=True):
-            if dialog.name == f"friendly-{self._me.user_id}-data" and dialog.is_channel:
-                members = await self._client.get_participants(dialog, limit=2)
-                if len(members) != 1:
-                    continue
-                logger.debug(f"Found data chat! It is {dialog.id}.")
-                return dialog.entity
-
-    async def _make_data_channel(self):
-        async with self._anti_double_lock:
-            if self._data_already_exists:
-                return await self._find_data_channel()
-            self._data_already_exists = True
-            return (
-                await self._client(
-                    CreateChannelRequest(
-                        f"friendly-{self._me.user_id}-data",
-                        "// Don't touch",
-                        megagroup=True,
-                    )
-                )
-            ).chats[0]
-
-    async def _find_asset_channel(self):
-        async for dialog in self._client.iter_dialogs(None, ignore_migrated=True):
-            if (
-                dialog.name == f"friendly-{self._me.user_id}-assets"
-                and dialog.is_channel
-            ):
-                members = await self._client.get_participants(dialog, limit=2)
-                if len(members) != 1:
-                    continue
-                logger.debug(f"Found asset chat! It is {dialog.id}.")
-                return dialog.entity
-
-    async def _make_asset_channel(self):
-        async with self._anti_double_asset_lock:
-            if self._assets_already_exists:
-                return await self._find_data_channel()
-            self._assets_already_exists = True
-            return (
-                await self._client(
-                    CreateChannelRequest(
-                        f"friendly-{self._me.user_id}-assets",
-                        "// Don't touch",
-                        megagroup=True,
-                    )
-                )
-            ).chats[0]
-
-    async def do_download(self, force_from_data_channel=False):
-        """
-        Attempt to download the database.
-        Return the database (as unparsed JSON) or None
-        """
-        if main.get_config_key("use_file_db") and not force_from_data_channel:
-            try:
-                with open(self._db_path, "r", encoding="utf-8") as f:
-                    data = json.dumps(json.loads(f.read()))
-            except Exception:
-                data = await self.do_download(force_from_data_channel=True)
-                await self.do_upload(data)
-
-            return data
-
-        if not self.db:
-            self.db = await self._find_data_channel()
-
-            if not self.db:
-                logging.debug("No DB, returning")
-                return None
-
-            self._client.add_event_handler(
-                self._callback,
-                telethon.events.messageedited.MessageEdited(chats=[self.db]),
-            )
-
-        msgs = self._client.iter_messages(entity=self.db, reverse=True)
-
-        data = ""
-        lastdata = ""
-
-        async for msg in msgs:
-            if isinstance(msg, Message):
-                data += lastdata
-                lastdata = msg.message
-            else:
-                logger.debug(f"Found service message {msg}")
-
-        return data
-
-    async def do_upload(self, data):
-        """
-        Attempt to upload the database.
-        Return True or throw
-        """
-
-        if main.get_config_key("use_file_db"):
-            try:
-                with open(self._db_path, "w", encoding="utf-8") as f:
-                    f.write(data or "{}")
-            except Exception:
-                logger.exception("Database save failed!")
-                raise
-
-            return True
-
-        if not self.db:
-            self.db = await self._find_data_channel()
-            if not self.db:
-                self.db = await self._make_data_channel()
-
-            self._client.add_event_handler(
-                self._callback,
-                telethon.events.messageedited.MessageEdited(chats=[self.db]),
-            )
-
-        msgs = await self._client.get_messages(entity=self.db, reverse=True)
-
-        ops = []
-        sdata = data
-        newmsg = False
-        for msg in msgs:
-            if isinstance(msg, Message):
-                if len(sdata):
-                    if msg.id == msgs[-1].id:
-                        newmsg = True
-                    if sdata[:4096] != msg.message:
-                        ops += [
-                            msg.edit(f"<code>{utils.escape_html(sdata[:4096])}</code>")
-                        ]
-                    sdata = sdata[4096:]
-                elif msg.id != msgs[-1].id:
-                    ops += [msg.delete()]
-
-        if await self._do_ops(ops):
-            return await self.do_upload(data)
-
-        while len(
-            sdata
-        ):  # Only happens if newmsg is True or there was no message before
-            newmsg = True
-            await self._client.send_message(self.db, utils.escape_html(sdata[:4096]))
-            sdata = sdata[4096:]
-
-        if newmsg:
-            await self._client.send_message(self.db, "Please ignore this chat.")
-
-        return True
-
-    async def _do_ops(self, ops):
-        try:
-            for r in await asyncio.gather(*ops, return_exceptions=True):
-                if isinstance(r, MessageNotModifiedError):
-                    logging.debug("db not modified", exc_info=r)
-                elif isinstance(r, Exception):
-                    raise r  # Makes more sense to raise even for MessageEditTimeExpiredError
-                elif not isinstance(r, Message):
-                    logging.debug("unknown ret from gather, %r", r)
-        except MessageEditTimeExpiredError:
-            logging.debug("Making new channel.")
-            _db = self.db
-            self.db = None
-            await self._client(DeleteChannelRequest(channel=_db))
-            return True
-
-        return False
-
-    async def store_asset(self, message):
-        if not self._assets:
-            self._assets = await self._find_asset_channel()
-
-        if not self._assets:
-            self._assets = await self._make_asset_channel()
-
-        return (
-            (await self._client.send_message(self._assets, message)).id
-            if isinstance(message, (Message, CustomMessage))
-            else (
-                await self._client.send_message(
-                    self._assets, file=message, force_document=True
-                )
-            ).id
-        )
-
-    async def fetch_asset(self, id_):
-        if not self._assets:
-            self._assets = await self._find_asset_channel()
-
-        if not self._assets:
-            return None
-
-        ret = await self._client.get_messages(self._assets, ids=[id_])
-
-        if not ret:
-            return None
-
-        return ret[0]
diff --git a/friendly-telegram/database/frontend.py b/friendly-telegram/database/frontend.py
deleted file mode 100755
index 84d9840..0000000
--- a/friendly-telegram/database/frontend.py
+++ /dev/null
@@ -1,155 +0,0 @@
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2019 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-import asyncio
-import json
-import logging
-
-
-class NotifyingFuture(asyncio.Future):
-    def __init__(self, *args, **kwargs):
-        self.__to_notify_on_await = kwargs.pop("on_await", None)
-        super().__init__(*args, **kwargs)
-
-    def __await__(self):
-        if callable(self.__to_notify_on_await):
-            self.__to_notify_on_await()
-        return super().__await__()
-
-
-# Not thread safe, use the event loop!
-class Database(dict):
-    def __init__(self, backend, noop=False):
-        super().__init__()
-        self._noop = noop or backend is None
-        self._backend = backend
-        self._pending = None
-        self._loading = True
-        self._waiter = asyncio.Event()
-        self._sync_future = None
-        # We use a future because we need await-ability and we will be delaying by 10s, but
-        # because we are gonna frequently be changing the data, we want to avoid floodwait
-        # and to do that we will discard most requests. However, attempting to await any request
-        # should return a future corresponding to the next time that we flush the database.
-        # To achieve this, we have one future stored here (the next time we flush the db) and we
-        # always return that from set(). However, if someone decides to await set() much later
-        # than when they called set(), it will already be finished. Luckily, we return a future,
-        # not a reference to _sync_future, so it will be the correct future, and set_result will
-        # not already have been called. Simple, right?
-
-    def __repr__(self):
-        return object.__repr__(self)
-
-    async def init(self):
-        if self._backend is None:
-            self._loading = False
-            self._waiter.set()
-            return
-
-        await self._backend.init(self.reload)
-        db = await self._backend.do_download()
-
-        if db is not None:
-            try:
-                self.update(**json.loads(db))
-            except Exception:
-                # Don't worry if its corrupted. Just set it to {} and let it be fixed on next upload
-                pass
-
-        self._loading = False
-        self._waiter.set()
-
-    async def close(self):
-        try:
-            await self.save()
-        except Exception:
-            logging.info("Database close failed", exc_info=True)
-
-        if self._backend is not None:
-            self._backend.close()
-
-    def save(self):
-        if self._pending is not None and not self._pending.cancelled():
-            self._pending.cancel()
-
-        if self._sync_future is None or self._sync_future.done():
-            self._sync_future = NotifyingFuture(on_await=self._cancel_then_set)
-
-        self._pending = asyncio.ensure_future(
-            _wait_then_do(10, self._set)
-        )  # Delay database ops by 10s
-        return self._sync_future
-
-    def get(self, owner, key, default=None):
-        try:
-            return self[owner][key]
-        except KeyError:
-            return default
-
-    def set(self, owner, key, value):
-        super().setdefault(owner, {})[key] = value
-        return self.save()
-
-    def _cancel_then_set(self):
-        if self._pending is not None and not self._pending.cancelled():
-            self._pending.cancel()
-
-        self._pending = asyncio.ensure_future(self._set())
-        # Restart the task, but without the delay, because someone is waiting for us
-
-    async def _set(self):
-        if self._noop:
-            self._sync_future.set_result(True)
-            return
-
-        if self._loading:
-            await self._waiter.wait()
-
-        try:
-            await self._backend.do_upload(json.dumps(self))
-        except Exception as e:
-            self._sync_future.set_exception(e)
-
-        self._sync_future.set_result(True)
-
-    async def reload(self, event):
-        if self._noop:
-            return
-
-        try:
-            self._waiter.clear()
-            self._loading = True
-
-            if self._pending is not None:
-                self._pending.cancel()
-
-            db = await self._backend.do_download()
-            self.clear()
-            self.update(**json.loads(db))
-        finally:
-            self._loading = False
-            self._waiter.set()
-
-    async def store_asset(self, message):
-        return await self._backend.store_asset(message)
-
-    async def fetch_asset(self, message):
-        return await self._backend.fetch_asset(message)
-
-
-async def _wait_then_do(time, task, *args, **kwargs):
-    await asyncio.sleep(time)
-    return await task(*args, **kwargs)
diff --git a/friendly-telegram/dispatcher.py b/friendly-telegram/dispatcher.py
deleted file mode 100755
index d034e80..0000000
--- a/friendly-telegram/dispatcher.py
+++ /dev/null
@@ -1,434 +0,0 @@
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-#    Modded by GeekTG Team
-
-import asyncio
-import collections
-import logging
-import re
-from telethon import types
-import traceback
-
-from . import utils, main, security, loader
-
-# Keys for layout switch
-ru_keys = """—ë–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é.–Å"‚Ññ;%:?–ô–¶–£–ö–ï–ù–ì
-–®–©–ó–•–™–§–´–í–ê–ü–†–û–õ–î–ñ–≠/–Ø–ß–°–ú–ò–¢–¨–ë–Æ, """
-en_keys = """`qwertyuiop[]asdfghjkl;'zxcvbnm,./~@#$%^&QWERTYUIOP{
-}ASDFGHJKL:"|ZXCVBNM<>? """
-
-
-def _decrement_ratelimit(delay, data, key, severity):
-    def inner():
-        data[key] = max(0, data[key] - severity)
-
-    asyncio.get_event_loop().call_later(delay, inner)
-
-
-class CommandDispatcher:
-    def __init__(self, modules, db, no_nickname=False):
-        self._modules = modules
-        self._db = db
-        self.security = security.SecurityManager(db)
-        self.no_nickname = no_nickname
-        self._ratelimit_storage_user = collections.defaultdict(int)
-        self._ratelimit_storage_chat = collections.defaultdict(int)
-        self._ratelimit_max_user = db.get(__name__, "ratelimit_max_user", 30)
-        self._ratelimit_max_chat = db.get(__name__, "ratelimit_max_chat", 100)
-        self.check_security = self.security.check
-
-    async def init(self, client):
-        await self.security.init(client)
-        me = await client.get_me()
-        self._me = me.id
-        self._cached_username = me.username.lower() if me.username else str(me.id)
-
-    async def _handle_ratelimit(self, message, func):
-        if await self.security.check(
-            message, security.OWNER | security.SUDO | security.SUPPORT
-        ):
-            return True
-        func = getattr(func, "__func__", func)
-        ret = True
-        chat = self._ratelimit_storage_chat[message.chat_id]
-        if message.sender_id:
-            user = self._ratelimit_storage_user[message.sender_id]
-            severity = (5 if getattr(func, "ratelimit", False) else 2) * (
-                (user + chat) // 30 + 1
-            )
-            user += severity
-            self._ratelimit_storage_user[message.sender_id] = user
-            if user > self._ratelimit_max_user:
-                ret = False
-            else:
-                self._ratelimit_storage_chat[message.chat_id] = chat
-
-            _decrement_ratelimit(
-                self._ratelimit_max_user * severity,
-                self._ratelimit_storage_user,
-                message.sender_id,
-                severity,
-            )
-        else:
-            severity = (5 if getattr(func, "ratelimit", False) else 2) * (
-                chat // 15 + 1
-            )
-
-        chat += severity
-
-        if chat > self._ratelimit_max_chat:
-            ret = False
-
-        _decrement_ratelimit(
-            self._ratelimit_max_chat * severity,
-            self._ratelimit_storage_chat,
-            message.chat_id,
-            severity,
-        )
-
-        return ret
-
-    async def handle_command(self, event):
-        """Handle all commands"""
-        if not hasattr(event, "message") or not hasattr(event.message, "message"):
-            return
-
-        # Fix bug when after reacting message command gets executed
-        if getattr(event, "reactions", False):
-            return
-
-        # Empty string evaluates to False, so the `or` activates
-        prefix = self._db.get(main.__name__, "command_prefix", False) or "."
-        if isinstance(prefix, list):
-            prefix = prefix[0]
-            self._db.set(main.__name__, "command_prefix", prefix)
-
-        change = str.maketrans(ru_keys + en_keys, en_keys + ru_keys)
-
-        if event.message.message.startswith(prefix):
-            translated = False
-        elif event.message.message.startswith(str.translate(prefix, change)):
-            prefix = str.translate(prefix, change)
-            translated = True
-        else:
-            return
-
-        logging.debug("Incoming command!")
-
-        if event.sticker or event.dice or event.audio:
-            logging.debug("Ignoring invisible or potentially forwarded command.")
-            return
-
-        if event.via_bot_id:
-            logging.debug("Ignoring inline bot.")
-            return
-
-        message = utils.censor(event.message)
-        blacklist_chats = self._db.get(main.__name__, "blacklist_chats", [])
-        whitelist_chats = self._db.get(main.__name__, "whitelist_chats", [])
-        whitelist_modules = self._db.get(main.__name__, "whitelist_modules", [])
-
-        if utils.get_chat_id(message) in blacklist_chats or (
-            whitelist_chats and utils.get_chat_id(message) not in whitelist_chats
-        ):
-            logging.debug("Message is blacklisted")
-            return
-
-        if (
-            message.out
-            and len(message.message) > len(prefix)
-            and message.message[: len(prefix) * 2] == prefix * 2
-            and message.message != len(message.message) // len(prefix) * prefix
-        ):
-            # Allow escaping commands using .'s
-            entities = utils.relocate_entities(
-                message.entities, -len(prefix), message.message
-            )
-            await message.edit(
-                message.message[len(prefix) :], parse_mode=lambda s: (s, entities or ())
-            )
-            return
-
-        logging.debug(message)
-        # Make sure we don't get confused about spaces or other stuff in the prefix
-        message.message = message.message[len(prefix) :]
-
-        if translated:
-            message.message = str.translate(message.message, change)
-
-        if not message.message:
-            return  # Message is just the prefix
-
-        utils.relocate_entities(message.entities, -len(prefix))
-
-        try:
-            initiator = event.sender_id
-        except Exception:
-            initiator = 0
-
-        command = message.message.split(maxsplit=1)[0]
-        tag = command.split("@", maxsplit=1)
-
-        if len(tag) == 2:
-            if tag[1] == "me":
-                if not message.out:
-                    return
-            elif tag[1].lower() != self._cached_username:
-                return
-        elif (
-            event.mentioned
-            and event.message is not None
-            and event.message.message is not None
-            and "@" + self._cached_username not in event.message.message
-        ):
-            pass
-        elif (
-            not event.is_private
-            and not self.no_nickname
-            and not event.out
-            and not self._db.get(main.__name__, "no_nickname", False)
-            and command not in self._db.get(main.__name__, "nonickcmds", [])
-            and initiator not in self._db.get(main.__name__, "nonickusers", [])
-        ):
-            logging.debug("Ignoring message without nickname")
-            return
-
-        txt, func = self._modules.dispatch(tag[0])
-
-        if func is not None:
-            if not await self._handle_ratelimit(message, func):
-                return
-
-            if not await self.security.check(message, func):
-                return
-
-            if message.is_channel and message.is_group:
-                my_id = (await message.client.get_me(True)).user_id
-                chat = await message.get_chat()
-                if (
-                    chat.title.startswith(f"friendly-{my_id}-")
-                    or chat.title == "geektg-log"
-                ):
-                    logging.warning("Ignoring message in datachat \\ logging chat")
-                    return
-
-            message.message = txt + message.message[len(command) :]
-
-            if (
-                str(utils.get_chat_id(message)) + "." + func.__self__.__module__
-                in blacklist_chats
-            ):
-                logging.debug("Command is blacklisted in chat")
-                return
-
-            if (
-                whitelist_modules
-                and f"{utils.get_chat_id(message)}.{func.__self__.__module__}"
-                not in whitelist_modules
-            ):  # noqa
-                logging.debug("Command is not whitelisted in chat")
-                return
-
-            if self._db.get(main.__name__, "grep", False):
-                if "||grep" in message.text or "|| grep" in message.text:
-                    message.raw_text = message.raw_text.replace(
-                        "||grep", "|grep"
-                    ).replace("|| grep", "| grep")
-                    message.text = message.text.replace("||grep", "|grep").replace(
-                        "|| grep", "| grep"
-                    )
-                    message.message = message.message.replace(
-                        "||grep", "|grep"
-                    ).replace("|| grep", "| grep")
-                else:
-                    grep = False
-                    if "| grep" in message.text or "|grep" in message.text:
-                        grep = message.text[message.text.find("grep ") + 5 :]
-                        message.text = message.text[
-                            : (
-                                message.text.find(" | grep")
-                                if message.text.find(" | grep") > 0
-                                else message.text.find("|grep")
-                            )
-                        ]  # noqa
-
-                    if grep:
-                        ungrep = False
-
-                        if "-v" in grep:
-                            ungrep = grep[
-                                grep.find("-v ")
-                                + 3 : (
-                                    grep.find("grep") if "grep" in grep else len(grep)
-                                )
-                            ]
-                            grep = grep[: grep.find("-v")] + (
-                                grep[grep.find("grep") + 4 :] if "grep" in grep else ""
-                            )
-
-                        grep = utils.escape_html(grep).strip() if grep else False
-                        ungrep = utils.escape_html(ungrep).strip() if ungrep else False
-
-                        old_edit = message.edit
-                        old_reply = message.reply
-                        old_respond = message.respond
-
-                        def process_text(text):
-                            nonlocal grep, ungrep
-                            res = []
-
-                            for line in text.split("\n"):
-                                if (
-                                    grep
-                                    and grep in re.sub("<.*?>", "", line)
-                                    and (
-                                        not ungrep
-                                        or ungrep not in re.sub("<.*?>", "", line)
-                                    )
-                                ):
-                                    res.append(line.replace(grep, f"<u>{grep}</u>"))
-
-                                if (
-                                    not grep
-                                    and ungrep
-                                    and ungrep not in re.sub("<.*?>", "", line)
-                                ):
-                                    res.append(line)
-
-                            cont = (
-                                (f"contain <b>{grep}</b>" if grep else "")
-                                + (" and" if grep and ungrep else "")
-                                + (
-                                    (" do not contain <b>" + ungrep + "</b>")
-                                    if ungrep
-                                    else ""
-                                )
-                            )
-
-                            if res:
-                                text = f"<i>üí¨ Lines that {cont}:</i>\n" + (
-                                    "\n".join(res)
-                                )
-                            else:
-                                text = f"üí¨ <i>No lines that {cont}</i>"
-
-                            return text
-
-                        async def my_edit(text, *args, **kwargs):
-                            text = process_text(text)
-                            kwargs["parse_mode"] = "HTML"
-                            return await old_edit(text, *args, **kwargs)
-
-                        async def my_reply(text, *args, **kwargs):
-                            text = process_text(text)
-                            kwargs["parse_mode"] = "HTML"
-                            return await old_reply(text, *args, **kwargs)
-
-                        async def my_respond(text, *args, **kwargs):
-                            text = process_text(text)
-                            kwargs["parse_mode"] = "HTML"
-                            return await old_respond(text, *args, **kwargs)
-
-                        message.edit = my_edit
-                        message.reply = my_reply
-                        message.respond = my_respond
-
-            # Feature for CommandsLogger module
-            try:
-                if getattr(loader, "mods", False):
-                    for mod in loader.mods:
-                        if mod.name == "CommandsLogger":
-                            await mod.process_log(message)
-            except Exception:
-                pass
-
-            try:
-                await func(message)
-            except Exception:
-                logging.exception("Command failed")
-                if not self._db.get(main.__name__, "inlinelogs", True):
-                    try:
-                        txt = f"<b>üö´ Command</b> <code>{prefix}{utils.escape_html(message.message)}</code><b> failed!</b>"
-                        await (message.edit if message.out else message.reply)(txt)
-                    except Exception:
-                        pass
-                else:
-                    try:
-                        exc = traceback.format_exc()
-                        exc = "\n".join(
-                            exc.split("\n")[1:]
-                        )  # Remove `Traceback (most recent call last):`
-                        txt = f"<b>üö´ Command</b> <code>{prefix}{utils.escape_html(message.message)}</code><b> failed!</b>\n\n<b>‚õë Traceback:</b>\n<code>{exc}</code>"
-                        await (message.edit if message.out else message.reply)(txt)
-                    except Exception:
-                        pass
-
-    async def handle_incoming(self, event):
-        """Handle all incoming messages"""
-        logging.debug("Incoming message!")
-        message = utils.censor(getattr(event, "message", event))
-        blacklist_chats = self._db.get(main.__name__, "blacklist_chats", [])
-        whitelist_chats = self._db.get(main.__name__, "whitelist_chats", [])
-        whitelist_modules = self._db.get(main.__name__, "whitelist_modules", [])
-
-        if utils.get_chat_id(message) in blacklist_chats or (
-            whitelist_chats and utils.get_chat_id(message) not in whitelist_chats
-        ):
-            logging.debug("Message is blacklisted")
-            return
-
-        for func in self._modules.watchers:
-            bl = self._db.get(main.__name__, "disabled_watchers", {})
-            modname = str(func.__self__.__class__.strings["name"])
-            if (
-                modname in bl
-                and isinstance(message, types.Message)
-                and (
-                    "*" in bl[modname]
-                    or utils.get_chat_id(message) in bl[modname]
-                    or "only_chats" in bl[modname]
-                    and message.is_private
-                    or "only_pm" in bl[modname]
-                    and not message.is_private
-                    or "out" in bl[modname]
-                    and not message.out
-                    or "in" in bl[modname]
-                    and message.out
-                )
-            ):
-                logging.debug(f"Ignored watcher of module {modname}")
-                continue
-
-            if (
-                f"{str(utils.get_chat_id(message))}.{func.__self__.__module__}"
-                in blacklist_chats
-            ):
-                logging.debug("Command is blacklisted in chat")
-                continue
-
-            if (
-                whitelist_modules
-                and (f"{str(utils.get_chat_id(message))}." + func.__self__.__module__)
-                not in whitelist_modules
-            ):
-                logging.debug("Command is not whitelisted in chat")
-                continue
-
-            try:
-                await func(message)
-            except Exception as e:
-                logging.exception(f"Error running watcher {e}")
diff --git a/friendly-telegram/heroku.py b/friendly-telegram/heroku.py
deleted file mode 100755
index eb8cfb4..0000000
--- a/friendly-telegram/heroku.py
+++ /dev/null
@@ -1,119 +0,0 @@
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-#    Modded by GeekTG Team
-
-"""Handles heroku uploads"""
-
-import json
-import logging
-import os
-
-import heroku3
-from git import Repo
-from git.exc import InvalidGitRepositoryError
-from telethon.sessions import StringSession
-
-from . import utils
-
-
-def publish(clients, key, api_token=None, create_new=True, full_match=False):
-    """Push to heroku"""
-    logging.debug("Configuring heroku...")
-
-    data = json.dumps(
-        {
-            getattr(client, "phone", ""): StringSession.save(client.session)
-            for client in clients
-        }
-    )
-    app, config = get_app(data, key, api_token, create_new, full_match)
-
-    config["authorization_strings"] = data
-    config["heroku_api_token"] = key
-
-    if api_token is not None:
-        config["api_id"] = api_token.ID
-        config["api_hash"] = api_token.HASH
-
-    app.update_buildpacks(
-        [
-            "https://github.com/heroku/heroku-buildpack-python",
-            "https://github.com/GeekTG/Heroku-BuildPack",
-            "https://github.com/jonathanong/heroku-buildpack-ffmpeg-latest",
-        ]
-    )
-
-    repo = get_repo()
-    url = app.git_url.replace("https://", f"https://api:{key}@")
-
-    if "heroku" in repo.remotes:
-        remote = repo.remote("heroku")
-        remote.set_url(url)
-    else:
-        remote = repo.create_remote("heroku", url)
-
-    remote.push(refspec="HEAD:refs/heads/master")
-
-    return app
-
-
-def get_app(
-    authorization_strings, key, api_token=None, create_new=True, full_match=False
-):
-    heroku = heroku3.from_key(key)
-    app = None
-
-    for poss_app in heroku.apps():
-        config = poss_app.config()
-
-        if "authorization_strings" not in config:
-            continue
-
-        if api_token is None or (
-            config["api_id"] == api_token.ID and config["api_hash"] == api_token.HASH
-        ):
-            if full_match and config["authorization_strings"] != authorization_strings:
-                continue
-
-            app = poss_app
-            break
-
-    if app is None:
-        if api_token is None or not create_new:
-            logging.error("%r", {app: repr(app.config) for app in heroku.apps()})
-            raise RuntimeError("Could not identify app!")
-
-        app = heroku.create_app(stack_id_or_name="heroku-18", region_id_or_name="us")
-        config = app.config()
-
-    return app, config
-
-
-def get_repo():
-    """Helper to get the repo, making it if not found"""
-    try:
-        repo = Repo(os.path.dirname(utils.get_base_dir()))
-    except InvalidGitRepositoryError:
-        repo = Repo.init(os.path.dirname(utils.get_base_dir()))
-        origin = repo.create_remote(
-            "origin", "https://github.com/GeekTG/Friendly-Telegram"
-        )
-        origin.fetch()
-        repo.create_head("master", origin.refs.master)
-        repo.heads.master.set_tracking_branch(origin.refs.master)
-        repo.heads.master.checkout(True)
-    return repo
diff --git a/friendly-telegram/inline.py b/friendly-telegram/inline.py
deleted file mode 100755
index e06f819..0000000
--- a/friendly-telegram/inline.py
+++ /dev/null
@@ -1,1306 +0,0 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-from typing import Union, Any, List
-
-from aiogram import Bot, Dispatcher
-import aiogram
-
-import re
-import time
-import random
-import asyncio
-
-from telethon.tl.types import Message
-
-from telethon.errors.rpcerrorlist import YouBlockedUserError, InputUserDeactivatedError
-
-from telethon.tl.functions.contacts import UnblockRequest
-from telethon.utils import get_display_name
-
-from aiogram.types import (  # skipcq: PYL-C0412
-    InputTextMessageContent,
-    InlineQuery,
-    InlineKeyboardMarkup,
-    InlineKeyboardButton,
-    InlineQueryResultArticle,
-    CallbackQuery,
-    ChosenInlineResult,
-    InlineQueryResultPhoto,
-    InputMediaPhoto,
-)
-
-from aiogram.types import Message as AiogramMessage
-
-from aiogram.utils.exceptions import Unauthorized
-
-from . import utils
-import logging
-import requests
-import io
-import functools
-from types import FunctionType
-
-import inspect
-
-logger = logging.getLogger(__name__)
-
-photo = io.BytesIO(
-    requests.get(
-        "https://github.com/GeekTG/Friendly-Telegram/raw/master/friendly-telegram/bot_avatar.png"
-    ).content
-)
-photo.name = "avatar.png"
-
-
-class InlineCall:
-    def __init__(self):
-        self.delete = None
-        self.unload = None
-        self.edit = None
-        super().__init__()
-
-
-class BotMessage(AiogramMessage):
-    def __init__(self):
-        super().__init__()
-
-
-class GeekInlineQuery:
-    def __init__(self, inline_query: InlineQuery) -> None:
-        self.inline_query = inline_query
-
-        # Inherit original `InlineQuery` attributes for
-        # easy access
-        for attr in dir(inline_query):
-            if attr.startswith("__") and attr.endswith("__"):
-                continue  # Ignore magic attrs
-
-            try:
-                setattr(self, attr, getattr(inline_query, attr))
-            except AttributeError:
-                pass  # There are some non-writable native attrs
-                # So just ignore them
-
-        self.args = (
-            self.inline_query.query.split(maxsplit=1)[1]
-            if len(self.inline_query.query.split()) > 1
-            else ""
-        )
-
-
-def rand(size: int) -> str:
-    """Return random string of len `size`"""
-    return "".join(
-        [random.choice("abcdefghijklmnopqrstuvwxyz1234567890") for _ in range(size)]
-    )
-
-
-def array_sum(array: list) -> Any:
-    """Performs basic sum operation on array"""
-    result = []
-    for item in array:
-        result += item
-
-    return result
-
-
-async def edit(
-    text: str,
-    reply_markup: List[List[dict]] = None,
-    force_me: Union[bool, None] = None,
-    always_allow: Union[List[int], None] = None,
-    self: Any = None,
-    query: Any = None,
-    form: Any = None,
-    form_uid: Any = None,
-    inline_message_id: Union[str, None] = None,
-    disable_web_page_preview: bool = True,
-) -> None:
-    """Do not edit or pass `self`, `query`, `form`, `form_uid` params, they are for internal use only"""
-    if reply_markup is None:
-        reply_markup = []
-
-    if not isinstance(text, str):
-        logger.error("Invalid type for `text`")
-        return False
-
-    if isinstance(reply_markup, list):
-        form["buttons"] = reply_markup
-    if isinstance(force_me, bool):
-        form["force_me"] = force_me
-    if isinstance(always_allow, list):
-        form["always_allow"] = always_allow
-    try:
-        await self.bot.edit_message_text(
-            text,
-            inline_message_id=inline_message_id or query.inline_message_id,
-            parse_mode="HTML",
-            disable_web_page_preview=disable_web_page_preview,
-            reply_markup=self._generate_markup(form_uid),
-        )
-    except aiogram.utils.exceptions.MessageNotModified:
-        try:
-            await query.answer()
-        except aiogram.utils.exceptions.InvalidQueryID:
-            pass  # Just ignore that error, bc we need to just
-            # remove preloader from user's button, if message
-            # was deleted
-
-    except aiogram.utils.exceptions.RetryAfter as e:
-        logger.info(f"Sleeping {e.timeout}s on aiogram FloodWait...")
-        await asyncio.sleep(e.timeout)
-        return await edit(
-            text,
-            reply_markup,
-            force_me,
-            always_allow,
-            self,
-            query,
-            form,
-            form_uid,
-            inline_message_id,
-        )
-    except aiogram.utils.exceptions.MessageIdInvalid:
-        try:
-            await query.answer(
-                "I should have edited some message, but it is deleted :("
-            )
-        except aiogram.utils.exceptions.InvalidQueryID:
-            pass  # Just ignore that error, bc we need to just
-            # remove preloader from user's button, if message
-            # was deleted
-
-
-async def custom_next_handler(
-    call: CallbackQuery,
-    caption: str = None,
-    btn_call_data: str = None,
-    self=None,
-    func: FunctionType = None,
-) -> None:
-    try:
-        new_url = await func()
-        if not isinstance(new_url, (str, bool)):
-            raise Exception(
-                f"Invalid type returned by `next_handler`. Expected `str` or `False`, got `{type(new_url)}`"
-            )
-    except Exception:
-        logger.exception("Exception while trying to parse new photo")
-        await call.answer("Error occurred", show_alert=True)
-        return
-
-    if not new_url:
-        await call.answer("No photos left", show_alert=True)
-        return
-
-    markup = InlineKeyboardMarkup()
-    markup.add(InlineKeyboardButton("Next ‚û°Ô∏è", callback_data=btn_call_data))
-
-    _caption = caption if isinstance(caption, str) or not callable(caption) else caption()
-
-    try:
-        await self.bot.edit_message_media(
-            inline_message_id=call.inline_message_id,
-            media=InputMediaPhoto(media=new_url, caption=_caption, parse_mode="HTML"),
-            reply_markup=markup,
-        )
-    except Exception:
-        logger.exception("Exception while trying to edit media")
-        await call.answer("Error occurred", show_alert=True)
-        return
-
-
-async def delete(self: Any = None, form: Any = None, form_uid: Any = None) -> bool:
-    """Params `self`, `form`, `form_uid` are for internal use only, do not try to pass them"""
-    try:
-        await self._client.delete_messages(form["chat"], [form["message_id"]])
-        del self._forms[form_uid]
-    except Exception:
-        return False
-
-    return True
-
-
-async def unload(self: Any = None, form_uid: Any = None) -> bool:
-    """Params `self`, `form_uid` are for internal use only, do not try to pass them"""
-    try:
-        del self._forms[form_uid]
-    except Exception:
-        return False
-
-    return True
-
-
-async def answer(
-    text: str = None,
-    mod: Any = None,
-    message: AiogramMessage = None,
-    parse_mode: str = "HTML",
-    disable_web_page_preview: bool = True,
-    **kwargs,
-) -> bool:
-    try:
-        await mod.bot.send_message(
-            message.chat.id,
-            text,
-            parse_mode=parse_mode,
-            disable_web_page_preview=disable_web_page_preview,
-            **kwargs,
-        )
-    except Exception:
-        return False
-
-    return True
-
-
-class InlineManager:
-    def __init__(self, client, db, allmodules) -> None:
-        """Initialize InlineManager to create forms"""
-        self._client = client
-        self._db = db
-        self._allmodules = allmodules
-
-        self._token = db.get("geektg.inline", "bot_token", False)
-
-        self._forms = {}
-        self._galleries = {}
-        self._custom_map = {}
-
-        self.fsm = {}
-
-        self._markup_ttl = 60 * 60 * 24
-
-        self.init_complete = False
-
-    def ss(self, user: Union[str, int], state: Union[str, bool]) -> bool:
-        if not isinstance(user, (str, int)):
-            logger.error(
-                f"Invalid type for `user` in `ss` (expected `str or int` got `{type(user)}`)"
-            )
-            return False
-
-        if not isinstance(state, (str, bool)):
-            logger.error(
-                f"Invalid type for `state` in `ss` (expected `str or bool` got `{type(state)}`)"
-            )
-            return False
-
-        if state:
-            self.fsm[str(user)] = state
-        elif str(user) in self.fsm:
-            del self.fsm[str(user)]
-
-        return True
-
-    def gs(self, user: Union[str, int]) -> Union[bool, str]:
-        if not isinstance(user, (str, int)):
-            logger.error(
-                f"Invalid type for `user` in `gs` (expected `str or int` got `{type(user)}`)"
-            )
-            return False
-
-        return self.fsm.get(str(user), False)
-
-    def check_inline_security(self, func, user):
-        """Checks if user with id `user` is allowed to run function `func`"""
-        allow = user in [self._me] + self._client.dispatcher.security._owner  # skipcq: PYL-W0212
-
-        if not hasattr(func, "__doc__") or not func.__doc__ or allow:
-            return allow
-
-        doc = func.__doc__
-
-        for line in doc.splitlines():
-            line = line.strip()
-            if line.startswith("@allow:"):
-                allow_line = line.split(":")[1].strip()
-
-                # First we check for possible group limits
-                # like `sudo`, `support`, `all`. Then check
-                # for the occurrence of user in overall string
-                # This allows dev to use any delimiter he wants
-                if (
-                    "all" in allow_line
-                    or "sudo" in allow_line
-                    and user in self._client.dispatcher.security._sudo
-                    or "support" in allow_line
-                    and user in self._client.dispatcher.security._support
-                    or str(user) in allow_line
-                ):
-                    allow = True
-
-        # But don't hurry to return value, we need to check,
-        # if there are any limits
-        for line in doc.splitlines():
-            line = line.strip()
-            if line.startswith("@restrict:"):
-                restrict = line.split(":")[1].strip()
-
-                if (
-                    "all" in restrict
-                    or "sudo" in restrict
-                    and user in self._client.dispatcher.security._sudo
-                    or "support" in restrict
-                    and user in self._client.dispatcher.security._support
-                    or str(user) in restrict
-                ):
-                    allow = True
-
-        return allow
-
-    async def _create_bot(self) -> None:
-        # This is called outside of conversation, so we can start the new one
-        # We create new bot
-        logger.info("User don't have bot, attempting creating new one")
-        async with self._client.conversation("@BotFather", exclusive=False) as conv:
-            m = await conv.send_message("/newbot")
-            r = await conv.get_response()
-
-            if "20" in r.raw_text:
-                return False
-
-            await m.delete()
-            await r.delete()
-
-            # Set its name to user's name + GeekTG Userbot
-            m = await conv.send_message(f"ü§ñ GeekTG Userbot of {self._name}")
-            r = await conv.get_response()
-
-            await m.delete()
-            await r.delete()
-
-            # Generate and set random username for bot
-            uid = rand(6)
-            username = f"GeekTG_{uid}_Bot"
-
-            m = await conv.send_message(username)
-            r = await conv.get_response()
-
-            await m.delete()
-            await r.delete()
-
-            # Set bot profile pic
-            m = await conv.send_message("/setuserpic")
-            r = await conv.get_response()
-
-            await m.delete()
-            await r.delete()
-
-            m = await conv.send_message(username)
-            r = await conv.get_response()
-
-            await m.delete()
-            await r.delete()
-
-            try:
-                m = await conv.send_file(photo)
-                r = await conv.get_response()
-            except Exception:
-                # In case user was not able to send photo to
-                # BotFather, it is not a critical issue, so
-                # just ignore it
-                m = await conv.send_message("/cancel")
-                r = await conv.get_response()
-
-            await m.delete()
-            await r.delete()
-
-        # Re-attempt search. If it won't find newly created (or not created?) bot
-        # it will return `False`, that's why `init_complete` will be `False`
-        return await self._assert_token(False)
-
-    async def _assert_token(
-        self, create_new_if_needed=True, revoke_token=False
-    ) -> None:
-        # If the token is set in db
-        if self._token:
-            # Just return `True`
-            return True
-
-        logger.info("Bot token not found in db, attempting search in BotFather")
-        # Start conversation with BotFather to attempt search
-        async with self._client.conversation("@BotFather", exclusive=False) as conv:
-            # Wrap it in try-except in case user banned BotFather
-            try:
-                # Try sending command
-                m = await conv.send_message("/token")
-            except YouBlockedUserError:
-                # If user banned BotFather, unban him
-                await self._client(UnblockRequest(id="@BotFather"))
-                # And resend message
-                m = await conv.send_message("/token")
-
-            r = await conv.get_response()
-
-            await m.delete()
-            await r.delete()
-
-            # User do not have any bots yet, so just create new one
-            if not hasattr(r, "reply_markup") or not hasattr(r.reply_markup, "rows"):
-                # Cancel current conversation (search)
-                # bc we don't need it anymore
-                await conv.cancel_all()
-
-                return await self._create_bot() if create_new_if_needed else False
-
-            for row in r.reply_markup.rows:
-                for button in row.buttons:
-                    if re.search(r"@geektg_[0-9a-zA-Z]{6}_bot", button.text, re.I):
-                        m = await conv.send_message(button.text)
-                        r = await conv.get_response()
-
-                        if revoke_token:
-                            await m.delete()
-                            await r.delete()
-
-                            m = await conv.send_message("/revoke")
-                            r = await conv.get_response()
-
-                            await m.delete()
-                            await r.delete()
-
-                            m = await conv.send_message(button.text)
-                            r = await conv.get_response()
-
-                        token = r.raw_text.splitlines()[1]
-
-                        # Save token to database, now this bot is ready-to-use
-                        self._db.set("geektg.inline", "bot_token", token)
-                        self._token = token
-
-                        await m.delete()
-                        await r.delete()
-
-                        # Enable inline mode or change its
-                        # placeholder in case it is not set
-                        m = await conv.send_message("/setinline")
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        m = await conv.send_message(button.text)
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        m = await conv.send_message("GeekQuery")
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        m = await conv.send_message("/setinlinefeedback")
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        m = await conv.send_message(button.text)
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        m = await conv.send_message("Enabled")
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        # Set bot profile pic
-                        m = await conv.send_message("/setuserpic")
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        m = await conv.send_message(button.text)
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        m = await conv.send_file(photo)
-                        r = await conv.get_response()
-
-                        await m.delete()
-                        await r.delete()
-
-                        # Return `True` to say, that everything is okay
-                        return True
-
-        # And we are not returned after creation
-        return await self._create_bot() if create_new_if_needed else False
-
-    async def _cleaner(self) -> None:
-        """Cleans outdated _forms"""
-        while True:
-            for form_uid, form in self._forms.copy().items():
-                if form["ttl"] < time.time():
-                    del self._forms[form_uid]
-
-            await asyncio.sleep(10)
-
-    async def _reassert_token(self) -> None:
-        is_token_asserted = await self._assert_token(revoke_token=True)
-        if not is_token_asserted:
-            self.init_complete = False
-        else:
-            await self._register_manager(ignore_token_checks=True)
-
-    async def _dp_revoke_token(self, inited=True) -> None:
-        if inited:
-            await self._stop()
-            logger.error("Got polling conflict. Attempting token revocation...")
-
-        self._db.set("geektg.inline", "bot_token", None)
-        self._token = None
-        if inited:
-            asyncio.ensure_future(self._reassert_token())
-        else:
-            return await self._reassert_token()
-
-    async def _register_manager(
-        self, after_break=False, ignore_token_checks=False
-    ) -> None:
-        # Get info about user to use it in this class
-        me = await self._client.get_me()
-        self._me = me.id
-        self._name = get_display_name(me)
-
-        if not ignore_token_checks:
-            # Assert that token is set to valid, and if not,
-            # set `init_complete` to `False` and return
-            is_token_asserted = await self._assert_token()
-            if not is_token_asserted:
-                self.init_complete = False
-                return
-
-        # We successfully asserted token, so set `init_complete` to `True`
-        self.init_complete = True
-
-        # Create bot instance and dispatcher
-        self.bot = Bot(token=self._token)
-        self._bot = self.bot  # This is a temporary alias so the
-        # developers can adapt their code
-        self._dp = Dispatcher(self.bot)
-
-        # Get bot username to call inline queries
-        try:
-            self.bot_username = (await self.bot.get_me()).username
-            self._bot_username = self.bot_username  # This is a temporary alias so the
-            # developers can adapt their code
-        except Unauthorized:
-            logger.critical("Token expired, revoking...")
-            return await self._dp_revoke_token(False)
-
-        # Start the bot in case it can send you messages
-        try:
-            m = await self._client.send_message(self.bot_username, "/start")
-        except (InputUserDeactivatedError, ValueError):
-            self._db.set("geektg.inline", "bot_token", None)
-            self._token = False
-
-            if not after_break:
-                return await self._register_manager(True)
-
-            self.init_complete = False
-            return False
-        except Exception:
-            self.init_complete = False
-            logger.critical("Initialization of inline manager failed!")
-            logger.exception("due to")
-            return False
-
-        await self._client.delete_messages(self.bot_username, m)
-
-        # Register required event handlers inside aiogram
-        self._dp.register_inline_handler(
-            self._inline_handler, lambda inline_query: True
-        )
-        self._dp.register_callback_query_handler(
-            self._callback_query_handler, lambda query: True
-        )
-        self._dp.register_chosen_inline_handler(
-            self._chosen_inline_handler, lambda chosen_inline_query: True
-        )
-        self._dp.register_message_handler(
-            self._message_handler, lambda *args: True, content_types=["any"]
-        )
-
-        old = self.bot.get_updates
-        revoke = self._dp_revoke_token
-
-        async def new(*args, **kwargs):
-            nonlocal revoke, old
-            try:
-                return await old(*args, **kwargs)
-            except aiogram.utils.exceptions.TerminatedByOtherGetUpdates:
-                await revoke()
-            except aiogram.utils.exceptions.Unauthorized:
-                logger.critical("Got Unauthorized")
-                await self._stop()
-
-        self.bot.get_updates = new
-
-        # Start polling as the separate task, just in case we will need
-        # to force stop this coro. It should be cancelled only by `stop`
-        # because it stops the bot from getting updates
-        self._task = asyncio.ensure_future(self._dp.start_polling())
-        self._cleaner_task = asyncio.ensure_future(self._cleaner())
-
-    async def _message_handler(self, message: AiogramMessage) -> None:
-        """Processes incoming messages"""
-        if message.chat.type != "private":
-            return
-
-        for mod in self._allmodules.modules:
-            if not hasattr(mod, "aiogram_watcher"):
-                continue
-
-            setattr(
-                message, "answer", functools.partial(answer, mod=self, message=message)
-            )
-
-            try:
-                await mod.aiogram_watcher(message)
-            except BaseException:
-                logger.exception("Error on running aiogram watcher!")
-
-    async def _stop(self) -> None:
-        self._task.cancel()
-        self._dp.stop_polling()
-        self._cleaner_task.cancel()
-
-    def _generate_markup(self, form_uid: Union[str, list]) -> InlineKeyboardMarkup:
-        """Generate markup for form"""
-        markup = InlineKeyboardMarkup()
-
-        for row in (
-            self._forms[form_uid]["buttons"] if isinstance(form_uid, str) else form_uid
-        ):
-            for button in row:
-                if "callback" in button and "_callback_data" not in button:
-                    button["_callback_data"] = rand(30)
-
-                if "input" in button and "_switch_query" not in button:
-                    button["_switch_query"] = rand(10)
-
-        for row in (
-            self._forms[form_uid]["buttons"] if isinstance(form_uid, str) else form_uid
-        ):
-            line = []
-            for button in row:
-                try:
-                    if "url" in button:
-                        line += [
-                            InlineKeyboardButton(
-                                button["text"], url=button.get("url", None)
-                            )
-                        ]
-                    elif "callback" in button:
-                        line += [
-                            InlineKeyboardButton(
-                                button["text"], callback_data=button["_callback_data"]
-                            )
-                        ]
-                    elif "input" in button:
-                        line += [
-                            InlineKeyboardButton(
-                                button["text"],
-                                switch_inline_query_current_chat=button["_switch_query"]
-                                + " ",
-                            )
-                        ]
-                    elif "data" in button:
-                        line += [
-                            InlineKeyboardButton(
-                                button["text"], callback_data=button["data"]
-                            )
-                        ]
-                    else:
-                        logger.warning(
-                            "Button have not been added to "
-                            "form, because it is not structured "
-                            f"properly. {button}"
-                        )
-                except KeyError:
-                    logger.exception(
-                        "Error while forming markup! Probably, you "
-                        "passed wrong type combination for button. "
-                        "Contact developer of module."
-                    )
-                    return False
-
-            markup.row(*line)
-
-        return markup
-
-    async def _inline_handler(self, inline_query: InlineQuery) -> None:
-        """Inline query handler (forms' calls)"""
-        # Retrieve query from passed object
-        query = inline_query.query
-
-        # If we didn't get any query, return help
-        if not query:
-            _help = ""
-            for mod in self._allmodules.modules:
-                if (
-                    not hasattr(mod, "inline_handlers")
-                    or not isinstance(mod.inline_handlers, dict)
-                    or not mod.inline_handlers
-                ):
-                    continue
-
-                _ihandlers = dict(mod.inline_handlers.items())
-                for name, fun in _ihandlers.items():
-                    # If user doesn't have enough permissions
-                    # to run this inline command, do not show it
-                    # in help
-                    if not self.check_inline_security(fun, inline_query.from_user.id):
-                        continue
-
-                    # Retrieve docs from func
-                    doc = utils.escape_html(
-                        "\n".join(
-                            [
-                                line.strip()
-                                for line in inspect.getdoc(fun).splitlines()
-                                if not line.strip().startswith("@")
-                            ]
-                        )
-                    )
-
-                    _help += f"üéπ <code>@{self.bot_username} {name}</code> - {doc}\n"
-
-            await inline_query.answer(
-                [
-                    InlineQueryResultArticle(
-                        id=rand(20),
-                        title="Show available inline commands",
-                        description=f"You have {len(_help.splitlines())} available command(-s)",
-                        input_message_content=InputTextMessageContent(
-                            f"<b>‚ÑπÔ∏è Available inline commands:</b>\n\n{_help}",
-                            "HTML",
-                            disable_web_page_preview=True,
-                        ),
-                        thumb_url="https://img.icons8.com/fluency/50/000000/info-squared.png",
-                        thumb_width=128,
-                        thumb_height=128,
-                    )
-                ],
-                cache_time=0,
-            )
-
-            return
-
-        # First, dispatch all registered inline handlers
-        for mod in self._allmodules.modules:
-            if (
-                not hasattr(mod, "inline_handlers")
-                or not isinstance(mod.inline_handlers, dict)
-                or not mod.inline_handlers
-            ):
-                continue
-
-            instance = GeekInlineQuery(inline_query)
-
-            for query_text, query_func in mod.inline_handlers.items():
-                if inline_query.query.split()[
-                    0
-                ].lower() == query_text.lower() and self.check_inline_security(
-                    query_func, inline_query.from_user.id
-                ):
-                    try:
-                        await query_func(instance)
-                    except BaseException:
-                        logger.exception("Error on running inline watcher!")
-
-        # Process forms
-        for form in self._forms.copy().values():
-            for button in array_sum(form.get("buttons", [])):
-                if (
-                    "_switch_query" in button
-                    and "input" in button
-                    and button["_switch_query"] == query.split()[0]
-                    and inline_query.from_user.id
-                    in [self._me]
-                    + self._client.dispatcher.security._owner  # skipcq: PYL-W0212
-                    + form["always_allow"]
-                ):
-                    await inline_query.answer(
-                        [
-                            InlineQueryResultArticle(
-                                id=rand(20),
-                                title=button["input"],
-                                description="‚ö†Ô∏è Please, do not remove identifier!",
-                                input_message_content=InputTextMessageContent(
-                                    "üîÑ <b>Transferring value to userbot...</b>\n"
-                                    "<i>This message is gonna be deleted...</i>",
-                                    "HTML",
-                                    disable_web_page_preview=True,
-                                ),
-                            )
-                        ],
-                        cache_time=60,
-                    )
-                    return
-
-        # Process galleries
-        for gallery in self._galleries.copy().values():
-            if (
-                inline_query.from_user.id
-                in [self._me]
-                + self._client.dispatcher.security._owner  # skipcq: PYL-W0212
-                + gallery["always_allow"]
-                and query == gallery["uid"]
-            ):
-                markup = InlineKeyboardMarkup()
-                markup.add(
-                    InlineKeyboardButton(
-                        "Next ‚û°Ô∏è", callback_data=gallery["btn_call_data"]
-                    )
-                )
-
-                caption = gallery["caption"]
-                caption = caption() if callable(caption) else caption
-
-                await inline_query.answer(
-                    [
-                        InlineQueryResultPhoto(
-                            id=rand(20),
-                            title="Toss a coin",
-                            photo_url=gallery["photo_url"],
-                            thumb_url=gallery["photo_url"],
-                            caption=caption,
-                            description=caption,
-                            reply_markup=markup,
-                            parse_mode="HTML",
-                        )
-                    ],
-                    cache_time=0,
-                )
-                return
-
-        # If we don't know, what this query is for, just ignore it
-        if query not in self._forms:
-            return
-
-        # Otherwise, answer it with templated form
-        await inline_query.answer(
-            [
-                InlineQueryResultArticle(
-                    id=rand(20),
-                    title="GeekTG",
-                    input_message_content=InputTextMessageContent(
-                        self._forms[query]["text"],
-                        "HTML",
-                        disable_web_page_preview=True,
-                    ),
-                    reply_markup=self._generate_markup(query),
-                )
-            ],
-            cache_time=60,
-        )
-
-    async def _callback_query_handler(
-        self, query: CallbackQuery, reply_markup: List[List[dict]] = None
-    ) -> None:
-        """Callback query handler (buttons' presses)"""
-        if reply_markup is None:
-            reply_markup = []
-
-        # First, dispatch all registered callback handlers
-        for mod in self._allmodules.modules:
-            if (
-                not hasattr(mod, "callback_handlers")
-                or not isinstance(mod.callback_handlers, dict)
-                or not mod.callback_handlers
-            ):
-                continue
-
-            for query_func in mod.callback_handlers.values():
-                if self.check_inline_security(query_func, query.from_user.id):
-                    try:
-                        await query_func(query)
-                    except Exception:
-                        logger.exception("Error on running callback watcher!")
-                        await query.answer(
-                            "Error occured while processing request. More info in logs",
-                            show_alert=True,
-                        )
-                        return
-
-        for form_uid, form in self._forms.copy().items():
-            for button in array_sum(form.get("buttons", [])):
-                if button.get("_callback_data", None) == query.data:
-                    if (
-                        form["force_me"]
-                        and query.from_user.id != self._me
-                        and query.from_user.id
-                        not in self._client.dispatcher.security._owner  # skipcq: PYL-W0212
-                        and query.from_user.id not in form["always_allow"]
-                    ):
-                        await query.answer("You are not allowed to press this button!")
-                        return
-
-                    query.delete = functools.partial(
-                        delete, self=self, form=form, form_uid=form_uid
-                    )
-                    query.unload = functools.partial(
-                        unload, self=self, form_uid=form_uid
-                    )
-                    query.edit = functools.partial(
-                        edit, self=self, query=query, form=form, form_uid=form_uid
-                    )
-
-                    query.form = {"id": form_uid, **form}
-
-                    try:
-                        return await button["callback"](
-                            query,
-                            *button.get("args", []),
-                            **button.get("kwargs", {}),
-                        )
-                    except Exception:
-                        logger.exception("Error on running callback watcher!")
-                        await query.answer(
-                            "Error occurred while "
-                            "processing request. "
-                            "More info in logs",
-                            show_alert=True,
-                        )
-                        return
-
-                    del self._forms[form_uid]
-
-        if query.data in self._custom_map:
-            if (
-                self._custom_map[query.data]["force_me"]
-                and query.from_user.id != self._me
-                and query.from_user.id not in self._client.dispatcher.security._owner  # skipcq: PYL-W0212
-                and query.from_user.id
-                not in self._custom_map[query.data]["always_allow"]
-            ):
-                await query.answer("You are not allowed to press this button!")
-                return
-
-            await self._custom_map[query.data]["handler"](query)
-            return
-
-    async def _chosen_inline_handler(
-        self, chosen_inline_query: ChosenInlineResult
-    ) -> None:
-        query = chosen_inline_query.query
-
-        for form_uid, form in self._forms.copy().items():
-            for button in array_sum(form.get("buttons", [])):
-                if (
-                    "_switch_query" in button
-                    and "input" in button
-                    and button["_switch_query"] == query.split()[0]
-                    and chosen_inline_query.from_user.id
-                    in [self._me]
-                    + self._client.dispatcher.security._owner  # skipcq: PYL-W0212
-                    + form["always_allow"]
-                ):
-
-                    query = query.split(maxsplit=1)[1] if len(query.split()) > 1 else ""
-
-                    call = InlineCall()
-
-                    call.delete = functools.partial(
-                        delete, self=self, form=form, form_uid=form_uid
-                    )
-                    call.unload = functools.partial(
-                        unload, self=self, form_uid=form_uid
-                    )
-                    call.edit = functools.partial(
-                        edit,
-                        self=self,
-                        query=chosen_inline_query,
-                        form=form,
-                        form_uid=form_uid,
-                    )
-
-                    try:
-                        return await button["handler"](
-                            call,
-                            query,
-                            *button.get("args", []),
-                            **button.get("kwargs", {}),
-                        )
-                    except Exception:
-                        logger.exception(
-                            "Exception while running chosen query watcher!"
-                        )
-                        return
-
-    async def form(
-        self,
-        text: str,
-        message: Union[Message, int],
-        reply_markup: List[List[dict]] = None,
-        force_me: bool = True,
-        always_allow: List[int] = None,
-        ttl: Union[int, bool] = False,
-    ) -> Union[str, bool]:
-        """Creates inline form with callback
-        Args:
-                text
-                        Content of inline form. HTML markup support
-                message
-                        Where to send inline. Can be either `Message` or `int`
-                reply_markup
-                        List of buttons to insert in markup. List of dicts with
-                        keys: text, callback
-                force_me
-                        Either this form buttons must be pressed only by owner scope or no
-                always_allow
-                        Users, that are allowed to press buttons in addition to previous rules
-                ttl
-                        Time, when the form is going to be unloaded. Unload means, that the form
-                        buttons with inline queries and callback queries will become unusable, but
-                        buttons with type url will still work as usual. Pay attention, that ttl can't
-                        be bigger, than default one (1 day) and must be either `int` or `False`
-        """
-
-        if reply_markup is None:
-            reply_markup = []
-
-        if always_allow is None:
-            always_allow = []
-
-        if not isinstance(text, str):
-            logger.error("Invalid type for `text`")
-            return False
-
-        if not isinstance(message, (Message, int)):
-            logger.error("Invalid type for `message`")
-            return False
-
-        if not isinstance(reply_markup, list):
-            logger.error("Invalid type for `reply_markup`")
-            return False
-
-        if not all(
-            all(isinstance(button, dict) for button in row) for row in reply_markup
-        ):
-            logger.error("Invalid type for one of the buttons. It must be `dict`")
-            return False
-
-        if not all(
-            all(
-                "url" in button
-                or "callback" in button
-                or "input" in button
-                or "data" in button
-                for button in row
-            )
-            for row in reply_markup
-        ):
-            logger.error(
-                "Invalid button specified. "
-                "Button must contain one of the following fields:\n"
-                "  - `url`\n"
-                "  - `callback`\n"
-                "  - `input`\n"
-                "  - `data`"
-            )
-            return False
-
-        if not isinstance(force_me, bool):
-            logger.error("Invalid type for `force_me`")
-            return False
-
-        if not isinstance(always_allow, list):
-            logger.error("Invalid type for `always_allow`")
-            return False
-
-        if not isinstance(ttl, int) and ttl:
-            logger.error("Invalid type for `ttl`")
-            return False
-
-        if isinstance(ttl, int) and (ttl > self._markup_ttl or ttl < 10):
-            ttl = self._markup_ttl
-            logger.debug("Defaulted ttl, because it breaks out of limits")
-
-        form_uid = rand(30)
-
-        self._forms[form_uid] = {
-            "text": text,
-            "buttons": reply_markup,
-            "ttl": round(time.time()) + ttl or self._markup_ttl,
-            "force_me": force_me,
-            "always_allow": always_allow,
-            "chat": None,
-            "message_id": None,
-            "uid": form_uid,
-        }
-
-        try:
-            q = await self._client.inline_query(self.bot_username, form_uid)
-            m = await q[0].click(
-                utils.get_chat_id(message) if isinstance(message, Message) else message,
-                reply_to=message.reply_to_msg_id
-                if isinstance(message, Message)
-                else None,
-            )
-        except Exception:
-            msg = (
-                "üö´ <b>A problem occurred with inline bot "
-                "while processing query. Check logs for "
-                "further info.</b>"
-            )
-
-            del self._forms[form_uid]
-            if isinstance(message, Message):
-                await (message.edit if message.out else message.respond)(msg)
-            else:
-                await self._client.send_message(message, msg)
-
-            return False
-
-        self._forms[form_uid]["chat"] = utils.get_chat_id(m)
-        self._forms[form_uid]["message_id"] = m.id
-        if isinstance(message, Message):
-            await message.delete()
-
-        return form_uid
-
-    async def gallery(
-        self,
-        caption: Union[str, FunctionType],
-        message: Union[Message, int],
-        next_handler: FunctionType,
-        force_me: bool = False,
-        always_allow: bool = False,
-        ttl: int = False,
-    ) -> Union[bool, str]:  # sourcery skip: raise-specific-error
-        """
-        Processes inline gallery
-            caption
-                    Caption for photo, or callable, returning caption
-            message
-                    Where to send inline. Can be either `Message` or `int`
-            next_handler
-                    Callback function, which must return url for next photo
-            force_me
-                    Either this form buttons must be pressed only by owner scope or no
-            always_allow
-                    Users, that are allowed to press buttons in addition to previous rules
-            ttl
-                    Time, when the form is going to be unloaded. Unload means, that the form
-                    buttons with inline queries and callback queries will become unusable, but
-                    buttons with type url will still work as usual. Pay attention, that ttl can't
-                    be bigger, than default one (1 day) and must be either `int` or `False`
-        """
-
-        if not isinstance(caption, str) and not callable(caption):
-            logger.error("Invalid type for `caption`")
-            return False
-
-        if not isinstance(message, (Message, int)):
-            logger.error("Invalid type for `message`")
-            return False
-
-        if not isinstance(force_me, bool):
-            logger.error("Invalid type for `force_me`")
-            return False
-
-        if always_allow and not isinstance(always_allow, list):
-            logger.error("Invalid type for `always_allow`")
-            return False
-
-        if not always_allow:
-            always_allow = []
-
-        if not isinstance(ttl, int) and ttl:
-            logger.error("Invalid type for `ttl`")
-            return False
-
-        if isinstance(ttl, int) and (ttl > self._markup_ttl or ttl < 10):
-            ttl = self._markup_ttl
-            logger.debug("Defaulted ttl, because it breaks out of limits")
-
-        gallery_uid = rand(30)
-        btn_call_data = rand(16)
-
-        try:
-            photo_url = await next_handler()
-            if not isinstance(photo_url, str):
-                raise Exception(
-                    f"Got invalid result from `next_handler`. Expected `str`, got `{type(photo_url)}`"
-                )
-        except Exception:
-            logger.exception("Error while parsing first photo in gallery")
-            return False
-
-        self._galleries[gallery_uid] = {
-            "caption": caption,
-            "ttl": round(time.time()) + ttl or self._markup_ttl,
-            "force_me": force_me,
-            "always_allow": always_allow,
-            "chat": None,
-            "message_id": None,
-            "uid": gallery_uid,
-            "photo_url": photo_url,
-            "next_handler": next_handler,
-            "btn_call_data": btn_call_data,
-        }
-
-        self._custom_map[btn_call_data] = {
-            "handler": asyncio.coroutine(
-                functools.partial(
-                    custom_next_handler,
-                    func=next_handler,
-                    self=self,
-                    btn_call_data=btn_call_data,
-                    caption=caption,
-                )
-            ),
-            "always_allow": always_allow,
-            "force_me": force_me,
-        }
-
-        try:
-            q = await self._client.inline_query(self.bot_username, gallery_uid)
-            m = await q[0].click(
-                utils.get_chat_id(message) if isinstance(message, Message) else message,
-                reply_to=message.reply_to_msg_id
-                if isinstance(message, Message)
-                else None,
-            )
-        except Exception:
-            msg = (
-                "üö´ <b>A problem occurred with inline bot "
-                "while processing query. Check logs for "
-                "further info.</b>"
-            )
-
-            del self._galleries[gallery_uid]
-            if isinstance(message, Message):
-                await (message.edit if message.out else message.respond)(msg)
-            else:
-                await self._client.send_message(message, msg)
-
-            return False
-
-        self._galleries[gallery_uid]["chat"] = utils.get_chat_id(m)
-        self._galleries[gallery_uid]["message_id"] = m.id
-        if isinstance(message, Message):
-            await message.delete()
-
-        return gallery_uid
-
-
-if __name__ == "__main__":
-    raise Exception("This file must be called as a module")
diff --git a/friendly-telegram/main.py b/friendly-telegram/main.py
deleted file mode 100644
index a7160a1..0000000
--- a/friendly-telegram/main.py
+++ /dev/null
@@ -1,790 +0,0 @@
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-#    Modded by GeekTG Team
-
-import argparse
-import asyncio
-import atexit
-import collections
-import functools
-import importlib
-import json
-import logging
-import os
-import platform
-import random
-import signal
-import socket
-import sqlite3
-import sys
-import time
-
-import requests
-from requests import get
-from telethon import TelegramClient, events
-from telethon.errors.rpcerrorlist import (
-    PhoneNumberInvalidError,
-    MessageNotModifiedError,
-    ApiIdInvalidError,
-    AuthKeyDuplicatedError,
-)
-from telethon.network.connection import ConnectionTcpFull
-from telethon.network.connection import ConnectionTcpMTProxyRandomizedIntermediate
-from telethon.sessions import StringSession, SQLiteSession
-from telethon.tl.functions.channels import DeleteChannelRequest
-
-from . import utils, loader, heroku
-from .database import backend, frontend
-from .dispatcher import CommandDispatcher
-from .translations.core import Translator
-
-__version__ = (3, 1, 24)
-try:
-    from .web import core
-except ImportError:
-    web_available = False
-    logging.exception("Unable to import web")
-else:
-    web_available = True
-
-
-def run_config(db, data_root, phone=None, modules=None):
-    """Load configurator.py"""
-    from . import configurator
-
-    return configurator.run(db, data_root, phone, phone is None, modules)
-
-
-def get_config_key(key):
-    """Parse and return key from config"""
-    try:
-        with open("config.json", "r") as f:
-            config = json.loads(f.read())
-
-        return config.get(key, False)
-    except FileNotFoundError:
-        return False
-
-
-def save_config_key(key, value):
-    try:
-        # Try to open our newly created json config
-        with open("config.json", "r") as f:
-            config = json.loads(f.read())
-    except FileNotFoundError:
-        # If it doesn't exist, just default config to none
-        # It won't cause problems, bc after new save
-        # we will create new one
-        config = {}
-
-    # Assign config value
-    config[key] = value
-
-    # And save config
-    with open("config.json", "w") as f:
-        f.write(json.dumps(config))
-
-    return True
-
-
-save_config_key("use_fs_for_modules", get_config_key("use_fs_for_modules"))
-
-
-def gen_port():
-    # In case of heroku you always need to use 8080
-    if "DYNO" in os.environ:
-        return 8080
-
-    # But for own server we generate new free port, and assign to it
-
-    port = get_config_key("port")
-    if port:
-        return port
-
-    # If we didn't get port from config, generate new one
-    # First, try to randomly get port
-    port = random.randint(1024, 65536)
-
-    # Then ensure it's free
-    while (
-        socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect_ex(
-            ("localhost", port)
-        )
-        == 0
-    ):
-        # Until we find the free port, generate new one
-        port = random.randint(1024, 65536)
-
-    return port
-
-
-def save_db_type(use_file_db):
-    return save_config_key("use_file_db", use_file_db)
-
-
-def parse_arguments():
-    """Parse the arguments"""
-    parser = argparse.ArgumentParser()
-    parser.add_argument("--setup", "-s", action="store_true")
-    parser.add_argument(
-        "--port", dest="port", action="store", default=gen_port(), type=int
-    )
-    parser.add_argument("--phone", "-p", action="append")
-    parser.add_argument("--token", "-t", action="append", dest="tokens")
-    parser.add_argument("--heroku", action="store_true")
-    parser.add_argument("--no-nickname", "-nn", dest="no_nickname", action="store_true")
-    parser.add_argument("--no-inline", dest="use_inline", action="store_false")
-    parser.add_argument("--hosting", "-lh", dest="hosting", action="store_true")
-    parser.add_argument("--default-app", "-da", dest="default_app", action="store_true")
-    parser.add_argument("--web-only", dest="web_only", action="store_true")
-    parser.add_argument("--no-web", dest="web", action="store_false")
-    parser.add_argument(
-        "--data-root",
-        dest="data_root",
-        default="",
-        help="Root path to store session files in",
-    )
-    parser.add_argument(
-        "--no-auth",
-        dest="no_auth",
-        action="store_true",
-        help="Disable authentication and API token input, exitting if needed",
-    )
-    parser.add_argument(
-        "--proxy-host",
-        dest="proxy_host",
-        action="store",
-        help="MTProto proxy host, without port",
-    )
-    parser.add_argument(
-        "--proxy-port",
-        dest="proxy_port",
-        action="store",
-        type=int,
-        help="MTProto proxy port",
-    )
-    parser.add_argument(
-        "--proxy-secret",
-        dest="proxy_secret",
-        action="store",
-        help="MTProto proxy secret",
-    )
-    parser.add_argument(
-        "--heroku-web-internal",
-        dest="heroku_web_internal",
-        action="store_true",
-        help="This is for internal use only. If you use it, things will go wrong.",
-    )
-    parser.add_argument(
-        "--heroku-deps-internal",
-        dest="heroku_deps_internal",
-        action="store_true",
-        help="This is for internal use only. If you use it, things will go wrong.",
-    )
-    parser.add_argument(
-        "--docker-deps-internal",
-        dest="docker_deps_internal",
-        action="store_true",
-        help="This is for internal use only. If you use it, things will go wrong.",
-    )
-    parser.add_argument(
-        "--heroku-restart-internal",
-        dest="heroku_restart_internal",
-        action="store_true",
-        help="This is for internal use only. If you use it, things will go wrong.",
-    )
-    parser.add_argument(
-        "--root",
-        dest="disable_root_check",
-        action="store_true",
-        help="Disable `force_insecure` warning",
-    )
-    arguments = parser.parse_args()
-    logging.debug(arguments)
-    if sys.platform == "win32":
-        # Subprocess support; not needed in 3.8 but not harmful
-        asyncio.set_event_loop(asyncio.ProactorEventLoop())
-
-    return arguments
-
-
-def get_phones(arguments):
-    """Get phones from the --token, --phone, and environment"""
-    phones = {
-        phone.split(":", maxsplit=1)[0]: phone
-        for phone in map(
-            lambda f: f[18:-8],
-            filter(
-                lambda f: f.startswith("friendly-telegram-") and f.endswith(".session"),
-                os.listdir(
-                    arguments.data_root or os.path.dirname(utils.get_base_dir())
-                ),
-            ),
-        )
-    }
-
-    phones.update(
-        **(
-            {phone.split(":", maxsplit=1)[0]: phone for phone in arguments.phone}
-            if arguments.phone
-            else {}
-        )
-    )
-
-    authtoken = os.environ.get("authorization_strings", False)  # for heroku
-    if authtoken and not arguments.setup:
-        try:
-            authtoken = json.loads(authtoken)
-        except json.decoder.JSONDecodeError:
-            logging.warning("authtoken invalid")
-            authtoken = False
-
-    if arguments.setup or (arguments.tokens and not authtoken):
-        authtoken = {}
-    if arguments.tokens:
-        for token in arguments.tokens:
-            phone = sorted(filter(lambda phone: ":" not in phone, phones.values()))[0]
-            del phones[phone]
-            authtoken[phone] = token
-
-    return phones, authtoken
-
-
-def get_api_token(arguments, use_default_app=False):
-    """Get API Token from disk or environment"""
-    api_token_type = collections.namedtuple("api_token", ("ID", "HASH"))
-
-    # Allow user to use default API credintials
-    # These are android ones
-    if use_default_app:
-        return api_token_type(2040, "b18441a1ff607e10a989891a5462e627")
-
-    # Try to retrieve credintials from file, or from env vars
-    try:
-        with open(
-            os.path.join(
-                arguments.data_root or os.path.dirname(utils.get_base_dir()),
-                "api_token.txt",
-            )
-        ) as f:
-            api_token = api_token_type(*[line.strip() for line in f.readlines()])
-    except FileNotFoundError:
-        try:
-            from . import api_token
-        except ImportError:
-            try:
-                api_token = api_token_type(os.environ["api_id"], os.environ["api_hash"])
-            except KeyError:
-                api_token = None
-
-    return api_token
-
-
-def get_proxy(arguments):
-    """Get proxy tuple from --proxy-host, --proxy-port and --proxy-secret
-    and connection to use (depends on proxy - provided or not)"""
-    if (
-        arguments.proxy_host is not None
-        and arguments.proxy_port is not None
-        and arguments.proxy_secret is not None
-    ):
-        logging.debug("Using proxy: %s:%s", arguments.proxy_host, arguments.proxy_port)
-        return (
-            (arguments.proxy_host, arguments.proxy_port, arguments.proxy_secret),
-            ConnectionTcpMTProxyRandomizedIntermediate,
-        )
-
-    return None, ConnectionTcpFull
-
-
-def sigterm(app, signum, handler):  # skipcq: PYL-W0613
-    if app is not None:
-        dyno = os.environ["DYNO"]
-        if dyno.startswith("web") and app.process_formation()["web"].quantity:
-            # If we are just idling, start the worker, but otherwise shutdown gracefully
-            app.scale_formation_process("worker-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK", 1)
-        elif (
-            dyno.startswith("restarter")
-            and app.process_formation()[
-                "restarter-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK"
-            ].quantity
-        ):
-            # If this dyno is restarting, it means we should start the web dyno
-            app.batch_scale_formation_processes(
-                {
-                    "web": 1,
-                    "worker-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK": 0,
-                    "restarter-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK": 0,
-                }
-            )
-    # This ensures that we call atexit hooks and close FDs when Heroku kills us un-gracefully
-    sys.exit(143)  # SIGTERM + 128
-
-
-class SuperList(list):
-    """
-    Makes able: await self.allclients.send_message("foo", "bar")
-    """
-
-    def __getattribute__(self, attr):
-        if hasattr(list, attr):
-            return list.__getattribute__(self, attr)
-
-        for obj in self:  # TODO: find other way
-            _ = getattr(obj, attr)
-            if callable(_):
-                if asyncio.iscoroutinefunction(_):
-
-                    async def foobar(*args, **kwargs):
-                        return [await getattr(__, attr)(*args, **kwargs) for __ in self]
-
-                    return foobar
-                return lambda *args, **kwargs: [
-                    getattr(__, attr)(*args, **kwargs) for __ in self
-                ]
-
-            return [getattr(x, attr) for x in self]
-
-
-def main():  # noqa: C901
-    """Main entrypoint"""
-    arguments = parse_arguments()
-    loop = asyncio.get_event_loop()
-
-    clients = SuperList()
-    phones, authtoken = get_phones(arguments)
-    api_token = get_api_token(arguments, arguments.default_app)
-    proxy, conn = get_proxy(arguments)
-
-    if web_available:
-        web = (
-            core.Web(
-                data_root=arguments.data_root,
-                api_token=api_token,
-                proxy=proxy,
-                connection=conn,
-                hosting=arguments.hosting,
-                default_app=arguments.default_app,
-            )
-            if arguments.web
-            else None
-        )
-    elif arguments.heroku_web_internal:
-        raise RuntimeError("Web required but unavailable")
-    else:
-        web = None
-
-    save_config_key("port", arguments.port)
-
-    while api_token is None:
-        if arguments.no_auth:
-            return
-        if web:
-            loop.run_until_complete(web.start(arguments.port))
-            print("Web mode ready for configuration")  # noqa: T001
-            if not arguments.heroku_web_internal:
-                port = str(web.port)
-                if platform.system() == "Linux" and not os.path.exists(
-                    "/etc/os-release"
-                ):
-                    print(f"Please visit http://localhost:{port}")
-                else:
-                    ipaddress = get("https://api.ipify.org").text
-                    print(
-                        f"Please visit http://{ipaddress}:{port} or http://localhost:{port}"
-                    )
-            loop.run_until_complete(web.wait_for_api_token_setup())
-            api_token = web.api_token
-        else:
-            run_config({}, arguments.data_root)
-            importlib.invalidate_caches()
-            api_token = get_api_token(arguments)
-
-    if os.environ.get("authorization_strings", False):
-        if (
-            os.environ.get("DYNO", False)
-            or arguments.heroku_web_internal
-            or arguments.heroku_deps_internal
-        ):
-            app, _ = heroku.get_app(
-                os.environ["authorization_strings"],
-                os.environ["heroku_api_token"],
-                api_token,
-                False,
-                True,
-            )
-        if arguments.heroku_web_internal:
-            app.scale_formation_process("worker-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK", 0)
-            signal.signal(signal.SIGTERM, functools.partial(sigterm, app))
-        elif arguments.heroku_deps_internal:
-            try:
-                app.scale_formation_process("web", 0)
-                app.scale_formation_process(
-                    "worker-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK", 0
-                )
-            except requests.exceptions.HTTPError as e:
-                if e.response.status_code != 404:
-                    # The dynos don't exist on the very first deployment, so don't try to scale
-                    raise
-            else:
-                atexit.register(
-                    functools.partial(
-                        app.scale_formation_process,
-                        "restarter-DO-NOT-TURN-ON-OR-THINGS-WILL-BREAK",
-                        1,
-                    )
-                )
-        elif arguments.heroku_restart_internal:
-            signal.signal(signal.SIGTERM, functools.partial(sigterm, app))
-            while True:
-                time.sleep(60)
-        elif os.environ.get("DYNO", False):
-            signal.signal(signal.SIGTERM, functools.partial(sigterm, app))
-
-    if authtoken:
-        for phone, token in authtoken.items():
-            try:
-                clients += [
-                    TelegramClient(
-                        StringSession(token),
-                        api_token.ID,
-                        api_token.HASH,
-                        connection=conn,
-                        proxy=proxy,
-                        connection_retries=None,
-                    ).start()
-                ]
-            except ValueError:
-                run_config({}, arguments.data_root)
-                return
-
-            clients[-1].phone = phone  # for consistency
-
-    if not clients and not phones:
-        if arguments.no_auth:
-            return
-
-        if web:
-            if not web.running.is_set():
-                loop.run_until_complete(web.start(arguments.port))
-                print("Web mode ready for configuration")  # noqa: T001
-                if not arguments.heroku_web_internal:
-                    port = str(web.port)
-                    if platform.system() == "Linux" and not os.path.exists(
-                        "/etc/os-release"
-                    ):
-                        print(f"Please visit http://localhost:{port}")
-                    else:
-                        ipaddress = get("https://api.ipify.org").text
-                        print(
-                            f"Please visit http://{ipaddress}:{port} or http://localhost:{port}"
-                        )
-            loop.run_until_complete(web.wait_for_clients_setup())
-            arguments.heroku = web.heroku_api_token
-            clients = web.clients
-            for client in clients:
-                if arguments.heroku:
-                    session = StringSession()
-                else:
-                    session = SQLiteSession(
-                        os.path.join(
-                            arguments.data_root
-                            or os.path.dirname(utils.get_base_dir()),
-                            f"friendly-telegram-+{'X' * (len(client.phone) - 5)}{client.phone[-4:]}",
-                        )
-                    )
-
-                session.set_dc(
-                    client.session.dc_id,
-                    client.session.server_address,
-                    client.session.port,
-                )
-                session.auth_key = client.session.auth_key
-                if not arguments.heroku:
-                    session.save()
-                client.session = session
-        else:
-            try:
-                phone = input("Please enter your phone: ")
-                phones = {phone.split(":", maxsplit=1)[0]: phone}
-            except EOFError:
-                print("=" * 30)
-                print(
-                    "Hello. If you are seeing this, it means YOU ARE DOING SOMETHING WRONG!\n"
-                    "It is likely that you tried to deploy to heroku -\n"
-                    "you cannot do this via the web interface.\n"
-                    "\n"
-                    "To deploy to heroku, go to\n"
-                    "https://friendly-telegram.gitlab.io/heroku to learn more\n"
-                    "\n"
-                    "In addition, you seem to have forked the friendly-telegram repo. THIS IS WRONG!\n"
-                    "You should remove the forked repo, and read https://friendly-telegram.gitlab.io\n"
-                    "\n"
-                    "If you're not using Heroku, then you are using a non-interactive prompt but\n"
-                    "you have not got a session configured, meaning authentication to Telegram is\n"
-                    "impossible.\n"
-                    "\n"
-                    "THIS ERROR IS YOUR FAULT. DO NOT REPORT IT AS A BUG!\n"
-                    "Goodbye.\n"
-                )
-
-                sys.exit(1)
-
-    for phone_id, phone in phones.items():
-        if arguments.heroku:
-            session = StringSession()
-        else:
-            session = os.path.join(
-                arguments.data_root or os.path.dirname(utils.get_base_dir()),
-                f"friendly-telegram{(('-' + phone_id) if phone_id else '')}",
-            )
-
-        try:
-            client = TelegramClient(
-                session,
-                api_token.ID,
-                api_token.HASH,
-                connection=conn,
-                proxy=proxy,
-                connection_retries=None,
-            )
-
-            client.start()
-            client.phone = phone
-
-            clients.append(client)
-        except sqlite3.OperationalError as ex:
-            print(
-                f"Error initialising phone {(phone or 'unknown')} {','.join(ex.args)}\n"  # noqa
-                ": this is probably your fault. Try checking that this is the only instance running and"
-                "that the session is not copied. If that doesn't help, delete the file named"
-                f"'friendly-telegram-{phone if phone else ''}.session'"
-            )
-            continue
-        except (TypeError, AuthKeyDuplicatedError):
-            os.remove(f"{session}.session")
-            main()
-        except (ValueError, ApiIdInvalidError):
-            # Bad API hash/ID
-            run_config({}, arguments.data_root)
-            return
-        except PhoneNumberInvalidError:
-            print(
-                "Please check the phone number. Use international format (+XX...)"  # noqa: T001
-                " and don't put spaces in it."
-            )
-            continue
-
-    if arguments.heroku:
-        if isinstance(arguments.heroku, str):
-            key = arguments.heroku
-        else:
-            key = input(
-                "Please enter your Heroku API key (from https://dashboard.heroku.com/account): "
-            ).strip()
-
-        app = heroku.publish(clients, key, api_token)
-        print(
-            "Installed to heroku successfully! Type .help in Telegram for help."
-        )  # noqa: T001
-        if web:
-            web.redirect_url = app.web_url
-            web.ready.set()
-            loop.run_until_complete(web.root_redirected.wait())
-        return
-
-    loop.set_exception_handler(
-        lambda _, x: logging.error(
-            "Exception on event loop! %s",
-            x["message"],
-            exc_info=x.get("exception", None),
-        )
-    )
-
-    loops = [amain_wrapper(client, clients, web, arguments) for client in clients]
-    loop.run_until_complete(asyncio.gather(*loops))
-
-
-async def amain_wrapper(client, *args, **kwargs):
-    """Wrapper around amain so we don't have to manually clear all locals on soft restart"""
-    async with client:
-        first = True
-        while await amain(first, client, *args, **kwargs):
-            first = False
-
-
-async def amain(first, client, allclients, web, arguments):
-    """Entrypoint for async init, run once for each user"""
-    setup = arguments.setup
-    web_only = arguments.web_only
-    client.parse_mode = "HTML"
-    await client.start()
-
-    handlers = logging.getLogger().handlers
-    db = backend.CloudBackend(client)
-
-    if setup:
-        await db.init(lambda e: None)
-        jdb = await db.do_download()
-
-        try:
-            pdb = json.loads(jdb)
-        except (json.decoder.JSONDecodeError, TypeError):
-            pdb = {}
-
-        modules = loader.Modules(arguments.use_inline)
-        babelfish = Translator([], [], arguments.data_root)
-        await babelfish.init(client)
-        modules.register_all(babelfish)
-        fdb = frontend.Database(db, True)
-        await fdb.init()
-        modules.send_config(fdb, babelfish)
-        await modules.send_ready(
-            client, fdb, allclients
-        )  # Allow normal init even in setup
-
-        for handler in handlers:
-            handler.setLevel(50)
-
-        pdb = run_config(
-            pdb,
-            arguments.data_root,
-            getattr(client, "phone", "Unknown Number"),
-            modules,
-        )
-
-        if pdb is None:
-            await client(DeleteChannelRequest(db.db))
-            return
-
-        try:
-            await db.do_upload(json.dumps(pdb))
-        except MessageNotModifiedError:
-            pass
-
-        return False
-
-    db = frontend.Database(
-        db, arguments.heroku_deps_internal or arguments.docker_deps_internal
-    )
-    await db.init()
-
-    logging.debug("got db")
-    logging.info("Loading logging config...")
-    for handler in handlers:
-        handler.setLevel(db.get(__name__, "loglevel", logging.WARNING))
-
-    to_load = None
-    if arguments.heroku_deps_internal or arguments.docker_deps_internal:
-        to_load = ["loader.py"]
-
-    babelfish = Translator(
-        db.get(__name__, "langpacks", []),
-        db.get(__name__, "language", ["en"]),
-        arguments.data_root,
-    )
-
-    await babelfish.init(client)
-
-    modules = loader.Modules()
-    no_nickname = arguments.no_nickname
-
-    if not (arguments.heroku_deps_internal or arguments.docker_deps_internal):
-        if web:
-            await web.add_loader(client, modules, db)
-            await web.start_if_ready(len(allclients), arguments.port)
-        if not web_only:
-            dispatcher = CommandDispatcher(modules, db, no_nickname)
-            client.dispatcher = dispatcher
-    if arguments.heroku_deps_internal or arguments.docker_deps_internal:
-        # Loader has installed all dependencies
-        return  # We are done
-
-    if not web_only:
-        await dispatcher.init(client)
-        modules.check_security = dispatcher.check_security
-
-        client.add_event_handler(dispatcher.handle_incoming, events.NewMessage)
-
-        client.add_event_handler(dispatcher.handle_incoming, events.ChatAction)
-
-        client.add_event_handler(
-            dispatcher.handle_command, events.NewMessage(forwards=False)
-        )
-
-        client.add_event_handler(dispatcher.handle_command, events.MessageEdited())
-
-    modules.register_all(babelfish, to_load)
-
-    modules.send_config(db, babelfish)
-
-    await modules.send_ready(client, db, allclients)
-
-    if first:
-        try:
-            import git
-
-            repo = git.Repo()
-
-            build = repo.heads[0].commit.hexsha
-            diff = repo.git.log(["HEAD..origin/master", "--oneline"])
-            upd = r"\33[31mUpdate required" if diff else r"Up-to-date"
-
-            termux = bool(
-                os.popen('echo $PREFIX | grep -o "com.termux"').read()
-            )  # skipcq: BAN-B605, BAN-B607
-            is_heroku = os.environ.get("DYNO", False)
-
-            _platform = r"Termux" if termux else (r"Heroku" if is_heroku else "VDS")
-
-            logo1 = f"""
-                                      )
-                   (               ( /(
-                   ) )   (   (    )())
-                  (()/(   )  ) |((_)
-                   /((_)_((_)((_)|_((_)
-                  (_)/ __| __| __| |/ /
-                    | (_ | _|| _|  ' <
-                      ___|___|___|_|_\\
-
-                     ‚Ä¢ Build: {build[:7]}
-                     ‚Ä¢ Version: {'.'.join(list(map(str, list(__version__))))}
-                     ‚Ä¢ {upd}
-                     ‚Ä¢ Platform: {_platform}
-                     - Started for {(await client.get_me(True)).user_id} -"""
-
-            print(logo1)
-
-            logging.info(f"=== BUILD: {build} ===")
-            logging.info(
-                f"=== VERSION: {'.'.join(list(map(str, list(__version__))))} ==="
-            )
-            logging.info(
-                f"=== PLATFORM: {'Termux' if termux else ('Heroku' if is_heroku else 'VDS')} ==="
-            )
-        except Exception:
-            logging.exception(
-                "Badge error"
-            )  # This part is not so necessary, so if error occures, ignore it
-
-    await client.run_until_disconnected()
-
-    # Previous line will stop code execution, so this part is
-    # reached only when client is by some reason disconnected
-    # At this point we need to close database
-    await db.close()
-    return False
diff --git a/friendly-telegram/modules/backuper.py b/friendly-telegram/modules/backuper.py
deleted file mode 100755
index f44a154..0000000
--- a/friendly-telegram/modules/backuper.py
+++ /dev/null
@@ -1,144 +0,0 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-# meta pic: https://img.icons8.com/fluency/48/000000/sync-settings.png
-
-from .. import loader, utils
-import asyncio
-import datetime
-import io
-import json
-
-from telethon.tl.types import Message
-
-
-@loader.tds
-class BackuperMod(loader.Module):
-    """Backup everything and anything"""
-
-    strings = {
-        "name": "Backuper",
-        "backup_caption": "‚òùÔ∏è <b>This is your database backup. Do not give it to anyone, it contains personal info.</b>",
-        "reply_to_file": "üö´ <b>Reply to .{} file</b>",
-        "db_restored": "üîÑ <b>Database updated, restarting...</b>",
-        "modules_backup": "üóÉ <b>Backup mods ({})</b>",
-        "notes_backup": "üóÉ <b>Backup notes ({})</b>",
-        "mods_restored": "‚úÖ <b>Modes restored, restarting</b>",
-        "notes_restored": "‚úÖ <b>Notes restored</b>",
-    }
-
-    async def client_ready(self, client, db):
-        self._db = db
-        self._client = client
-
-    async def backupdbcmd(self, message: Message) -> None:
-        """Create database backup [will be sent in pm]"""
-        txt = io.BytesIO(json.dumps(self._db).encode("utf-8"))
-        txt.name = f"ftg-db-backup-{getattr(datetime, 'datetime', datetime).now().strftime('%d-%m-%Y-%H-%M')}.db"
-        await self._client.send_file("me", txt, caption=self.strings("backup_caption"))
-        await message.delete()
-
-    async def restoredbcmd(self, message: Message) -> None:
-        """Restore database from file"""
-        reply = await message.get_reply_message()
-        if not reply or not reply.media:
-            await utils.answer(
-                message, self.strings("reply_to_file", message).format("db")
-            )
-            await asyncio.sleep(3)
-            await message.delete()
-            return
-
-        file = await message.client.download_file(reply.media)
-        decoded_text = json.loads(file.decode("utf-8"))
-        self._db.clear()
-        self._db.update(**decoded_text)
-        self._db.save()
-        await utils.answer(message, self.strings("db_restored", message))
-        await self.allmodules.commands["restart"](await message.respond("_"))
-
-    async def backupmodscmd(self, message: Message) -> None:
-        """Create backup of mods"""
-        data = json.dumps(
-            {
-                "loaded": self._db.get(
-                    "friendly-telegram.modules.loader", "loaded_modules", []
-                ),
-                "unloaded": [],
-            }
-        )
-        txt = io.BytesIO(data.encode("utf-8"))
-        txt.name = f"ftg-mods-{getattr(datetime, 'datetime', datetime).now().strftime('%d-%m-%Y-%H-%M')}.mods"
-        await self._client.send_file(
-            utils.get_chat_id(message),
-            txt,
-            caption=self.strings("modules_backup", message).format(
-                len(
-                    self._db.get(
-                        "friendly-telegram.modules.loader", "loaded_modules", []
-                    )
-                )
-            ),
-        )
-        await message.delete()
-
-    async def restoremodscmd(self, message: Message) -> None:
-        """<reply to file> - Restore mods from backup"""
-        reply = await message.get_reply_message()
-        if not reply or not reply.media:
-            await utils.answer(
-                message, self.strings("reply_to_file", message).format("mods")
-            )
-            await asyncio.sleep(3)
-            await message.delete()
-            return
-
-        file = await message.client.download_file(reply.media)
-        decoded_text = json.loads(file.decode("utf-8"))
-        self._db.set(
-            "friendly-telegram.modules.loader", "loaded_modules", decoded_text["loaded"]
-        )
-        self._db.set(
-            "friendly-telegram.modules.loader",
-            "unloaded_modules",
-            decoded_text["unloaded"],
-        )
-        self._db.save()
-        await utils.answer(message, self.strings("mods_restored", message))
-        await self.allmodules.commands["restart"](await message.respond("_"))
-
-    async def backupnotescmd(self, message: Message) -> None:
-        """Create the backup of notes"""
-        data = json.dumps(self._db.get("friendly-telegram.modules.notes", "notes", []))
-        txt = io.BytesIO(data.encode("utf-8"))
-        txt.name = f"ftg-notes-{getattr(datetime, 'datetime', datetime).now().strftime('%d-%m-%Y-%H-%M')}.notes"
-        await self._client.send_file(
-            utils.get_chat_id(message),
-            txt,
-            caption=self.strings("notes_backup", message).format(
-                len(self._db.get("friendly-telegram.modules.notes", "notes", []))
-            ),
-        )
-        await message.delete()
-
-    async def restorenotescmd(self, message: Message) -> None:
-        """<reply to file> - Restore notes from backup"""
-        reply = await message.get_reply_message()
-        if not reply or not reply.media:
-            await utils.answer(
-                message, self.strings("reply_to_file", message).format("notes")
-            )
-            await asyncio.sleep(3)
-            await message.delete()
-            return
-
-        file = await message.client.download_file(reply.media)
-        decoded_text = json.loads(file.decode("utf-8"))
-        self._db.set("friendly-telegram.modules.notes", "notes", decoded_text)
-        self._db.save()
-        await utils.answer(message, self.strings("notes_restored", message))
diff --git a/friendly-telegram/modules/geek_info.py b/friendly-telegram/modules/geek_info.py
deleted file mode 100755
index 6c75db7..0000000
--- a/friendly-telegram/modules/geek_info.py
+++ /dev/null
@@ -1,110 +0,0 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-# meta pic: https://img.icons8.com/external-flatart-icons-flat-flatarticons/64/000000/external-info-hotel-services-flatart-icons-flat-flatarticons.png
-# scope: inline
-
-from .. import loader, main
-import logging
-import aiogram
-import os
-import git
-
-from telethon.utils import get_display_name
-from ..inline import GeekInlineQuery, rand
-
-logger = logging.getLogger(__name__)
-
-
-@loader.tds
-class GeekInfoMod(loader.Module):
-    """Show userbot info (geek3.1.0alpha+)"""
-
-    strings = {"name": "GeekInfo"}
-
-    def get(self, *args) -> dict:
-        return self._db.get(self.strings["name"], *args)
-
-    def set(self, *args) -> None:
-        return self._db.set(self.strings["name"], *args)
-
-    async def client_ready(self, client, db) -> None:
-        self._db = db
-        self._client = client
-        self._me = await client.get_me()
-        self.markup = aiogram.types.inline_keyboard.InlineKeyboardMarkup()
-        self.markup.row(
-            aiogram.types.inline_keyboard.InlineKeyboardButton(
-                "ü§µ‚Äç‚ôÄÔ∏è Support chat", url="https://t.me/chat_ftg"
-            )
-        )
-
-    async def info_inline_handler(self, query: GeekInlineQuery) -> None:
-        """
-        Send userbot info
-        @allow: all
-        """
-
-        try:
-            repo = git.Repo()
-            ver = repo.heads[0].commit.hexsha
-
-            diff = repo.git.log(["HEAD..origin", "--oneline"])
-            upd = (
-                "‚ö†Ô∏è Update required </b><code>.update</code><b>"
-                if diff
-                else "‚úÖ Up-to-date"
-            )
-        except Exception:
-            ver = "unknown"
-            upd = ""
-
-        termux = bool(os.popen('echo $PREFIX | grep -o "com.termux"').read())  # skipcq: BAN-B605, BAN-B607
-        heroku = os.environ.get("DYNO", False)
-
-        platform = (
-            "üï∂ Termux"
-            if termux
-            else (
-                "‚õé Heroku"
-                if heroku
-                else (
-                    f"‚úåÔ∏è lavHost {os.environ['LAVHOST']}"
-                    if "LAVHOST" in os.environ
-                    else "üìª VDS"
-                )
-            )
-        )
-
-        await query.answer(
-            [
-                aiogram.types.inline_query_result.InlineQueryResultArticle(
-                    id=rand(20),
-                    title="Send userbot info",
-                    description="‚Ñπ This will not compromise any sensitive data",
-                    input_message_content=aiogram.types.input_message_content.InputTextMessageContent(
-                        f"""
-<b>üï∂ GeekTG Userbot</b>
-<b>ü§¥ Owner: <a href="tg://user?id={self._me.id}">{get_display_name(self._me)}</a></b>\n
-<b>üîÆ Version: </b><i>{".".join(list(map(str, list(main.__version__))))}</i>
-<b>üß± Build: </b><a href="https://github.com/GeekTG/Friendly-Telegram/commit/{ver}">{ver[:8] or "Unknown"}</a>
-<b>{upd}</b>
-
-<b>{platform}</b>
-""",
-                        "HTML",
-                        disable_web_page_preview=True,
-                    ),
-                    thumb_url="https://github.com/GeekTG/Friendly-Telegram/raw/master/friendly-telegram/bot_avatar.png",
-                    thumb_width=128,
-                    thumb_height=128,
-                    reply_markup=self.markup,
-                )
-            ],
-            cache_time=0,
-        )
diff --git a/friendly-telegram/translations/core.py b/friendly-telegram/translations/core.py
deleted file mode 100755
index 6c7fbab..0000000
--- a/friendly-telegram/translations/core.py
+++ /dev/null
@@ -1,127 +0,0 @@
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2021 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-#    Friendly Telegram Userbot
-#    by GeekTG Team
-
-import json
-import logging
-import os
-
-import telethon
-from babel import negotiate_locale
-from telethon.tl.types import MessageEntityHashtag
-
-from .. import utils
-
-logger = logging.getLogger(__name__)
-
-MAGIC = "#ftgtrnsl1"
-
-
-class Translator:
-    def __init__(self, packs, languages, data_root):
-        self._packs = packs
-        self._languages = languages
-        self._data_root = data_root
-
-    async def init(self, client):
-        self._data = {}
-        if await client.is_bot():
-            for pack in self._packs:
-                if not pack.isalnum():
-                    logger.warning("Pack path invalid")
-                    continue
-                try:
-                    file = open(
-                        os.path.join(
-                            self._data_root
-                            or os.path.dirname(utils.get_base_dir()),
-                            "translations",
-                            f'{pack}.json',
-                        ),
-                        "r",
-                    )
-
-                except FileNotFoundError:
-                    logger.exception("Pack not found")
-                    continue
-                with file:
-                    try:
-                        data = json.load(file)
-                    except json.decoder.JSONDecodeError:
-                        logger.exception("Unable to decode %s", pack)
-                        continue
-                    try:
-                        self._data.setdefault(data["language"], {}).update(data["data"])
-                    except KeyError:
-                        logger.exception("Translation pack follows wrong format")
-        else:
-            for pack in self._packs:
-                try:
-                    [message] = await client.get_messages(pack, 1)
-                except (ValueError, telethon.errors.rpcerrorlist.ChannelPrivateError):
-                    # We can't access the channel
-                    logger.warning(
-                        "No translation pack found for %r", pack, exc_info=True
-                    )
-                    continue
-                if not message.document or not message.entities:
-                    logger.info(
-                        "Last message in translation pack %r has no document/entities",
-                        pack,
-                    )
-                    continue
-                found = False
-                for ent in filter(
-                    lambda x: isinstance(x, MessageEntityHashtag), message.entities
-                ):
-                    if (
-                        message.message[ent.offset : ent.offset + ent.length] == MAGIC
-                        and message.file
-                    ):
-                        logger.debug("Got translation message")
-                        found = True
-                        break
-                if not found:
-                    logger.info("Didn't find translation hashtags")
-                    continue
-                try:
-                    ndata = json.loads(
-                        (await message.download_media(bytes)).decode("utf-8")
-                    )
-                except (json.decoder.JSONDecodeError, UnicodeDecodeError):
-                    logger.exception("Unable to decode %s", pack)
-                    continue
-                try:
-                    self._data.setdefault(ndata["language"], {}).update(ndata["data"])
-                except KeyError:
-                    logger.exception("Translation pack follows wrong format")
-
-    def set_preferred_languages(self, languages):
-        self._languages = languages
-
-    def getkey(self, key, lang_code=None):
-        locales = []
-        for locale, strings in self._data.items():
-            if key in strings:
-                locales += [locale]
-        target_locales = [lang_code] if lang_code else self._languages
-        locale = negotiate_locale(target_locales, locales)
-        return self._data.get(locale, {}).get(key, False)
-
-    def gettext(self, english_text):
-        return self.getkey(english_text) or english_text
diff --git a/friendly-telegram/web/root.py b/friendly-telegram/web/root.py
deleted file mode 100755
index e561c8d..0000000
--- a/friendly-telegram/web/root.py
+++ /dev/null
@@ -1,28 +0,0 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-import aiohttp_jinja2
-
-
-class Web:
-    def __init__(self, **kwargs):
-        super().__init__(**kwargs)
-        self.app.router.add_get("/", self.root)
-        self.app.router.add_get("/is_restart_complete", lambda r: True)
-        self.app.router.add_post("/restart", self.restart)
-
-    @aiohttp_jinja2.template("root.jinja2")
-    async def root(self, request):
-        return {}
-
-    async def restart(self, request):
-        cl = self.client_data[list(self.client_data.keys())[0]]
-        m = await cl[1].send_message("me", "<b>Restarting...</b>")
-        for mod in cl[0].modules:
-            if mod.__class__.__name__ == "UpdaterMod":
-                await mod.restart_common(m)
diff --git a/hikka/__init__.py b/hikka/__init__.py
new file mode 100755
index 0000000..f096e53
--- /dev/null
+++ b/hikka/__init__.py
@@ -0,0 +1,2 @@
+"""Just a placeholder to do relative imports"""
+# Do not delete this file, it will cause errors.
diff --git a/friendly-telegram/__main__.py b/hikka/__main__.py
similarity index 65%
rename from friendly-telegram/__main__.py
rename to hikka/__main__.py
index 6f7a031..801cbeb 100755
--- a/friendly-telegram/__main__.py
+++ b/hikka/__main__.py
@@ -1,5 +1,7 @@
+"""Entry point. Checks for user and starts main script"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,15 +16,25 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
-"""Initial entrypoint"""
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import sys
 import getpass
 import os
 
-if getpass.getuser() == "root" and "--root" not in " ".join(sys.argv):
+if (
+    getpass.getuser() == "root"
+    and "--root" not in " ".join(sys.argv)
+    and "OKTETO" not in os.environ
+):
     print("!" * 30)
     print("NEVER EVER RUN USERBOT FROM ROOT")
     print("THIS IS THE THREAD FOR NOT ONLY YOUR DATA, ")
@@ -36,7 +48,7 @@ if getpass.getuser() == "root" and "--root" not in " ".join(sys.argv):
 
 if sys.version_info < (3, 8, 0):
     print("Error: you must use at least Python version 3.8.0")  # pragma: no cover
-elif __package__ != "friendly-telegram":  # In case they did python __main__.py
+elif __package__ != "hikka":  # In case they did python __main__.py
     print(
         "Error: you cannot run this as a script; you must execute as a package"
     )  # pragma: no cover
@@ -46,23 +58,27 @@ else:
     log.init()
     try:
         from . import main
-    except ModuleNotFoundError:  # pragma: no cover
+    except ModuleNotFoundError as e:  # pragma: no cover
         print(
             "Error: you have not installed all dependencies correctly.\n"
+            f"{str(e)}\n"
             "Attempting dependencies installation... Just wait."
         )
 
-        os.popen("pip3 install -r requirements.txt").read()  # skipcq: BAN-B605, BAN-B607
+        os.popen(
+            "pip3 install -r requirements.txt"
+        ).read()  # skipcq: BAN-B605, BAN-B607
 
         try:
             from . import main
-        except ModuleNotFoundError:
+        except ModuleNotFoundError as e2:
             print(
                 "Error while installing dependencies. Please, do this manually!\n"
+                f"{str(e2)}\n"
                 "pip3 install -r requirements.txt"
             )
 
             sys.exit(1)
 
     if __name__ == "__main__":
-        main.main()  # Execute main function
+        main.hikka.main()  # Execute main function
diff --git a/friendly-telegram/compat/__init__.py b/hikka/compat/__init__.py
similarity index 97%
rename from friendly-telegram/compat/__init__.py
rename to hikka/compat/__init__.py
index 116246a..1e477dd 100755
--- a/friendly-telegram/compat/__init__.py
+++ b/hikka/compat/__init__.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,8 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
 import logging
 import sys
 from importlib.abc import Loader, MetaPathFinder
diff --git a/friendly-telegram/compat/dbhelper.py b/hikka/compat/dbhelper.py
similarity index 100%
rename from friendly-telegram/compat/dbhelper.py
rename to hikka/compat/dbhelper.py
diff --git a/hikka/compat/geek.py b/hikka/compat/geek.py
new file mode 100644
index 0000000..1f0bd26
--- /dev/null
+++ b/hikka/compat/geek.py
@@ -0,0 +1,46 @@
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+import re
+
+
+def compat(code: str) -> str:
+    """Reformats modules, built for GeekTG to work with Hikka"""
+    code = "\n".join(
+        [
+            re.sub(
+                r"^( *)from \.\.inline import (.+)$",
+                r"\1from ..inline.types import \2",
+                re.sub(
+                    r"^( *)from \.\.inline import rand[^,]*$",
+                    "\1from ..utils import rand",
+                    re.sub(
+                        r"^( *)from \.\.inline import rand, ?(.+)$",
+                        r"\1from ..inline.types import \2\n\1from ..utils import rand",
+                        re.sub(
+                            r"^( *)from \.\.inline import (.+), ?rand[^,]*$",
+                            r"\1from ..inline.types import \2\n\1from ..utils import rand",
+                            re.sub(
+                                r"^( *)from \.\.inline import (.+), ?rand, ?(.+)$",
+                                r"\1from ..inline.types import \2, \3\n\1from ..utils import rand",
+                                line.replace("GeekInlineQuery", "InlineQuery"),
+                                flags=re.M,
+                            ),
+                            flags=re.M,
+                        ),
+                        flags=re.M,
+                    ),
+                    flags=re.M,
+                ),
+                flags=re.M,
+            )
+            for line in code.splitlines()
+        ]
+    )
+    return code
diff --git a/friendly-telegram/compat/raphielgang.py b/hikka/compat/raphielgang.py
similarity index 99%
rename from friendly-telegram/compat/raphielgang.py
rename to hikka/compat/raphielgang.py
index 0b997ac..dc0fee8 100755
--- a/friendly-telegram/compat/raphielgang.py
+++ b/hikka/compat/raphielgang.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,8 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
 # pylint: disable=R,C,W0613 # This is bad code, just let it be. We will delete it at some point, perhaps?
 
 import asyncio
@@ -376,7 +374,7 @@ class RaphielgangEvents:
                         func.__self__.__module__ = events_instance.module
                     else:
                         func.__self__ = self
-                self.strings = {"name": f"RaphielGang{self.instance_id}"}
+                self.strings = {"name": f"RaphielGang{str(self.instance_id)}"}
                 self.unknowns = events_instance.unknowns
                 self.__module__ = events_instance.module
 
diff --git a/friendly-telegram/compat/uniborg.py b/hikka/compat/uniborg.py
similarity index 99%
rename from friendly-telegram/compat/uniborg.py
rename to hikka/compat/uniborg.py
index 60f6fb8..b426fb2 100755
--- a/friendly-telegram/compat/uniborg.py
+++ b/hikka/compat/uniborg.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,8 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
 # pylint: disable=R,C,W0613,W0212 # This is bad code, just let it be.
 
 import asyncio
diff --git a/friendly-telegram/compat/util.py b/hikka/compat/util.py
similarity index 98%
rename from friendly-telegram/compat/util.py
rename to hikka/compat/util.py
index d85f14f..bbca18d 100755
--- a/friendly-telegram/compat/util.py
+++ b/hikka/compat/util.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,8 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
 import inspect
 import logging
 
diff --git a/friendly-telegram/configurator.py b/hikka/configurator.py
similarity index 90%
rename from friendly-telegram/configurator.py
rename to hikka/configurator.py
index 72ac291..2c531d7 100755
--- a/friendly-telegram/configurator.py
+++ b/hikka/configurator.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,12 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
-# flake8: noqa: T001
-
-"""Configuration menu, providing interface for users to control internals"""
-
 import ast
 import inspect
 import locale
@@ -38,22 +32,7 @@ def _safe_input(*args, **kwargs):
     try:
         return input(*args, **kwargs)
     except (EOFError, OSError):
-        print()
-        print("=" * 30)
-        print(
-            """
-Hello. If you are seeing this, it means YOU ARE DOING SOMETHING WRONG!
-It is likely that you tried to deploy to heroku - you cannot do this via the web interface.
-To deploy to heroku, go to https://friendly-telegram.gitlab.io/heroku to learn more
-
-If you're not using heroku, then you are using a non-interactive prompt but 
-you have not got a session configured, meaning authentication to Telegram is impossible.
-
-THIS ERROR IS YOUR FAULT. DO NOT REPORT IT AS A BUG!
-
-Goodbye."""
-        )
-        sys.exit(1)
+        raise    
     except KeyboardInterrupt:
         print()
         return None
@@ -191,9 +170,8 @@ def module_config(mod):
         for key in getattr(mod, "config", {}).keys()
     ]
     code, tag = DIALOG.menu(
-        f"Module configuration for {mod.name}", choices=choices
+        "Module configuration for {}".format(mod.name), choices=choices
     )
-
     if code == DIALOG.OK:
         code, value = DIALOG.inputbox(tag)
         if code == DIALOG.OK:
diff --git a/hikka/database.py b/hikka/database.py
new file mode 100755
index 0000000..9c1dccd
--- /dev/null
+++ b/hikka/database.py
@@ -0,0 +1,147 @@
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+import asyncio
+import logging
+
+from telethon.tl.functions.channels import CreateChannelRequest
+from telethon.tl.types import Message, Channel
+import json
+import os
+from typing import Any, Union
+
+from . import main
+
+ORIGIN = "/".join(main.__file__.split("/")[:-2])
+
+logger = logging.getLogger(__name__)
+
+
+class Database(dict):
+    def __init__(self, client):
+        super().__init__()
+        self._client = client
+        self._me = None
+        self._assets = None
+        self._anti_double_asset_lock = asyncio.Lock()
+        self._assets_chat_exists = False
+
+    def __repr__(self):
+        return object.__repr__(self)
+
+    async def init(self):
+        """Asynchronous initialisation unit"""
+        self._me = await self._client.get_me()
+        self._db_path = os.path.join(ORIGIN, f"config-{self._me.id}.json")
+        self.read()
+
+    async def _find_asset_channel(self) -> Channel:
+        """Find the asset channel and returns its peer"""
+        async for dialog in self._client.iter_dialogs(None, ignore_migrated=True):
+            if dialog.name == f"hikka-{self._me.id}-assets" and dialog.is_channel:
+
+                if dialog.entity.participants_count != 1:
+                    continue
+
+                logger.debug(f"Found asset chat {dialog.id}")
+                return dialog.entity
+
+    async def _make_asset_channel(self) -> Channel:
+        """If user doesn't have an asset channel, create it"""
+        async with self._anti_double_asset_lock:
+            if self._assets_chat_exists:
+                return await self._find_data_channel()
+            self._assets_chat_exists = True
+
+            dialog = (
+                await self._client(
+                    CreateChannelRequest(
+                        f"hikka-{self._me.id}-assets",
+                        "üåÜ Your Hikka assets will be stored here",
+                        megagroup=True,
+                    )
+                )
+            ).chats[0]
+
+            await self._client.edit_folder(dialog, folder=1)
+
+            return dialog
+
+    def read(self) -> str:
+        """Read database"""
+        try:
+            with open(self._db_path, "r", encoding="utf-8") as f:
+                data = json.loads(f.read())
+                self.update(**data)
+                return data
+        except (FileNotFoundError, json.decoder.JSONDecodeError):
+            logger.exception("Database read failed! Creating new one...")
+            return {}
+
+    def save(self) -> bool:
+        """Save database"""
+        try:
+            with open(self._db_path, "w", encoding="utf-8") as f:
+                f.write(json.dumps(self))
+        except Exception:
+            logger.exception("Database save failed!")
+            return False
+
+        return True
+
+    async def store_asset(self, message: Message) -> int:
+        """
+        Save assets
+        returns asset_id as integer
+        """
+        if not self._assets:
+            self._assets = await self._find_asset_channel()
+
+        if not self._assets:
+            self._assets = await self._make_asset_channel()
+
+        return (
+            (await self._client.send_message(self._assets, message)).id
+            if isinstance(message, Message)
+            else (
+                await self._client.send_message(
+                    self._assets,
+                    file=message,
+                    force_document=True,
+                )
+            ).id
+        )
+
+    async def fetch_asset(self, asset_id: int) -> Union[None, Message]:
+        """Fetch previously saved asset by its asset_id"""
+        if not self._assets:
+            self._assets = await self._find_asset_channel()
+
+        if not self._assets:
+            return None
+
+        asset = await self._client.get_messages(self._assets, ids=[asset_id])
+
+        if not asset:
+            return None
+
+        return asset[0]
+
+    def get(self, owner: str, key: str, default: Any = None) -> Any:
+        """Get database key"""
+        try:
+            return self[owner][key]
+        except KeyError:
+            return default
+
+    def set(self, owner: str, key: str, value: Any) -> bool:
+        """Set database key"""
+        super().setdefault(owner, {})[key] = value
+        return self.save()
diff --git a/hikka/dispatcher.py b/hikka/dispatcher.py
new file mode 100755
index 0000000..1ac9f7d
--- /dev/null
+++ b/hikka/dispatcher.py
@@ -0,0 +1,425 @@
+"""Obviously, dispatches stuff"""
+
+#    Friendly Telegram (telegram userbot)
+#    Copyright (C) 2018-2022 The Authors
+
+#    This program is free software: you can redistribute it and/or modify
+#    it under the terms of the GNU Affero General Public License as published by
+#    the Free Software Foundation, either version 3 of the License, or
+#    (at your option) any later version.
+
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU Affero General Public License for more details.
+
+#    You should have received a copy of the GNU Affero General Public License
+#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+import asyncio
+import collections
+import logging
+import re
+from telethon import types
+import traceback
+from telethon.tl.types import Message
+from typing import Union, Tuple
+from types import FunctionType
+
+from . import utils, main, security
+
+# Keys for layout switch
+ru_keys = '—ë–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é.–Å"‚Ññ;%:?–ô–¶–£–ö–ï–ù–ì–®–©–ó–•–™–§–´–í–ê–ü–†–û–õ–î–ñ–≠/–Ø–ß–°–ú–ò–¢–¨–ë–Æ,'
+en_keys = "`qwertyuiop[]asdfghjkl;'zxcvbnm,./~@#$%^&QWERTYUIOP{}ASDFGHJKL:\"|ZXCVBNM<>?"
+
+
+def _decrement_ratelimit(delay, data, key, severity):
+    def inner():
+        data[key] = max(0, data[key] - severity)
+
+    asyncio.get_event_loop().call_later(delay, inner)
+
+
+class CommandDispatcher:
+    def __init__(self, modules, db, no_nickname=False):
+        self._modules = modules
+        self._db = db
+        self.security = security.SecurityManager(db)
+        self.no_nickname = no_nickname
+        self._ratelimit_storage_user = collections.defaultdict(int)
+        self._ratelimit_storage_chat = collections.defaultdict(int)
+        self._ratelimit_max_user = db.get(__name__, "ratelimit_max_user", 30)
+        self._ratelimit_max_chat = db.get(__name__, "ratelimit_max_chat", 100)
+        self.check_security = self.security.check
+
+    async def init(self, client):
+        await self.security.init(client)
+        me = await client.get_me()
+        self._me = me.id
+        self._cached_username = me.username.lower() if me.username else str(me.id)
+
+    async def _handle_ratelimit(self, message, func):
+        if await self.security.check(
+            message,
+            security.OWNER | security.SUDO | security.SUPPORT,
+        ):
+            return True
+        func = getattr(func, "__func__", func)
+        ret = True
+        chat = self._ratelimit_storage_chat[message.chat_id]
+        if message.sender_id:
+            user = self._ratelimit_storage_user[message.sender_id]
+            severity = (5 if getattr(func, "ratelimit", False) else 2) * (
+                (user + chat) // 30 + 1
+            )
+            user += severity
+            self._ratelimit_storage_user[message.sender_id] = user
+            if user > self._ratelimit_max_user:
+                ret = False
+            else:
+                self._ratelimit_storage_chat[message.chat_id] = chat
+
+            _decrement_ratelimit(
+                self._ratelimit_max_user * severity,
+                self._ratelimit_storage_user,
+                message.sender_id,
+                severity,
+            )
+        else:
+            severity = (5 if getattr(func, "ratelimit", False) else 2) * (
+                chat // 15 + 1
+            )
+
+        chat += severity
+
+        if chat > self._ratelimit_max_chat:
+            ret = False
+
+        _decrement_ratelimit(
+            self._ratelimit_max_chat * severity,
+            self._ratelimit_storage_chat,
+            message.chat_id,
+            severity,
+        )
+
+        return ret
+
+    def _handle_grep(self, message: Message) -> Message:
+        # Allow escaping grep with double stick
+        if "||grep" in message.text or "|| grep" in message.text:
+            message.raw_text = re.sub(r"\|\| ?grep", "| grep", message.raw_text)
+            message.text = re.sub(r"\|\| ?grep", "| grep", message.text)
+            message.message = re.sub(r"\|\| ?grep", "| grep", message.message)
+            return message
+
+        grep = False
+        if not re.search(r".+\| ?grep (.+)", message.raw_text):
+            return message
+
+        grep = re.search(r".+\| ?grep (.+)", message.raw_text).group(1)
+        message.text = re.sub(r"\| ?grep.+", "", message.text)
+        message.raw_text = re.sub(r"\| ?grep.+", "", message.raw_text)
+        message.message = re.sub(r"\| ?grep.+", "", message.message)
+
+        ungrep = False
+
+        if re.search(r"-v (.+)", grep):
+            ungrep = re.search(r"-v (.+)", grep).group(1)
+            grep = re.sub(r"(.+) -v .+", r"\g<1>", grep)
+
+        grep = utils.escape_html(grep).strip() if grep else False
+        ungrep = utils.escape_html(ungrep).strip() if ungrep else False
+
+        old_edit = message.edit
+        old_reply = message.reply
+        old_respond = message.respond
+
+        def process_text(text: str) -> str:
+            nonlocal grep, ungrep
+            res = []
+
+            for line in text.split("\n"):
+                if (
+                    grep
+                    and grep in re.sub("<.*?>", "", line)
+                    and (not ungrep or ungrep not in re.sub("<.*?>", "", line))
+                ):
+                    res.append(line.replace(grep, f"<u>{grep}</u>"))
+
+                if not grep and ungrep and ungrep not in re.sub("<.*?>", "", line):
+                    res.append(line)
+
+            cont = (
+                (f"contain <b>{grep}</b>" if grep else "")
+                + (" and" if grep and ungrep else "")
+                + ((" do not contain <b>" + ungrep + "</b>") if ungrep else "")
+            )
+
+            if res:
+                text = f"<i>üí¨ Lines that {cont}:</i>\n" + ("\n".join(res))
+            else:
+                text = f"üí¨ <i>No lines that {cont}</i>"
+
+            return text
+
+        async def my_edit(text, *args, **kwargs):
+            text = process_text(text)
+            kwargs["parse_mode"] = "HTML"
+            return await old_edit(text, *args, **kwargs)
+
+        async def my_reply(text, *args, **kwargs):
+            text = process_text(text)
+            kwargs["parse_mode"] = "HTML"
+            return await old_reply(text, *args, **kwargs)
+
+        async def my_respond(text, *args, **kwargs):
+            text = process_text(text)
+            kwargs["parse_mode"] = "HTML"
+            return await old_respond(text, *args, **kwargs)
+
+        message.edit = my_edit
+        message.reply = my_reply
+        message.respond = my_respond
+
+        return message
+
+    async def _handle_command(self, event) -> Union[bool, Tuple[Message, str, str, FunctionType]]:
+        if not hasattr(event, "message") or not hasattr(event.message, "message"):
+            return False
+
+        prefix = self._db.get(main.__name__, "command_prefix", False) or "."
+        if isinstance(prefix, list):
+            prefix = prefix[0]
+            self._db.set(main.__name__, "command_prefix", prefix)
+
+        if len(prefix) != 1:
+            prefix = "."
+            self._db.set(main.__name__, "command_prefix", prefix)
+            logging.warning("Prefix has been reset to a default one (¬´.¬ª)")
+
+        change = str.maketrans(ru_keys + en_keys, en_keys + ru_keys)
+        message = utils.censor(event.message)
+
+        if event.message.message.startswith(prefix):
+            pass
+        elif event.message.message.startswith(str.translate(prefix, change)):
+            prefix = str.translate(prefix, change)
+            message.message = str.translate(message.message, change)
+        else:
+            return False
+
+        if (
+            event.sticker
+            or event.dice
+            or event.audio
+            or event.via_bot_id
+            or getattr(event, "reactions", False)
+        ):
+            return False
+
+        blacklist_chats = self._db.get(main.__name__, "blacklist_chats", [])
+        whitelist_chats = self._db.get(main.__name__, "whitelist_chats", [])
+        whitelist_modules = self._db.get(main.__name__, "whitelist_modules", [])
+
+        if utils.get_chat_id(message) in blacklist_chats or (
+            whitelist_chats and utils.get_chat_id(message) not in whitelist_chats
+        ):
+            return False
+
+        if (
+            message.out
+            and len(message.message) > len(prefix)
+            and message.message[: len(prefix) * 2] == prefix * 2
+            and message.message != len(message.message) // len(prefix) * prefix
+        ):
+            # Allow escaping commands using .'s
+            entities = utils.relocate_entities(
+                message.entities,
+                -len(prefix),
+                message.message,
+            )
+
+            await message.edit(
+                message.message[len(prefix) :],
+                parse_mode=lambda s: (s, entities or ()),
+            )
+            return False
+
+        message.message = message.message[len(prefix) :]
+
+        if not message.message:
+            return False  # Message is just the prefix
+
+        utils.relocate_entities(message.entities, -len(prefix))
+
+        try:
+            initiator = event.sender_id
+        except Exception:
+            initiator = 0
+
+        command = message.message.split(maxsplit=1)[0]
+        tag = command.split("@", maxsplit=1)
+
+        if len(tag) == 2:
+            if tag[1] == "me":
+                if not message.out:
+                    return False
+            elif tag[1].lower() != self._cached_username:
+                return False
+        elif (
+            event.mentioned
+            and event.message is not None
+            and event.message.message is not None
+            and f"@{self._cached_username}" not in event.message.message
+        ):
+            pass
+        elif (
+            not event.is_private
+            and not self.no_nickname
+            and not event.out
+            and not self._db.get(main.__name__, "no_nickname", False)
+            and command not in self._db.get(main.__name__, "nonickcmds", [])
+            and initiator not in self._db.get(main.__name__, "nonickusers", [])
+        ):
+            logging.debug("Ignoring message without nickname")
+            return False
+
+        txt, func = self._modules.dispatch(tag[0])
+
+        if (
+            not func
+            or not await self._handle_ratelimit(message, func)
+            or not await self.security.check(message, func)
+        ):
+            return False
+
+        if (
+            message.is_channel
+            and message.is_group
+            and message.chat.title.startswith("hikka-")
+            and message.chat.title != "hikka-logs"
+        ):
+            logging.warning("Ignoring message in datachat \\ logging chat")
+            return False
+
+        message.message = txt + message.message[len(command) :]
+
+        if (
+            f"{str(utils.get_chat_id(message))}.{func.__self__.__module__}"
+            in blacklist_chats
+        ):
+            logging.debug("Command is blacklisted in chat")
+            return False
+
+        if (
+            whitelist_modules
+            and f"{utils.get_chat_id(message)}.{func.__self__.__module__}"
+            not in whitelist_modules
+        ):
+            logging.debug("Command is not whitelisted in chat")
+            return False
+
+        if self._db.get(main.__name__, "grep", False):
+            message = self._handle_grep(message)
+
+        return message, prefix, txt, func
+
+    async def handle_command(self, event: Message) -> None:
+        """Handle all commands"""
+        message = await self._handle_command(event)
+        if not message:
+            return
+
+        message, prefix, txt, func = message
+
+        try:
+            await func(message)
+        except Exception:
+            logging.exception("Command failed")
+            if not self._db.get(main.__name__, "inlinelogs", True):
+                try:
+                    txt = f"<b>üö´ Command</b> <code>{prefix}{utils.escape_html(message.message)}</code><b> failed!</b>"
+                    await (message.edit if message.out else message.reply)(txt)
+                except Exception:
+                    pass
+                return
+
+            try:
+                exc = traceback.format_exc()
+                # Remove `Traceback (most recent call last):`
+                exc = "\n".join(exc.split("\n")[1:])
+                txt = (
+                    f"<b>üö´ Command</b> <code>{prefix}{utils.escape_html(message.message)}</code><b> failed!</b>\n\n"
+                    f"<b>‚õë Traceback:</b>\n<code>{exc}</code>"
+                )
+                await (message.edit if message.out else message.reply)(txt)
+            except Exception:
+                pass
+
+    async def handle_incoming(self, event):
+        """Handle all incoming messages"""
+        message = utils.censor(getattr(event, "message", event))
+
+        blacklist_chats = self._db.get(main.__name__, "blacklist_chats", [])
+        whitelist_chats = self._db.get(main.__name__, "whitelist_chats", [])
+        whitelist_modules = self._db.get(main.__name__, "whitelist_modules", [])
+
+        # fmt: off
+        if (
+            utils.get_chat_id(message) in blacklist_chats
+            or (
+                whitelist_chats
+                and utils.get_chat_id(message)
+                not in whitelist_chats
+            )
+        ):
+            logging.debug("Message is blacklisted")
+            return
+        # fmt: on
+
+        for func in self._modules.watchers:
+            bl = self._db.get(main.__name__, "disabled_watchers", {})
+            modname = str(func.__self__.__class__.strings["name"])
+
+            if (
+                modname in bl
+                and isinstance(message, types.Message)
+                and (
+                    "*" in bl[modname]
+                    or utils.get_chat_id(message) in bl[modname]
+                    or "only_chats" in bl[modname]
+                    and message.is_private
+                    or "only_pm" in bl[modname]
+                    and not message.is_private
+                    or "out" in bl[modname]
+                    and not message.out
+                    or "in" in bl[modname]
+                    and message.out
+                )
+                or f"{str(utils.get_chat_id(message))}.{func.__self__.__module__}"
+                in blacklist_chats
+                or (
+                    whitelist_modules
+                    and (
+                        f"{str(utils.get_chat_id(message))}." + func.__self__.__module__
+                    )
+                    not in whitelist_modules
+                )
+            ):
+                logging.debug(f"Ignored watcher of module {modname}")
+                continue
+
+            try:
+                await func(message)
+            except Exception as e:
+                logging.exception(f"Error running watcher {e}")
diff --git a/hikka/inline/bot_interaction.py b/hikka/inline/bot_interaction.py
new file mode 100644
index 0000000..c1d5d30
--- /dev/null
+++ b/hikka/inline/bot_interaction.py
@@ -0,0 +1,54 @@
+from .types import InlineUnit
+
+from aiogram.types import Message as AiogramMessage
+
+from typing import Union
+import logging
+
+logger = logging.getLogger(__name__)
+
+
+class BotInteractions(InlineUnit):
+    def ss(self, user: Union[str, int], state: Union[str, bool]) -> bool:
+        if not isinstance(user, (str, int)):
+            logger.error("Invalid type for `user` in `ss`")
+            return False
+
+        if not isinstance(state, (str, bool)):
+            logger.error("Invalid type for `state` in `ss`")
+            return False
+
+        if state:
+            self.fsm[str(user)] = state
+        elif str(user) in self.fsm:
+            del self.fsm[str(user)]
+
+        return True
+
+    def gs(self, user: Union[str, int]) -> Union[bool, str]:
+        if not isinstance(user, (str, int)):
+            logger.error("Invalid type for `user` in `gs`")
+            return False
+
+        return self.fsm.get(str(user), False)
+
+    async def _bot_message_answer(  # skipcq: PYL-E0213
+        mod,
+        text: str = None,
+        message: AiogramMessage = None,
+        parse_mode: str = "HTML",
+        disable_web_page_preview: bool = True,
+        **kwargs,
+    ) -> bool:
+        try:
+            await mod.bot.send_message(
+                message.chat.id,
+                text,
+                parse_mode=parse_mode,
+                disable_web_page_preview=disable_web_page_preview,
+                **kwargs,
+            )
+        except Exception:
+            return False
+
+        return True
diff --git a/hikka/inline/core.py b/hikka/inline/core.py
new file mode 100644
index 0000000..ed1c06b
--- /dev/null
+++ b/hikka/inline/core.py
@@ -0,0 +1,259 @@
+"""Inline buttons, galleries and other Telegram-Bot-API stuff"""
+
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+from aiogram import Bot, Dispatcher
+from aiogram.utils.exceptions import Unauthorized, TerminatedByOtherGetUpdates
+
+import time
+import asyncio
+
+from telethon.errors.rpcerrorlist import InputUserDeactivatedError
+from telethon.utils import get_display_name
+
+from .gallery import Gallery
+from .form import Form
+from .bot_interaction import BotInteractions
+from .events import Events
+from .token_obtainment import TokenObtainment
+
+from typing import Union, Callable
+import inspect
+from .. import security
+
+import logging
+
+logger = logging.getLogger(__name__)
+
+
+class InlineManager(Gallery, Form, BotInteractions, Events, TokenObtainment):
+    def __init__(self, client, db, allmodules) -> None:
+        """Initialize InlineManager to create forms"""
+        self._client = client
+        self._db = db
+        self._allmodules = allmodules
+
+        self._token = db.get("hikka.inline", "bot_token", False)
+
+        self._forms = {}
+        self._galleries = {}
+        self._custom_map = {}
+
+        self.fsm = {}
+
+        self._web_auth_tokens = []
+
+        self._markup_ttl = 60 * 60 * 24
+
+        self.init_complete = False
+
+    def check_inline_security(self, func, user):
+        """Checks if user with id `user` is allowed to run function `func`"""
+        allow = (user in [self._me] + self._client.dispatcher.security._owner)  # fmt: skip
+
+        if not hasattr(func, "__doc__") or not func.__doc__ or allow:
+            return allow
+
+        doc = func.__doc__
+
+        for line in doc.splitlines():
+            line = line.strip()
+            if line.startswith("@allow:"):
+                allow_line = line.split(":")[1].strip()
+
+                # First we check for possible group limits
+                # like `sudo`, `support`, `all`. Then check
+                # for the occurrence of user in overall string
+                # This allows dev to use any delimiter he wants
+                if (
+                    "all" in allow_line
+                    or "sudo" in allow_line
+                    and user in self._client.dispatcher.security._sudo
+                    or "support" in allow_line
+                    and user in self._client.dispatcher.security._support
+                    or str(user) in allow_line
+                ):
+                    allow = True
+
+        # But don't hurry to return value, we need to check,
+        # if there are any limits
+        for line in doc.splitlines():
+            line = line.strip()
+            if line.startswith("@restrict:"):
+                restrict = line.split(":")[1].strip()
+
+                if (
+                    "all" in restrict
+                    or "sudo" in restrict
+                    and user in self._client.dispatcher.security._sudo
+                    or "support" in restrict
+                    and user in self._client.dispatcher.security._support
+                    or str(user) in restrict
+                ):
+                    allow = True
+
+        return allow
+
+    async def _cleaner(self) -> None:
+        """Cleans outdated _forms"""
+        while True:
+            for form_uid, form in self._forms.copy().items():
+                if form.get("ttl", time.time() + self._markup_ttl) < time.time():
+                    del self._forms[form_uid]
+
+            for gallery_uid, gallery in self._galleries.copy().items():
+                if gallery.get("ttl", time.time() + self._markup_ttl) < time.time():
+                    del self._galleries[gallery_uid]
+
+            for map_uid, config in self._custom_map.copy().items():
+                if config.get("ttl", time.time() + self._markup_ttl) < time.time():
+                    del self._custom_map[map_uid]
+
+            await asyncio.sleep(5)
+
+    def _find_caller_sec_map(self) -> Union[Callable, None]:
+        try:
+            return next(
+                next(
+                    lambda: self._db.get(security.__name__, "masks", {}).get(
+                        f"{getattr(cls_, stack_entry.function).__module__}.{getattr(cls_, stack_entry.function).__name__}",
+                        getattr(
+                            getattr(cls_, stack_entry.function),
+                            "security",
+                            self._client.dispatcher.security._default,
+                        ),
+                    )
+                    for name, cls_ in stack_entry.frame.f_globals.items()
+                    if name.endswith("Mod") and hasattr(cls_, "strings")
+                )
+                for stack_entry in inspect.stack()
+                if hasattr(stack_entry, "function")
+                and stack_entry.function.endswith("cmd")
+            )
+        except Exception:
+            logger.exception("Can't parse security mask in form")
+            return None
+
+    async def _register_manager(
+        self,
+        after_break: bool = False,
+        ignore_token_checks: bool = False,
+    ) -> None:
+        # Get info about user to use it in this class
+        me = await self._client.get_me()
+        self._me = me.id
+        self._name = get_display_name(me)
+
+        if not ignore_token_checks:
+            # Assert that token is set to valid, and if not,
+            # set `init_complete` to `False` and return
+            is_token_asserted = await self._assert_token()
+            if not is_token_asserted:
+                self.init_complete = False
+                return
+
+        # We successfully asserted token, so set `init_complete` to `True`
+        self.init_complete = True
+
+        # Create bot instance and dispatcher
+        self.bot = Bot(token=self._token)
+        self._bot = self.bot  # This is a temporary alias so the
+        # developers can adapt their code
+        self._dp = Dispatcher(self.bot)
+
+        # Get bot username to call inline queries
+        try:
+            self.bot_username = (await self.bot.get_me()).username
+            self._bot_username = self.bot_username  # This is a temporary alias so the
+            # developers can adapt their code
+        except Unauthorized:
+            logger.critical("Token expired, revoking...")
+            return await self._dp_revoke_token(False)
+
+        # Start the bot in case it can send you messages
+        try:
+            m = await self._client.send_message(self.bot_username, "/start")
+        except (InputUserDeactivatedError, ValueError):
+            self._db.set("hikka.inline", "bot_token", None)
+            self._token = False
+
+            if not after_break:
+                return await self._register_manager(True)
+
+            self.init_complete = False
+            return False
+        except Exception:
+            self.init_complete = False
+            logger.critical("Initialization of inline manager failed!")
+            logger.exception("due to")
+            return False
+
+        await self._client.delete_messages(self.bot_username, m)
+
+        # Register required event handlers inside aiogram
+        self._dp.register_inline_handler(
+            self._inline_handler,
+            lambda inline_query: True,
+        )
+
+        self._dp.register_callback_query_handler(
+            self._callback_query_handler,
+            lambda query: True,
+        )
+
+        self._dp.register_chosen_inline_handler(
+            self._chosen_inline_handler,
+            lambda chosen_inline_query: True,
+        )
+
+        self._dp.register_message_handler(
+            self._message_handler,
+            lambda *args: True,
+            content_types=["any"],
+        )
+
+        old = self.bot.get_updates
+        revoke = self._dp_revoke_token
+
+        async def new(*args, **kwargs):
+            nonlocal revoke, old
+            try:
+                return await old(*args, **kwargs)
+            except TerminatedByOtherGetUpdates:
+                await revoke()
+            except Unauthorized:
+                logger.critical("Got Unauthorized")
+                await self._stop()
+
+        self.bot.get_updates = new
+
+        # Start polling as the separate task, just in case we will need
+        # to force stop this coro. It should be cancelled only by `stop`
+        # because it stops the bot from getting updates
+        self._task = asyncio.ensure_future(self._dp.start_polling())
+        self._cleaner_task = asyncio.ensure_future(self._cleaner())
+
+    async def _stop(self) -> None:
+        self._task.cancel()
+        self._dp.stop_polling()
+        self._cleaner_task.cancel()
+
+    def pop_web_auth_token(self, token) -> bool:
+        """Check if web confirmation button was pressed"""
+        if token not in self._web_auth_tokens:
+            return False
+
+        self._web_auth_tokens.remove(token)
+        return True
+
+
+if __name__ == "__main__":
+    raise Exception("This file must be called as a module")
diff --git a/hikka/inline/events.py b/hikka/inline/events.py
new file mode 100644
index 0000000..379cea4
--- /dev/null
+++ b/hikka/inline/events.py
@@ -0,0 +1,329 @@
+from .types import InlineUnit, InlineCall
+from aiogram.types import (
+    Message as AiogramMessage,
+    InlineQuery as AiogramInlineQuery,
+    CallbackQuery,
+    ChosenInlineResult,
+    InlineQueryResultArticle,
+    InputTextMessageContent,
+)
+import logging
+from typing import List
+import re
+from .. import utils
+from .types import InlineQuery
+import functools
+import inspect
+from telethon.tl.types import Message
+
+logger = logging.getLogger(__name__)
+
+
+class Events(InlineUnit):
+    async def _message_handler(self, message: AiogramMessage) -> None:
+        """Processes incoming messages"""
+        if message.chat.type != "private":
+            return
+
+        for mod in self._allmodules.modules:
+            if not hasattr(mod, "aiogram_watcher"):
+                continue
+
+            setattr(
+                message,
+                "answer",
+                functools.partial(
+                    self._bot_message_answer,
+                    message=message,
+                ),
+            )
+
+            try:
+                await mod.aiogram_watcher(message)
+            except BaseException:
+                logger.exception("Error on running aiogram watcher!")
+
+    async def _inline_handler(self, inline_query: AiogramInlineQuery) -> None:
+        """Inline query handler (forms' calls)"""
+        # Retrieve query from passed object
+        query = inline_query.query
+
+        # If we didn't get any query, return help
+        if not query:
+            await self._query_help(inline_query)
+            return
+
+        # First, dispatch all registered inline handlers
+        for mod in self._allmodules.modules:
+            if (
+                not hasattr(mod, "inline_handlers")
+                or not isinstance(mod.inline_handlers, dict)
+                or not mod.inline_handlers
+            ):
+                continue
+
+            instance = InlineQuery(inline_query)
+
+            for query_text, query_func in mod.inline_handlers.items():
+                if inline_query.query.split()[
+                    0
+                ].lower() == query_text.lower() and self.check_inline_security(
+                    query_func, inline_query.from_user.id
+                ):
+                    try:
+                        await query_func(instance)
+                    except BaseException:
+                        logger.exception("Error on running inline watcher!")
+
+        await self._form_inline_handler(inline_query)
+        await self._gallery_inline_handler(inline_query)
+
+    async def _check_inline_sec_by_mask(
+        self,
+        *,
+        mask: int,
+        user: int,
+        message: Message,
+    ) -> bool:
+        """Checks if user is able to execute command with provided security mask"""
+        return await self._client.dispatcher.security._check(
+            message=message,
+            func=mask,
+            user=user,
+        )
+
+    async def _callback_query_handler(
+        self,
+        query: CallbackQuery,
+        reply_markup: List[List[dict]] = None,
+    ) -> None:
+        """Callback query handler (buttons' presses)"""
+        if reply_markup is None:
+            reply_markup = []
+
+        if re.search(r"authorize_web_(.{8})", query.data):
+            self._web_auth_tokens += [
+                re.search(r"authorize_web_(.{8})", query.data).group(1)
+            ]
+            return
+
+        # First, dispatch all registered callback handlers
+        for mod in self._allmodules.modules:
+            if (
+                not hasattr(mod, "callback_handlers")
+                or not isinstance(mod.callback_handlers, dict)
+                or not mod.callback_handlers
+            ):
+                continue
+
+            for query_func in mod.callback_handlers.values():
+                if self.check_inline_security(query_func, query.from_user.id):
+                    try:
+                        await query_func(query)
+                    except Exception:
+                        logger.exception("Error on running callback watcher!")
+                        await query.answer(
+                            "Error occured while processing request. More info in logs",
+                            show_alert=True,
+                        )
+                        return
+
+        for form_uid, form in self._forms.copy().items():
+            for button in utils.array_sum(form.get("buttons", [])):
+                if button.get("_callback_data", None) == query.data:
+                    if (
+                        form.get("force_me", False) and query.from_user.id == self._me
+                    ) or (
+                        await self._check_inline_sec_by_mask(
+                            mask=form.get(
+                                "perms_map",
+                                lambda: self._client.dispatcher.security._default,
+                            )(),
+                            user=query.from_user.id,
+                            message=form["message"],
+                        )
+                        if "message" in form
+                        else False
+                    ):
+                        pass
+                    elif (
+                        query.from_user.id
+                        not in self._client.dispatcher.security._owner
+                        and query.from_user.id not in form.get("always_allow", [])
+                    ):
+                        await query.answer("You are not allowed to press this button!")
+                        return
+
+                    query.delete = functools.partial(
+                        self._callback_query_delete,
+                        form=form,
+                        form_uid=form_uid,
+                    )
+
+                    query.unload = functools.partial(
+                        self._callback_query_unload,
+                        form_uid=form_uid,
+                    )
+
+                    query.edit = functools.partial(
+                        self._callback_query_edit,
+                        query=query,
+                        form=form,
+                        form_uid=form_uid,
+                    )
+
+                    query.form = {"id": form_uid, **form}
+
+                    try:
+                        return await button["callback"](
+                            query,
+                            *button.get("args", []),
+                            **button.get("kwargs", {}),
+                        )
+                    except Exception:
+                        logger.exception("Error on running callback watcher!")
+                        await query.answer(
+                            "Error occurred while "
+                            "processing request. "
+                            "More info in logs",
+                            show_alert=True,
+                        )
+                        return
+
+                    del self._forms[form_uid]
+
+        if query.data in self._custom_map:
+            if (
+                self._custom_map[query.data].get("force_me", False)
+                and query.from_user.id == self._me
+            ) or (
+                await self._check_inline_sec_by_mask(
+                    mask=self._custom_map[query.data].get(
+                        "perms_map",
+                        lambda: self._client.dispatcher.security._default,
+                    )(),
+                    user=query.from_user.id,
+                    message=self._custom_map[query.data]["message"],
+                )
+                if "message" in self._custom_map[query.data]
+                else False
+            ):
+                pass
+            elif (
+                query.from_user.id not in self._client.dispatcher.security._owner
+                and query.from_user.id
+                not in self._custom_map[query.data].get("always_allow", [])
+            ):
+                await query.answer("You are not allowed to press this button!")
+                return
+
+            await self._custom_map[query.data]["handler"](
+                query,
+                *self._custom_map[query.data].get("args", []),
+                **self._custom_map[query.data].get("kwargs", {}),
+            )
+            return
+
+    async def _chosen_inline_handler(
+        self,
+        chosen_inline_query: ChosenInlineResult,
+    ) -> None:
+        query = chosen_inline_query.query
+
+        for form_uid, form in self._forms.copy().items():
+            for button in utils.array_sum(form.get("buttons", [])):
+                if (
+                    "_switch_query" in button
+                    and "input" in button
+                    and button["_switch_query"] == query.split()[0]
+                    and chosen_inline_query.from_user.id
+                    in [self._me]
+                    + self._client.dispatcher.security._owner
+                    + form.get("always_allow", [])
+                ):
+
+                    query = query.split(maxsplit=1)[1] if len(query.split()) > 1 else ""
+
+                    call = InlineCall()
+
+                    call.delete = functools.partial(
+                        self._callback_query_delete,
+                        form=form,
+                        form_uid=form_uid,
+                    )
+                    call.unload = functools.partial(
+                        self._callback_query_unload,
+                        form_uid=form_uid,
+                    )
+                    call.edit = functools.partial(
+                        self._callback_query_edit,
+                        query=chosen_inline_query,
+                        form=form,
+                        form_uid=form_uid,
+                    )
+
+                    try:
+                        return await button["handler"](
+                            call,
+                            query,
+                            *button.get("args", []),
+                            **button.get("kwargs", {}),
+                        )
+                    except Exception:
+                        logger.exception(
+                            "Exception while running chosen query watcher!"
+                        )
+                        return
+
+    async def _query_help(self, inline_query: InlineQuery) -> None:
+        _help = ""
+        for mod in self._allmodules.modules:
+            if (
+                not hasattr(mod, "inline_handlers")
+                or not isinstance(mod.inline_handlers, dict)
+                or not mod.inline_handlers
+            ):
+                continue
+
+            _ihandlers = dict(mod.inline_handlers.items())
+            for name, fun in _ihandlers.items():
+                # If user doesn't have enough permissions
+                # to run this inline command, do not show it
+                # in help
+                if not self.check_inline_security(fun, inline_query.from_user.id):
+                    continue
+
+                # Retrieve docs from func
+                try:
+                    doc = utils.escape_html(
+                        "\n".join(
+                            [
+                                line.strip()
+                                for line in inspect.getdoc(fun).splitlines()
+                                if not line.strip().startswith("@")
+                            ]
+                        )
+                    )
+                except AttributeError:
+                    doc = "ü¶• No docs"
+
+                _help += f"üéπ <code>@{self.bot_username} {name}</code> - {doc}\n"
+
+        await inline_query.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="Show available inline commands",
+                    description=f"You have {len(_help.splitlines())} available command(-s)",
+                    input_message_content=InputTextMessageContent(
+                        f"<b>‚ÑπÔ∏è Available inline commands:</b>\n\n{_help}",
+                        "HTML",
+                        disable_web_page_preview=True,
+                    ),
+                    thumb_url="https://img.icons8.com/fluency/50/000000/info-squared.png",
+                    thumb_width=128,
+                    thumb_height=128,
+                )
+            ],
+            cache_time=0,
+        )
diff --git a/hikka/inline/form.py b/hikka/inline/form.py
new file mode 100644
index 0000000..8004688
--- /dev/null
+++ b/hikka/inline/form.py
@@ -0,0 +1,399 @@
+from .types import InlineUnit
+from .. import utils
+
+from aiogram.types import (
+    InlineKeyboardMarkup,
+    InlineKeyboardButton,
+    InlineQueryResultArticle,
+    InputTextMessageContent,
+    InlineQuery,
+)
+
+from aiogram.utils.exceptions import (
+    MessageNotModified,
+    RetryAfter,
+    MessageIdInvalid,
+    InvalidQueryID,
+)
+
+from typing import Union, List, Any
+from types import FunctionType
+from telethon.tl.types import Message
+import logging
+import asyncio
+import time
+
+logger = logging.getLogger(__name__)
+
+
+class Form(InlineUnit):
+    async def form(
+        self,
+        text: str,
+        message: Union[Message, int],
+        reply_markup: List[List[dict]] = None,
+        *,
+        force_me: bool = True,
+        always_allow: Union[List[list], None] = None,
+        ttl: Union[int, bool] = False,
+        on_unload: Union[FunctionType, None] = None,
+        manual_security: bool = False,
+    ) -> Union[str, bool]:
+        """Creates inline form with callback
+        Args:
+                text
+                        Content of inline form. HTML markdown supported
+                message
+                        Where to send inline. Can be either `Message` or `int`
+                reply_markup
+                        List of buttons to insert in markup. List of dicts with
+                        keys: text, callback
+                force_me
+                        Either this form buttons must be pressed only by owner scope or no
+                always_allow
+                        Users, that are allowed to press buttons in addition to previous rules
+                ttl
+                        Time, when the form is going to be unloaded. Unload means, that the form
+                        buttons with inline queries and callback queries will become unusable, but
+                        buttons with type url will still work as usual. Pay attention, that ttl can't
+                        be bigger, than default one (1 day) and must be either `int` or `False`
+                on_unload
+                        Callback, called when form is unloaded and/or closed. You can clean up trash
+                        or perform another needed action
+                manual_security
+                        By default, Hikka will try to inherit inline buttons security from the caller (command)
+                        If you want to avoid this, pass `manual_security=True`
+        """
+
+        if reply_markup is None:
+            reply_markup = []
+
+        if always_allow is None:
+            always_allow = []
+
+        if not isinstance(text, str):
+            logger.error("Invalid type for `text`")
+            return False
+
+        if not isinstance(manual_security, bool):
+            logger.error("Invalid type for `manual_security`")
+            return False
+
+        if not isinstance(message, (Message, int)):
+            logger.error("Invalid type for `message`")
+            return False
+
+        if not isinstance(reply_markup, list):
+            logger.error("Invalid type for `reply_markup`")
+            return False
+
+        if not all(
+            all(isinstance(button, dict) for button in row) for row in reply_markup
+        ):
+            logger.error("Invalid type for one of the buttons. It must be `dict`")
+            return False
+
+        if not all(
+            all(
+                "url" in button
+                or "callback" in button
+                or "input" in button
+                or "data" in button
+                for button in row
+            )
+            for row in reply_markup
+        ):
+            logger.error(
+                "Invalid button specified. "
+                "Button must contain one of the following fields:\n"
+                "  - `url`\n"
+                "  - `callback`\n"
+                "  - `input`\n"
+                "  - `data`"
+            )
+            return False
+
+        if not isinstance(force_me, bool):
+            logger.error("Invalid type for `force_me`")
+            return False
+
+        if not isinstance(always_allow, list):
+            logger.error("Invalid type for `always_allow`")
+            return False
+
+        if not isinstance(ttl, int) and ttl:
+            logger.error("Invalid type for `ttl`")
+            return False
+
+        if isinstance(ttl, int) and (ttl > self._markup_ttl or ttl < 10):
+            ttl = None
+            logger.debug("Defaulted ttl, because it breaks out of limits")
+
+        form_uid = utils.rand(30)
+
+        perms_map = self._find_caller_sec_map() if not manual_security else None
+
+        self._forms[form_uid] = {
+            "text": text,
+            "buttons": reply_markup,
+            "chat": None,
+            "message_id": None,
+            "uid": form_uid,
+            "on_unload": on_unload,
+            **({"perms_map": perms_map} if perms_map else {}),
+            **({"message": message} if isinstance(message, Message) else {}),
+            **({"force_me": force_me} if force_me else {}),
+            **({"ttl": round(time.time()) + ttl} if ttl else {}),
+            **({"always_allow": always_allow} if always_allow else {}),
+        }
+
+        try:
+            q = await self._client.inline_query(self.bot_username, form_uid)
+            m = await q[0].click(
+                utils.get_chat_id(message) if isinstance(message, Message) else message,
+                reply_to=message.reply_to_msg_id
+                if isinstance(message, Message)
+                else None,
+            )
+        except Exception:
+            msg = (
+                "üö´ <b>A problem occurred with inline bot "
+                "while processing query. Check logs for "
+                "further info.</b>"
+            )
+
+            del self._forms[form_uid]
+            if isinstance(message, Message):
+                await (message.edit if message.out else message.respond)(msg)
+            else:
+                await self._client.send_message(message, msg)
+
+            return False
+
+        self._forms[form_uid]["chat"] = utils.get_chat_id(m)
+        self._forms[form_uid]["message_id"] = m.id
+        if isinstance(message, Message):
+            await message.delete()
+
+        if not any(
+            any("callback" in button or "input" in button for button in row)
+            for row in reply_markup
+        ):
+            del self._forms[form_uid]
+            logger.debug(
+                f"Unloading form {form_uid}, because it "
+                "doesn't contain any button callbacks"
+            )
+
+        return form_uid
+
+    def _generate_markup(self, form_uid: Union[str, list]) -> InlineKeyboardMarkup:
+        """Generate markup for form"""
+        markup = InlineKeyboardMarkup()
+
+        for row in (
+            self._forms[form_uid]["buttons"] if isinstance(form_uid, str) else form_uid
+        ):
+            for button in row:
+                if "callback" in button and "_callback_data" not in button:
+                    button["_callback_data"] = utils.rand(30)
+
+                if "input" in button and "_switch_query" not in button:
+                    button["_switch_query"] = utils.rand(10)
+
+        for row in (
+            self._forms[form_uid]["buttons"] if isinstance(form_uid, str) else form_uid
+        ):
+            line = []
+            for button in row:
+                try:
+                    if "url" in button:
+                        line += [
+                            InlineKeyboardButton(
+                                button["text"],
+                                url=button.get("url", None),
+                            )
+                        ]
+                    elif "callback" in button:
+                        line += [
+                            InlineKeyboardButton(
+                                button["text"],
+                                callback_data=button["_callback_data"],
+                            )
+                        ]
+                    elif "input" in button:
+                        line += [
+                            InlineKeyboardButton(
+                                button["text"],
+                                switch_inline_query_current_chat=button["_switch_query"] + " ",  # fmt: skip
+                            )
+                        ]
+                    elif "data" in button:
+                        line += [
+                            InlineKeyboardButton(
+                                button["text"],
+                                callback_data=button["data"],
+                            )
+                        ]
+                    else:
+                        logger.warning(
+                            "Button have not been added to "
+                            "form, because it is not structured "
+                            f"properly. {button}"
+                        )
+                except KeyError:
+                    logger.exception(
+                        "Error while forming markup! Probably, you "
+                        "passed wrong type combination for button. "
+                        "Contact developer of module."
+                    )
+                    return False
+
+            markup.row(*line)
+
+        return markup
+
+    async def _callback_query_edit(
+        self,
+        text: str,
+        reply_markup: List[List[dict]] = None,
+        force_me: Union[bool, None] = None,
+        always_allow: Union[List[int], None] = None,
+        query: Any = None,
+        form: Any = None,
+        form_uid: Any = None,
+        inline_message_id: Union[str, None] = None,
+        disable_web_page_preview: bool = True,
+    ) -> None:
+        """Do not edit or pass `self`, `query`, `form`, `form_uid` params, they are for internal use only"""
+        if reply_markup is None:
+            reply_markup = []
+
+        if not isinstance(text, str):
+            logger.error("Invalid type for `text`")
+            return False
+
+        if isinstance(reply_markup, list):
+            form["buttons"] = reply_markup
+        if isinstance(force_me, bool):
+            form["force_me"] = force_me
+        if isinstance(always_allow, list):
+            form["always_allow"] = always_allow
+        try:
+            await self.bot.edit_message_text(
+                text,
+                inline_message_id=inline_message_id or query.inline_message_id,
+                parse_mode="HTML",
+                disable_web_page_preview=disable_web_page_preview,
+                reply_markup=self._generate_markup(form_uid),
+            )
+        except MessageNotModified:
+            try:
+                await query.answer()
+            except InvalidQueryID:
+                pass  # Just ignore that error, bc we need to just
+                # remove preloader from user's button, if message
+                # was deleted
+
+        except RetryAfter as e:
+            logger.info(f"Sleeping {e.timeout}s on aiogram FloodWait...")
+            await asyncio.sleep(e.timeout)
+            return await self._callback_query_edit(
+                text,
+                reply_markup,
+                force_me,
+                always_allow,
+                query,
+                form,
+                form_uid,
+                inline_message_id,
+            )
+        except MessageIdInvalid:
+            try:
+                await query.answer(
+                    "I should have edited some message, but it is deleted :("
+                )
+            except InvalidQueryID:
+                pass  # Just ignore that error, bc we need to just
+                # remove preloader from user's button, if message
+                # was deleted
+
+    async def _callback_query_delete(
+        self,
+        form: Any = None,
+        form_uid: Any = None,
+    ) -> bool:
+        """Params `self`, `form`, `form_uid` are for internal use only, do not try to pass them"""
+        try:
+            await self._client.delete_messages(form["chat"], [form["message_id"]])
+
+            if callable(self._forms[form_uid]["on_unload"]):
+                self._forms[form_uid]["on_unload"]()
+
+            del self._forms[form_uid]
+        except Exception:
+            return False
+
+        return True
+
+    async def _callback_query_unload(self, form_uid: Any = None) -> bool:
+        """Params `self`, `form_uid` are for internal use only, do not try to pass them"""
+        try:
+            if callable(self._forms[form_uid]["on_unload"]):
+                self._forms[form_uid]["on_unload"]()
+
+            del self._forms[form_uid]
+        except Exception:
+            return False
+
+        return True
+
+    async def _form_inline_handler(self, inline_query: InlineQuery) -> None:
+        for form in self._forms.copy().values():
+            for button in utils.array_sum(form.get("buttons", [])):
+                if (
+                    "_switch_query" in button
+                    and "input" in button
+                    and button["_switch_query"] == inline_query.query.split()[0]
+                    and inline_query.from_user.id
+                    in [self._me]
+                    + self._client.dispatcher.security._owner
+                    + form.get("always_allow", [])
+                ):
+                    await inline_query.answer(
+                        [
+                            InlineQueryResultArticle(
+                                id=utils.rand(20),
+                                title=button["input"],
+                                description="‚ö†Ô∏è Please, do not remove identifier!",
+                                input_message_content=InputTextMessageContent(
+                                    "üîÑ <b>Transferring value to userbot...</b>\n"
+                                    "<i>This message is gonna be deleted...</i>",
+                                    "HTML",
+                                    disable_web_page_preview=True,
+                                ),
+                            )
+                        ],
+                        cache_time=60,
+                    )
+                    return
+
+        if inline_query.query not in self._forms:
+            return
+
+        # Otherwise, answer it with templated form
+        await inline_query.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="Hikka",
+                    input_message_content=InputTextMessageContent(
+                        self._forms[inline_query.query]["text"],
+                        "HTML",
+                        disable_web_page_preview=True,
+                    ),
+                    reply_markup=self._generate_markup(inline_query.query),
+                )
+            ],
+            cache_time=60,
+        )
diff --git a/hikka/inline/gallery.py b/hikka/inline/gallery.py
new file mode 100644
index 0000000..dff3a16
--- /dev/null
+++ b/hikka/inline/gallery.py
@@ -0,0 +1,712 @@
+from .types import InlineUnit
+from .. import utils
+
+from aiogram.types import (
+    InlineKeyboardMarkup,
+    InlineKeyboardButton,
+    CallbackQuery,
+    InputMediaPhoto,
+    InputMediaAnimation,
+    InlineQueryResultPhoto,
+    InlineQuery,
+    InlineQueryResultGif,
+    InlineQueryResultArticle,
+    InputTextMessageContent,
+)
+
+from aiogram.utils.exceptions import InvalidHTTPUrlContent, BadRequest, RetryAfter
+
+from typing import Union, List
+from types import FunctionType
+from telethon.tl.types import Message
+import logging
+import asyncio
+import time
+import functools
+
+
+logger = logging.getLogger(__name__)
+
+
+class ListGalleryHelper:
+    def __init__(self, lst: List[str]):
+        self.lst = lst
+
+    def __call__(self):
+        elem = self.lst[0]
+        del self.lst[0]
+        return elem
+
+
+class Gallery(InlineUnit):
+    async def gallery(
+        self,
+        message: Union[Message, int],
+        next_handler: Union[FunctionType, List[str]],
+        caption: Union[str, FunctionType] = "",
+        *,
+        force_me: bool = False,
+        always_allow: Union[list, None] = None,
+        ttl: Union[int, bool] = False,
+        on_unload: Union[FunctionType, None] = None,
+        preload: Union[bool, int] = False,
+        gif: bool = False,
+        manual_security: bool = False,
+        _reattempt: bool = False,
+    ) -> Union[bool, str]:
+        """
+        Processes inline gallery
+            caption
+                    Caption for photo, or callable, returning caption
+            message
+                    Where to send inline. Can be either `Message` or `int`
+            next_handler
+                    Callback function, which must return url for next photo or list with photo urls
+            force_me
+                    Either this gallery buttons must be pressed only by owner scope or no
+            always_allow
+                    Users, that are allowed to press buttons in addition to previous rules
+            ttl
+                    Time, when the gallery is going to be unloaded. Unload means, that the gallery
+                    will become unusable. Pay attention, that ttl can't
+                    be bigger, than default one (1 day) and must be either `int` or `False`
+            on_unload
+                    Callback, called when gallery is unloaded and/or closed. You can clean up trash
+                    or perform another needed action
+            preload
+                    Either to preload gallery photos beforehand or no. If yes - specify threshold to
+                    be loaded. Toggle this attribute, if your callback is too slow to load photos
+                    in real time
+            gif
+                    Whether the gallery will be filled with gifs. If you omit this argument and specify
+                    gifs in `next_handler`, they will be interpreted as plain images (not GIFs!)
+            manual_security
+                    By default, Hikka will try to inherit inline buttons security from the caller (command)
+                    If you want to avoid this, pass `manual_security=True`
+        """
+
+        if not isinstance(caption, str) and not callable(caption):
+            logger.error("Invalid type for `caption`")
+            return False
+
+        if not isinstance(manual_security, bool):
+            logger.error("Invalid type for `manual_security`")
+            return False
+
+        if not isinstance(message, (Message, int)):
+            logger.error("Invalid type for `message`")
+            return False
+
+        if not isinstance(force_me, bool):
+            logger.error("Invalid type for `force_me`")
+            return False
+
+        if not isinstance(gif, bool):
+            logger.error("Invalid type for `gif`")
+            return False
+
+        if (
+            not isinstance(preload, (bool, int))
+            or isinstance(preload, bool)
+            and preload
+        ):
+            logger.error("Invalid type for `preload`")
+            return False
+
+        if always_allow and not isinstance(always_allow, list):
+            logger.error("Invalid type for `always_allow`")
+            return False
+
+        if not always_allow:
+            always_allow = []
+
+        if not isinstance(ttl, int) and ttl:
+            logger.error("Invalid type for `ttl`")
+            return False
+
+        if isinstance(ttl, int) and (ttl > self._markup_ttl or ttl < 10):
+            ttl = self._markup_ttl
+            logger.debug("Defaulted ttl, because it breaks out of limits")
+
+        if isinstance(next_handler, list):
+            if all(isinstance(i, str) for i in next_handler):
+                next_handler = ListGalleryHelper(next_handler)
+            else:
+                logger.error("Invalid type for `next_handler`")
+                return False
+
+        gallery_uid = utils.rand(30)
+        btn_call_data = {
+            key: utils.rand(16)
+            for key in {
+                "back",
+                "next",
+                "close",
+                "show",
+            }
+        }
+
+        try:
+            photo_url = await self._call_photo(next_handler)
+            if not photo_url:
+                return False
+        except Exception:
+            logger.exception("Error while parsing first photo in gallery")
+            return False
+
+        perms_map = self._find_caller_sec_map() if not manual_security else None
+
+        self._galleries[gallery_uid] = {
+            "caption": caption,
+            "chat": None,
+            "message_id": None,
+            "uid": gallery_uid,
+            "photo_url": (photo_url if isinstance(photo_url, str) else photo_url[0]),
+            "next_handler": next_handler,
+            "btn_call_data": btn_call_data,
+            "photos": [photo_url] if isinstance(photo_url, str) else photo_url,
+            "current_index": 0,
+            **({"ttl": round(time.time()) + ttl} if ttl else {}),
+            **({"force_me": force_me} if force_me else {}),
+            **({"on_unload": on_unload} if callable(on_unload) else {}),
+            **({"preload": preload} if preload else {}),
+            **({"gif": gif} if gif else {}),
+            **({"always_allow": always_allow} if always_allow else {}),
+            **({"perms_map": perms_map} if perms_map else {}),
+            **({"message": message} if isinstance(message, Message) else {}),
+        }
+
+        default_map = {
+            **(
+                {"always_allow": self._galleries[gallery_uid]["always_allow"]}
+                if "always_allow" in self._galleries[gallery_uid]
+                else {}
+            ),
+            **(
+                {"force_me": self._galleries[gallery_uid]["force_me"]}
+                if "force_me" in self._galleries[gallery_uid]
+                else {}
+            ),
+            **(
+                {"ttl": self._galleries[gallery_uid]["ttl"]}
+                if "ttl" in self._galleries[gallery_uid]
+                else {}
+            ),
+            **({"perms_map": perms_map} if perms_map else {}),
+            **({"message": message} if isinstance(message, Message) else {}),
+        }
+
+        self._custom_map[btn_call_data["back"]] = {
+            "handler": asyncio.coroutine(
+                functools.partial(
+                    self._gallery_back,
+                    btn_call_data=btn_call_data,
+                    gallery_uid=gallery_uid,
+                )
+            ),
+            **default_map,
+        }
+
+        self._custom_map[btn_call_data["close"]] = {
+            "handler": asyncio.coroutine(
+                functools.partial(
+                    self._gallery_close,
+                    btn_call_data=btn_call_data,
+                    gallery_uid=gallery_uid,
+                )
+            ),
+            **default_map,
+        }
+
+        self._custom_map[btn_call_data["next"]] = {
+            "handler": asyncio.coroutine(
+                functools.partial(
+                    self._gallery_next,
+                    func=next_handler,
+                    btn_call_data=btn_call_data,
+                    gallery_uid=gallery_uid,
+                )
+            ),
+            **default_map,
+        }
+
+        self._custom_map[btn_call_data["show"]] = {
+            "handler": asyncio.coroutine(
+                functools.partial(
+                    self._gallery_slideshow,
+                    btn_call_data=btn_call_data,
+                    gallery_uid=gallery_uid,
+                )
+            ),
+            **default_map,
+        }
+
+        if isinstance(message, Message):
+            await (message.edit if message.out else message.respond)(
+                "üë©‚Äçüé§ <b>Loading inline gallery...</b>"
+            )
+
+        try:
+            q = await self._client.inline_query(self.bot_username, gallery_uid)
+            m = await q[0].click(
+                utils.get_chat_id(message) if isinstance(message, Message) else message,
+                reply_to=message.reply_to_msg_id
+                if isinstance(message, Message)
+                else None,
+            )
+        except Exception:
+            logger.exception("Error sending inline gallery")
+
+            del self._galleries[gallery_uid]
+
+            if _reattempt:
+                msg = (
+                    "üö´ <b>A problem occurred with inline bot "
+                    "while processing query. Check logs for "
+                    "further info.</b>"
+                )
+
+                if isinstance(message, Message):
+                    await (message.edit if message.out else message.respond)(msg)
+                else:
+                    await self._client.send_message(message, msg)
+
+                return False
+
+            return await self.gallery(
+                caption=caption,
+                message=message,
+                next_handler=next_handler,
+                force_me=force_me,
+                always_allow=always_allow,
+                ttl=ttl,
+                on_unload=on_unload,
+                preload=preload,
+                _reattempt=True,
+            )
+
+        self._galleries[gallery_uid]["chat"] = utils.get_chat_id(m)
+        self._galleries[gallery_uid]["message_id"] = m.id
+
+        if isinstance(message, Message):
+            await message.delete()
+
+        asyncio.ensure_future(self._load_gallery_photos(gallery_uid))
+
+        return gallery_uid
+
+    async def query_gallery(
+        self,
+        query: InlineQuery,
+        items: List[dict],
+        *,
+        force_me: bool = True,
+        always_allow: Union[list, None] = None,
+    ) -> None:
+        """
+        query
+                `InlineQuery` which should be answered with inline gallery
+        items
+                Array of dicts with inline results.
+                Each dict *must* has a:
+                    - `title` - The title of the result
+                    - `description` - Short description of the result
+                    - `next_handler` - Inline gallery handler. Callback or awaitable
+                Each dict *could* has a:
+                    - `caption` - Caption of photo. Defaults to `""`
+        force_me
+                Either this gallery buttons must be pressed only by owner scope or no
+        always_allow
+                Users, that are allowed to press buttons in addition to previous rules
+        """
+        if not isinstance(force_me, bool):
+            logger.error("Invalid type for `force_me`")
+            return False
+
+        if always_allow and not isinstance(always_allow, list):
+            logger.error("Invalid type for `always_allow`")
+            return False
+
+        if not always_allow:
+            always_allow = []
+
+        if (
+            not isinstance(items, list)
+            or not all(isinstance(i, dict) for i in items)
+            or not all(
+                "title" in i
+                and "description" in i
+                and "next_handler" in i
+                and (
+                    callable(i["next_handler"])
+                    or asyncio.iscoroutinefunction(i)
+                    or isinstance(i, list)
+                )
+                and isinstance(i["title"], str)
+                and isinstance(i["description"], str)
+                for i in items
+            )
+        ):
+            logger.error("Invalid `items` specified in query gallery")
+            return False
+
+        result = []
+        for i in items:
+            if "thumb_handler" not in i:
+                photo_url = await self._call_photo(i["next_handler"])
+                if not photo_url:
+                    return False
+
+                if isinstance(photo_url, list):
+                    photo_url = photo_url[0]
+
+                if not isinstance(photo_url, str):
+                    logger.error("Invalid result from `next_handler`")
+                    continue
+            else:
+                photo_url = await self._call_photo(i["thumb_handler"])
+                if not photo_url:
+                    return False
+
+                if isinstance(photo_url, list):
+                    photo_url = photo_url[0]
+
+                if not isinstance(photo_url, str):
+                    logger.error("Invalid result from `thumb_handler`")
+                    continue
+
+            id_ = utils.rand(16)
+
+            self._custom_map[id_] = {
+                "handler": i["next_handler"],
+                "ttl": round(time.time()) + 120,
+                **({"always_allow": always_allow} if always_allow else {}),
+                **({"force_me": force_me} if force_me else {}),
+                **({"caption": i["caption"]} if "caption" in i else {}),
+            }
+
+            result += [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title=i["title"],
+                    description=i["description"],
+                    input_message_content=InputTextMessageContent(
+                        f"üë©‚Äçüé§ <b>Loading Hikka gallery...</b>\n<i>#id: {id_}</i>",
+                        "HTML",
+                        disable_web_page_preview=True,
+                    ),
+                    thumb_url=photo_url,
+                    thumb_width=128,
+                    thumb_height=128,
+                )
+            ]
+
+        await query.answer(result, cache_time=0)
+
+    async def _call_photo(self, callback: FunctionType) -> Union[str, bool]:
+        """Parses photo url from `callback`. Returns url on success, otherwise `False`"""
+        if asyncio.iscoroutinefunction(callback):
+            photo_url = await callback()
+        elif getattr(callback, "__call__", False):
+            photo_url = callback()
+        elif isinstance(callback, str):
+            photo_url = callback
+        elif isinstance(callback, list):
+            photo_url = callback[0]
+        else:
+            logger.error("Invalid type for `next_handler`")
+            return False
+
+        if not isinstance(photo_url, (str, list)):
+            logger.error("Got invalid result from `next_handler`")
+            return False
+
+        return photo_url
+
+    async def _load_gallery_photos(self, gallery_uid: str) -> None:
+        """Preloads photo. Should be called via ensure_future"""
+        photo_url = await self._call_photo(self._galleries[gallery_uid]["next_handler"])
+
+        self._galleries[gallery_uid]["photos"] += (
+            [photo_url] if isinstance(photo_url, str) else photo_url
+        )
+
+        # If only one preload was insufficient to load needed amount of photos
+        if self._galleries[gallery_uid].get("preload", False) and len(
+            self._galleries[gallery_uid]["photos"]
+        ) - self._galleries[gallery_uid]["current_index"] < self._galleries[
+            gallery_uid
+        ].get(
+            "preload", False
+        ):
+            # Start load again
+            asyncio.ensure_future(self._load_gallery_photos(gallery_uid))
+
+    async def _gallery_slideshow(
+        self,
+        call: CallbackQuery,
+        btn_call_data: List[str] = None,
+        gallery_uid: str = None,
+        _recall: bool = False,
+    ):
+        if not _recall:
+            if not self._galleries[gallery_uid].get("slideshow", False):
+                self._galleries[gallery_uid]["slideshow"] = True
+                await self.bot.edit_message_reply_markup(
+                    inline_message_id=call.inline_message_id,
+                    reply_markup=self._gallery_markup(gallery_uid),
+                )
+                await call.answer("‚úÖ Slideshow on")
+            else:
+                del self._galleries[gallery_uid]["slideshow"]
+                await self.bot.edit_message_reply_markup(
+                    inline_message_id=call.inline_message_id,
+                    reply_markup=self._gallery_markup(gallery_uid),
+                )
+                await call.answer("üö´ Slideshow off")
+                return
+
+        await self._custom_map[btn_call_data["next"]]["handler"](
+            call,
+            *self._custom_map[btn_call_data["next"]].get("args", []),
+            **self._custom_map[btn_call_data["next"]].get("kwargs", {}),
+        )
+
+        await asyncio.sleep(7)
+
+        if self._galleries[gallery_uid].get("slideshow", False):
+            asyncio.ensure_future(
+                self._gallery_slideshow(
+                    call,
+                    btn_call_data,
+                    gallery_uid,
+                    True,
+                )
+            )
+
+    async def _gallery_back(
+        self,
+        call: CallbackQuery,
+        btn_call_data: List[str] = None,
+        gallery_uid: str = None,
+    ) -> None:
+        queue = self._galleries[gallery_uid]["photos"]
+
+        if not queue:
+            await call.answer("No way back", show_alert=True)
+            return
+
+        self._galleries[gallery_uid]["current_index"] -= 1
+
+        if self._galleries[gallery_uid]["current_index"] < 0:
+            self._galleries[gallery_uid]["current_index"] = 0
+            await call.answer("No way back")
+            return
+
+        try:
+            await self.bot.edit_message_media(
+                inline_message_id=call.inline_message_id,
+                media=self._get_current_media(gallery_uid),
+                reply_markup=self._gallery_markup(gallery_uid),
+            )
+        except RetryAfter as e:
+            await call.answer(
+                f"Got FloodWait. Wait for {e.timeout} seconds",
+                show_alert=True,
+            )
+        except Exception:
+            logger.exception("Exception while trying to edit media")
+            await call.answer("Error occurred", show_alert=True)
+            return
+
+    def _get_current_media(
+        self,
+        gallery_uid: str,
+    ) -> Union[InputMediaPhoto, InputMediaAnimation]:
+        """Return current media, which should be updated in gallery"""
+        return (
+            InputMediaPhoto(
+                media=self._get_next_photo(gallery_uid),
+                caption=self._get_caption(gallery_uid),
+                parse_mode="HTML",
+            )
+            if not self._galleries[gallery_uid].get("gif", False)
+            else InputMediaAnimation(
+                media=self._get_next_photo(gallery_uid),
+                caption=self._get_caption(gallery_uid),
+                parse_mode="HTML",
+            )
+        )
+
+    async def _gallery_close(
+        self,
+        call: CallbackQuery,
+        btn_call_data: List[str] = None,
+        gallery_uid: str = None,
+    ) -> bool:
+        try:
+            await self._client.delete_messages(
+                self._galleries[gallery_uid]["chat"],
+                [self._galleries[gallery_uid]["message_id"]],
+            )
+
+            if callable(self._galleries[gallery_uid]["on_unload"]):
+                self._galleries[gallery_uid]["on_unload"]()
+
+            del self._galleries[gallery_uid]
+        except Exception:
+            return False
+
+        return True
+
+    async def _gallery_next(
+        self,
+        call: CallbackQuery,
+        btn_call_data: List[str] = None,
+        func: FunctionType = None,
+        gallery_uid: str = None,
+    ) -> None:
+        self._galleries[gallery_uid]["current_index"] += 1
+        # If we exceeded photos limit in gallery and need to preload more
+        if self._galleries[gallery_uid]["current_index"] >= len(
+            self._galleries[gallery_uid]["photos"]
+        ):
+            await self._load_gallery_photos(gallery_uid)
+
+        # If we still didn't get needed photo index
+        if self._galleries[gallery_uid]["current_index"] >= len(
+            self._galleries[gallery_uid]["photos"]
+        ):
+            await call.answer("Can't load next photo")
+            return
+
+        if self._galleries[gallery_uid].get("preload", False) and len(
+            self._galleries[gallery_uid]["photos"]
+        ) - self._galleries[gallery_uid]["current_index"] < self._galleries[
+            gallery_uid
+        ].get(
+            "preload", False
+        ):
+            logger.debug(f"Started preload for gallery {gallery_uid}")
+            asyncio.ensure_future(self._load_gallery_photos(gallery_uid))
+
+        try:
+            await self.bot.edit_message_media(
+                inline_message_id=call.inline_message_id,
+                media=self._get_current_media(gallery_uid),
+                reply_markup=self._gallery_markup(gallery_uid),
+            )
+        except (InvalidHTTPUrlContent, BadRequest):
+            logger.debug("Error fetching photo content, attempting load next one")
+            del self._galleries[gallery_uid]["photos"][
+                self._galleries[gallery_uid]["current_index"]
+            ]
+            self._galleries[gallery_uid]["current_index"] -= 1
+            return await self._gallery_next(call, btn_call_data, func, gallery_uid)
+        except RetryAfter as e:
+            await call.answer(
+                f"Got FloodWait. Wait for {e.timeout} seconds",
+                show_alert=True,
+            )
+            return
+        except Exception:
+            logger.exception("Exception while trying to edit media")
+            await call.answer("Error occurred", show_alert=True)
+            return
+
+    def _get_next_photo(self, gallery_uid: str) -> str:
+        """Returns next photo"""
+        try:
+            return self._galleries[gallery_uid]["photos"][
+                self._galleries[gallery_uid]["current_index"]
+            ]
+        except IndexError:
+            logger.error(
+                "Got IndexError in `_get_next_photo`. "
+                f"{self._galleries[gallery_uid]['current_index']=} / "
+                f"{len(self._galleries[gallery_uid]['photos'])=}"
+            )
+            return self._galleries[gallery_uid]["photos"][0]
+
+    def _get_caption(self, gallery_uid: str) -> str:
+        """Calls and returnes caption for gallery"""
+        return (
+            self._galleries[gallery_uid]["caption"]
+            if isinstance(self._galleries[gallery_uid]["caption"], str)
+            or not callable(self._galleries[gallery_uid]["caption"])
+            else self._galleries[gallery_uid]["caption"]()
+        )
+
+    def _gallery_markup(self, gallery_uid: str) -> InlineKeyboardMarkup:
+        """Converts `btn_call_data` into a aiogram markup"""
+        markup = InlineKeyboardMarkup()
+        markup.add(
+            InlineKeyboardButton(
+                "‚è™",
+                callback_data=self._galleries[gallery_uid]["btn_call_data"]["back"],
+            ),
+            InlineKeyboardButton(
+                "‚ñ∂Ô∏è"
+                if not self._galleries[gallery_uid].get("slideshow", False)
+                else "‚è∏",
+                callback_data=self._galleries[gallery_uid]["btn_call_data"]["show"],
+            ),
+            InlineKeyboardButton(
+                "‚è©",
+                callback_data=self._galleries[gallery_uid]["btn_call_data"]["next"],
+            ),
+        )
+
+        markup.add(
+            InlineKeyboardButton(
+                "‚ùå Close",
+                callback_data=self._galleries[gallery_uid]["btn_call_data"]["close"],
+            ),
+        )
+
+        return markup
+
+    async def _gallery_inline_handler(self, inline_query: InlineQuery) -> None:
+        for gallery in self._galleries.copy().values():
+            if (
+                inline_query.from_user.id
+                in [self._me]
+                + self._client.dispatcher.security._owner
+                + gallery.get("always_allow", [])
+                and inline_query.query == gallery["uid"]
+            ):
+                if not gallery.get("gif", False):
+                    await inline_query.answer(
+                        [
+                            InlineQueryResultPhoto(
+                                id=utils.rand(20),
+                                title="Processing inline gallery",
+                                photo_url=gallery["photo_url"],
+                                thumb_url="https://img.icons8.com/fluency/344/loading.png",
+                                caption=self._get_caption(gallery["uid"]),
+                                description="Processing inline gallery",
+                                reply_markup=self._gallery_markup(
+                                    gallery["uid"],
+                                ),
+                                parse_mode="HTML",
+                            )
+                        ],
+                        cache_time=0,
+                    )
+                    return
+
+                await inline_query.answer(
+                    [
+                        InlineQueryResultGif(
+                            id=utils.rand(20),
+                            title="Processing inline gallery",
+                            gif_url=gallery["photo_url"],
+                            thumb_url="https://img.icons8.com/fluency/344/loading.png",
+                            caption=self._get_caption(gallery["uid"]),
+                            parse_mode="HTML",
+                            reply_markup=self._gallery_markup(
+                                gallery["uid"],
+                            ),
+                        )
+                    ]
+                )
diff --git a/hikka/inline/token_obtainment.py b/hikka/inline/token_obtainment.py
new file mode 100644
index 0000000..9fae9f7
--- /dev/null
+++ b/hikka/inline/token_obtainment.py
@@ -0,0 +1,218 @@
+from .types import InlineUnit
+import logging
+import re
+from .. import utils
+import io
+import requests
+from telethon.errors.rpcerrorlist import YouBlockedUserError
+from telethon.tl.functions.contacts import UnblockRequest
+import asyncio
+
+logger = logging.getLogger(__name__)
+
+photo = io.BytesIO(
+    requests.get(
+        "https://github.com/hikariatama/Hikka/raw/master/assets/bot_pfp.png"
+    ).content
+)
+photo.name = "avatar.png"
+
+
+class TokenObtainment(InlineUnit):
+    async def _create_bot(self) -> None:
+        # This is called outside of conversation, so we can start the new one
+        # We create new bot
+        logger.info("User don't have bot, attempting creating new one")
+        async with self._client.conversation("@BotFather", exclusive=False) as conv:
+            m = await conv.send_message("/newbot")
+            r = await conv.get_response()
+
+            if "20" in r.raw_text:
+                return False
+
+            await m.delete()
+            await r.delete()
+
+            # Generate and set random username for bot
+            uid = utils.rand(6)
+            username = f"hikka_{uid}_bot"
+
+            for msg in [
+                f"üë©‚Äçüé§ Hikka Userbot of {self._name}",
+                username,
+                "/setuserpic",
+                username,
+            ]:
+                m = await conv.send_message(msg)
+                r = await conv.get_response()
+
+                logger.debug(f">> {m.raw_text}")
+                logger.debug(f"<< {r.raw_text}")
+
+                await m.delete()
+                await r.delete()
+
+            try:
+                m = await conv.send_file(photo)
+                r = await conv.get_response()
+
+                logger.debug(">> <Photo>")
+                logger.debug(f"<< {r.raw_text}")
+            except Exception:
+                # In case user was not able to send photo to
+                # BotFather, it is not a critical issue, so
+                # just ignore it
+                m = await conv.send_message("/cancel")
+                r = await conv.get_response()
+
+                logger.debug(f">> {m.raw_text}")
+                logger.debug(f"<< {r.raw_text}")
+
+            await m.delete()
+            await r.delete()
+
+        # Re-attempt search. If it won't find newly created (or not created?) bot
+        # it will return `False`, that's why `init_complete` will be `False`
+        return await self._assert_token(False)
+
+    async def _assert_token(
+        self,
+        create_new_if_needed=True,
+        revoke_token=False,
+    ) -> None:
+        # If the token is set in db
+        if self._token:
+            # Just return `True`
+            return True
+
+        logger.info("Bot token not found in db, attempting search in BotFather")
+        # Start conversation with BotFather to attempt search
+        async with self._client.conversation("@BotFather", exclusive=False) as conv:
+            # Wrap it in try-except in case user banned BotFather
+            try:
+                # Try sending command
+                m = await conv.send_message("/token")
+            except YouBlockedUserError:
+                # If user banned BotFather, unban him
+                await self._client(UnblockRequest(id="@BotFather"))
+                # And resend message
+                m = await conv.send_message("/token")
+
+            r = await conv.get_response()
+
+            logger.debug(f">> {m.raw_text}")
+            logger.debug(f"<< {r.raw_text}")
+
+            await m.delete()
+            await r.delete()
+
+            # User do not have any bots yet, so just create new one
+            if not hasattr(r, "reply_markup") or not hasattr(r.reply_markup, "rows"):
+                # Cancel current conversation (search)
+                # bc we don't need it anymore
+                await conv.cancel_all()
+
+                return await self._create_bot() if create_new_if_needed else False
+
+            for row in r.reply_markup.rows:
+                for button in row.buttons:
+                    if re.search(r"@hikka_[0-9a-zA-Z]{6}_bot", button.text):
+                        m = await conv.send_message(button.text)
+                        r = await conv.get_response()
+
+                        logger.debug(f">> {m.raw_text}")
+                        logger.debug(f"<< {r.raw_text}")
+
+                        if revoke_token:
+                            await m.delete()
+                            await r.delete()
+
+                            m = await conv.send_message("/revoke")
+                            r = await conv.get_response()
+
+                            logger.debug(f">> {m.raw_text}")
+                            logger.debug(f"<< {r.raw_text}")
+
+                            await m.delete()
+                            await r.delete()
+
+                            m = await conv.send_message(button.text)
+                            r = await conv.get_response()
+
+                            logger.debug(f">> {m.raw_text}")
+                            logger.debug(f"<< {r.raw_text}")
+
+                        token = r.raw_text.splitlines()[1]
+
+                        # Save token to database, now this bot is ready-to-use
+                        self._db.set("hikka.inline", "bot_token", token)
+                        self._token = token
+
+                        await m.delete()
+                        await r.delete()
+
+                        # Enable inline mode or change its
+                        # placeholder in case it is not set
+
+                        for msg in [
+                            "/setinline",
+                            button.text,
+                            "HikkaQuery",
+                            "/setinlinefeedback",
+                            button.text,
+                            "Enabled",
+                            "/setuserpic",
+                            button.text,
+                        ]:
+                            m = await conv.send_message(msg)
+                            r = await conv.get_response()
+
+                            logger.debug(f">> {m.raw_text}")
+                            logger.debug(f"<< {r.raw_text}")
+
+                            await m.delete()
+                            await r.delete()
+
+                        try:
+                            m = await conv.send_file(photo)
+                            r = await conv.get_response()
+
+                            logger.debug(">> <Photo>")
+                            logger.debug(f"<< {r.raw_text}")
+                        except Exception:
+                            # In case user was not able to send photo to
+                            # BotFather, it is not a critical issue, so
+                            # just ignore it
+                            m = await conv.send_message("/cancel")
+                            r = await conv.get_response()
+
+                            logger.debug(f">> {m.raw_text}")
+                            logger.debug(f"<< {r.raw_text}")
+
+                        await m.delete()
+                        await r.delete()
+
+                        # Return `True` to say, that everything is okay
+                        return True
+
+        # And we are not returned after creation
+        return await self._create_bot() if create_new_if_needed else False
+
+    async def _reassert_token(self) -> None:
+        is_token_asserted = await self._assert_token(revoke_token=True)
+        if not is_token_asserted:
+            self.init_complete = False
+        else:
+            await self._register_manager(ignore_token_checks=True)
+
+    async def _dp_revoke_token(self, already_initialised: bool = True) -> None:
+        if already_initialised:
+            await self._stop()
+            logger.error("Got polling conflict. Attempting token revocation...")
+
+        self._db.set("hikka.inline", "bot_token", None)
+        self._token = None
+        if already_initialised:
+            asyncio.ensure_future(self._reassert_token())
+        else:
+            return await self._reassert_token()
diff --git a/hikka/inline/types.py b/hikka/inline/types.py
new file mode 100644
index 0000000..8dbf3d0
--- /dev/null
+++ b/hikka/inline/types.py
@@ -0,0 +1,155 @@
+from aiogram.types import (
+    Message as AiogramMessage,
+    InlineQuery as AiogramInlineQuery,
+    InlineQueryResultArticle,
+    InputTextMessageContent,
+)
+
+from .. import utils
+
+
+class InlineCall:
+    """Modified version of original Aiogram CallbackQuery"""
+
+    def __init__(self):
+        self.delete = None
+        self.unload = None
+        self.edit = None
+        super().__init__()
+
+
+class InlineUnit:
+    """InlineManager extension type. For internal use only"""
+
+    def __init__(self):
+        """Made just for type specification"""
+
+
+class BotMessage(AiogramMessage):
+    """Modified version of original Aiogram Message"""
+
+    def __init__(self):
+        super().__init__()
+
+
+class InlineQuery:
+    """Modified version of original Aiogram InlineQuery"""
+
+    def __init__(self, inline_query: AiogramInlineQuery) -> None:
+        self.inline_query = inline_query
+
+        # Inherit original `InlineQuery` attributes for
+        # easy access
+        for attr in dir(inline_query):
+            if attr.startswith("__") and attr.endswith("__"):
+                continue  # Ignore magic attrs
+
+            if hasattr(self, attr):
+                continue  # Do not override anything
+
+            try:
+                setattr(self, attr, getattr(inline_query, attr))
+            except AttributeError:
+                pass  # There are some non-writable native attrs
+                # So just ignore them
+
+        self.args = (
+            self.inline_query.query.split(maxsplit=1)[1]
+            if len(self.inline_query.query.split()) > 1
+            else ""
+        )
+
+    async def e400(self) -> None:
+        await self.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="üö´ 400",
+                    description="Bad request. You need to pass right arguments, follow module's documentation",
+                    input_message_content=InputTextMessageContent(
+                        "üò∂‚Äçüå´Ô∏è <i>There is nothing here...</i>",
+                        parse_mode="HTML",
+                    ),
+                    thumb_url="https://img.icons8.com/color/344/swearing-male--v1.png",
+                    thumb_width=128,
+                    thumb_height=128,
+                )
+            ],
+            cache_time=0,
+        )
+
+    async def e403(self) -> None:
+        await self.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="üö´ 403",
+                    description="You have no permissions to access this result",
+                    input_message_content=InputTextMessageContent(
+                        "üò∂‚Äçüå´Ô∏è <i>There is nothing here...</i>",
+                        parse_mode="HTML",
+                    ),
+                    thumb_url="https://img.icons8.com/external-wanicon-flat-wanicon/344/external-forbidden-new-normal-wanicon-flat-wanicon.png",
+                    thumb_width=128,
+                    thumb_height=128,
+                )
+            ],
+            cache_time=0,
+        )
+
+    async def e404(self) -> None:
+        await self.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="üö´ 404",
+                    description="No results found",
+                    input_message_content=InputTextMessageContent(
+                        "üò∂‚Äçüå´Ô∏è <i>There is nothing here...</i>",
+                        parse_mode="HTML",
+                    ),
+                    thumb_url="https://img.icons8.com/external-justicon-flat-justicon/344/external-404-error-responsive-web-design-justicon-flat-justicon.png",
+                    thumb_width=128,
+                    thumb_height=128,
+                )
+            ],
+            cache_time=0,
+        )
+
+    async def e426(self) -> None:
+        await self.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="üö´ 426",
+                    description="You need to update Hikka before sending this request",
+                    input_message_content=InputTextMessageContent(
+                        "üò∂‚Äçüå´Ô∏è <i>There is nothing here...</i>",
+                        parse_mode="HTML",
+                    ),
+                    thumb_url="https://img.icons8.com/fluency/344/approve-and-update.png",
+                    thumb_width=128,
+                    thumb_height=128,
+                )
+            ],
+            cache_time=0,
+        )
+
+    async def e500(self) -> None:
+        await self.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="üö´ 500",
+                    description="Internal userbot error while processing request. More info in logs",
+                    input_message_content=InputTextMessageContent(
+                        "üò∂‚Äçüå´Ô∏è <i>There is nothing here...</i>",
+                        parse_mode="HTML",
+                    ),
+                    thumb_url="https://img.icons8.com/external-vitaliy-gorbachev-flat-vitaly-gorbachev/344/external-error-internet-security-vitaliy-gorbachev-flat-vitaly-gorbachev.png",
+                    thumb_width=128,
+                    thumb_height=128,
+                )
+            ],
+            cache_time=0,
+        )
diff --git a/friendly-telegram/loader.py b/hikka/loader.py
similarity index 74%
rename from friendly-telegram/loader.py
rename to hikka/loader.py
index de7a50c..1476a11 100755
--- a/friendly-telegram/loader.py
+++ b/hikka/loader.py
@@ -1,5 +1,7 @@
+"""Registers modules"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,9 +16,15 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
-"""Loads modules from disk and dispatches stuff, and stores state"""
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import asyncio
 import functools
@@ -26,28 +34,12 @@ import inspect
 import logging
 import os
 import sys
-import json
 
-from . import utils, security, inline
+from . import utils, security
 from .translations.dynamic import Strings
-
-
-class LoadError(Exception):
-    def __init__(self, error_message):  # skipcq: PYL-W0231
-        self._error = error_message
-
-    def __str__(self) -> str:
-        return self._error
-
-
-def use_fs_for_modules():
-    try:
-        with open("config.json", "r") as f:
-            config = json.loads(f.read())
-    except Exception:
-        return False
-
-    return config.get("use_fs_for_modules", False)
+from .inline.core import InlineManager
+from .types import Module, LoadError, ModuleConfig  # noqa: F401
+from importlib.machinery import ModuleSpec
 
 
 def test(*args, **kwargs):
@@ -70,10 +62,8 @@ pm = security.pm
 unrestricted = security.unrestricted
 
 MODULES_NAME = "modules"
-ru_keys = """—ë–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é.–Å"‚Ññ;%:?–ô–¶–£–ö–ï–ù–ì
-        –®–©–ó–•–™–§–´–í–ê–ü–†–û–õ–î–ñ–≠/–Ø–ß–°–ú–ò–¢–¨–ë–Æ, """
-en_keys = """`qwertyuiop[]asdfghjkl;'zxcvbnm,./~@#$%^&QWERTYUIOP{
-        }ASDFGHJKL:"|ZXCVBNM<>? """
+ru_keys = '—ë–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é.–Å"‚Ññ;%:?–ô–¶–£–ö–ï–ù–ì–®–©–ó–•–™–§–´–í–ê–ü–†–û–õ–î–ñ–≠/–Ø–ß–°–ú–ò–¢–¨–ë–Æ,'
+en_keys = "`qwertyuiop[]asdfghjkl;'zxcvbnm,./~@#$%^&QWERTYUIOP{}ASDFGHJKL:\"|ZXCVBNM<>?"
 
 
 LOADED_MODULES_DIR = os.path.join(utils.get_base_dir(), "loaded_modules")
@@ -115,63 +105,6 @@ def ratelimit(func):
     return func
 
 
-class ModuleConfig(dict):
-    """Like a dict but contains doc for each key"""
-
-    def __init__(self, *entries):
-        keys = []
-        values = []
-        defaults = []
-        docstrings = []
-        for i, entry in enumerate(entries):
-            if i % 3 == 0:
-                keys.append(entry)
-            elif i % 3 == 1:
-                values.append(entry)
-                defaults.append(entry)
-            else:
-                docstrings.append(entry)
-
-        super().__init__(zip(keys, values))
-        self._docstrings = dict(zip(keys, docstrings))
-        self._defaults = dict(zip(keys, defaults))
-
-    def getdoc(self, key, message=None):
-        """Get the documentation by key"""
-        ret = self._docstrings[key]
-        if callable(ret):
-            try:
-                ret = ret(message)
-            except TypeError:  # Invalid number of params
-                logging.debug("%s using legacy doc trnsl", key)
-                ret = ret()
-
-        return ret
-
-    def getdef(self, key):
-        """Get the default value by key"""
-        return self._defaults[key]
-
-
-class Module:
-    strings = {"name": "Unknown"}
-
-    """There is no help for this module"""
-
-    def config_complete(self):
-        """Will be called when module.config is populated"""
-
-    async def client_ready(self, client, db):
-        """Will be called after client is ready (after config_loaded)"""
-
-    async def on_unload(self):
-        """Will be called after unloading / reloading module"""
-
-    # Called after client_ready, for internal use only. Must not be used by non-core modules
-    async def _client_ready2(self, client, db):
-        pass
-
-
 def get_commands(mod):
     """Introspect the module to get its commands"""
     # https://stackoverflow.com/a/34452/5509575
@@ -209,24 +142,21 @@ def get_callback_handlers(mod):
 class Modules:
     """Stores all registered modules"""
 
-    def __init__(self, use_inline=True):
+    def __init__(self):
         self.commands = {}
         self.aliases = {}
         self.modules = []  # skipcq: PTC-W0052
         self.watchers = []
-        self._compat_layer = None
         self._log_handlers = []
+        self._compat_layer = None
         self.client = None
         self._initial_registration = True
         self.added_modules = None
-        self.use_inline = use_inline
-        self._fs = "DYNO" not in os.environ
 
-    def register_all(self, babelfish, mods=None):  # skipcq: PYL-W0613
-        # TODO: remove babelfish
+    def register_all(self, db, mods=None):
         """Load all modules in the module directory"""
         if self._compat_layer is None:
-            from . import compat  # Avoid circular import
+            from . import compat  # noqa
 
             self._compat_layer = compat.activate([])
 
@@ -234,19 +164,27 @@ class Modules:
             mods = [
                 os.path.join(utils.get_base_dir(), MODULES_NAME, mod)
                 for mod in filter(
-                    lambda x: (len(x) > 3 and x[-3:] == ".py" and x[0] != "_"),
+                    lambda x: (
+                        len(x) > 3
+                        and x[-3:] == ".py"
+                        and x[0] != "_"
+                        and ("OKTETO" in os.environ or x != "okteto.py")
+                        and (
+                            not db.get("hikka", "disable_quickstart", False)
+                            or x != "quickstart.py"
+                        )
+                    ),
                     os.listdir(os.path.join(utils.get_base_dir(), MODULES_NAME)),
                 )
             ]
 
-            if self._fs and use_fs_for_modules():
-                mods += [
-                    os.path.join(LOADED_MODULES_DIR, mod)
-                    for mod in filter(
-                        lambda x: (len(x) > 3 and x[-3:] == ".py" and x[0] != "_"),
-                        os.listdir(LOADED_MODULES_DIR),
-                    )
-                ]
+            mods += [
+                os.path.join(LOADED_MODULES_DIR, mod)
+                for mod in filter(
+                    lambda x: (len(x) > 3 and x[-3:] == ".py" and x[0] != "_"),
+                    os.listdir(LOADED_MODULES_DIR),
+                )
+            ]
 
         logging.debug(mods)
 
@@ -261,14 +199,18 @@ class Modules:
             except BaseException as e:
                 logging.exception(f"Failed to load module %s due to {e}:", mod)
 
-    def register_module(self, spec, module_name, origin="<file>"):
+    def register_module(
+        self,
+        spec: ModuleSpec,
+        module_name: str,
+        origin: str = "<core>",
+        save_fs: bool = False,
+    ) -> Module:
         """Register single module from importlib spec"""
         from .compat import uniborg
 
         module = importlib.util.module_from_spec(spec)
-        sys.modules[
-            module_name
-        ] = module  # Do this early for the benefit of RaphielGang compat layer
+        sys.modules[module_name] = module
         module.borg = uniborg.UniborgClient(module_name)
         spec.loader.exec_module(module)
         ret = None
@@ -277,7 +219,7 @@ class Modules:
             if key.endswith("Mod") and issubclass(value, Module):
                 ret = value()
 
-        if hasattr(module, '__version__'):
+        if hasattr(module, "__version__"):
             ret.__version__ = module.__version__
 
         if ret is None:
@@ -290,7 +232,7 @@ class Modules:
 
         cls_name = ret.__class__.__name__
 
-        if self._fs and use_fs_for_modules():
+        if save_fs:
             path = os.path.join(LOADED_MODULES_DIR, f"{cls_name}.py")
 
             if not os.path.isfile(path) and origin == "<string>":
@@ -301,7 +243,7 @@ class Modules:
 
         return ret
 
-    def register_commands(self, instance):
+    def register_commands(self, instance: Module) -> None:
         """Register commands from instance"""
         for command in instance.commands.copy():
             # Verify that command does not already exist, or,
@@ -322,7 +264,7 @@ class Modules:
 
             self.commands.update({command.lower(): instance.commands[command]})
 
-    def register_watcher(self, instance):
+    def register_watcher(self, instance: Module) -> None:
         """Register watcher from instance"""
         try:
             if instance.watcher:
@@ -338,22 +280,26 @@ class Modules:
         except AttributeError:
             pass
 
-    def complete_registration(self, instance):
+    def complete_registration(self, instance: Module) -> None:
         """Complete registration of instance"""
         instance.allmodules = self
-        instance.geektg = True
-        instance.log = self.log  # Like botlog from PP
+        instance.hikka = True
         for module in self.modules:
             if module.__class__.__name__ == instance.__class__.__name__:
                 logging.debug("Removing module for update %r", module)
                 self.modules.remove(module)
                 asyncio.ensure_future(
-                    asyncio.wait_for(asyncio.gather(module.on_unload()), timeout=5)
+                    asyncio.wait_for(
+                        asyncio.gather(
+                            module.on_unload(),
+                        ),
+                        timeout=5,
+                    )
                 )
 
         self.modules += [instance]
 
-    def dispatch(self, command):
+    def dispatch(self, command: str) -> tuple:
         """Dispatch command to appropriate module"""
         change = str.maketrans(ru_keys + en_keys, en_keys + ru_keys)
         try:
@@ -373,13 +319,13 @@ class Modules:
                     except KeyError:
                         return command, None
 
-    def send_config(self, db, babel, skip_hook=False):
+    def send_config(self, db, babel, skip_hook: bool = False) -> None:
         """Configure modules"""
         for mod in self.modules:
             self.send_config_one(mod, db, babel, skip_hook)
 
     @staticmethod
-    def send_config_one(mod, db, babel=None, skip_hook=False):
+    def send_config_one(mod, db, babel=None, skip_hook: bool = False) -> None:
         """Send config to single instance"""
         if hasattr(mod, "config"):
             modcfg = db.get(mod.__module__, "__config__", {})
@@ -413,13 +359,11 @@ class Modules:
         """Send all data to all modules"""
         self.client = client
 
-        # Register inline manager anyway, so the modules
+        # Init inline manager anyway, so the modules
         # can access its `init_complete`
-        inline_manager = inline.InlineManager(client, db, self)
+        inline_manager = InlineManager(client, db, self)
 
-        # Register only if it is not disabled
-        if self.use_inline:
-            await inline_manager._register_manager()
+        await inline_manager._register_manager()
 
         # We save it to `Modules` attribute, so not to re-init
         # it everytime module is loaded. Then we can just
@@ -437,7 +381,7 @@ class Modules:
             )
             await asyncio.gather(
                 *[mod._client_ready2(client, db) for mod in self.modules]
-            )  # pylint: disable=W0212
+            )
         except Exception as e:
             logging.exception(f"Failed to send mod init complete signal due to {e}")
 
@@ -451,10 +395,7 @@ class Modules:
         try:
             await mod.client_ready(client, db)
         except Exception as e:
-            logging.exception(
-                f"Failed to send mod init complete signal for %r due to {e}, attempting unload",
-                mod,
-            )
+            logging.exception(f"Failed to send mod init complete signal for {mod} due to {e}, attempting unload")  # fmt: skip
             self.modules.remove(mod)
             raise
 
@@ -472,7 +413,7 @@ class Modules:
         if not self._initial_registration and self.added_modules:
             await self.added_modules(self)
 
-    def get_classname(self, name):
+    def get_classname(self, name: str) -> str:
         return next(
             (
                 module.__class__.__module__
@@ -482,7 +423,7 @@ class Modules:
             name,
         )
 
-    def unload_module(self, classname):
+    def unload_module(self, classname: str) -> bool:
         """Remove module and all stuff from it"""
         worked = []
         to_remove = []
@@ -492,18 +433,22 @@ class Modules:
                 worked += [module.__module__]
 
                 name = module.__class__.__name__
-                if self._fs and use_fs_for_modules():
-                    path = os.path.join(LOADED_MODULES_DIR, f"{name}.py")
+                path = os.path.join(LOADED_MODULES_DIR, f"{name}.py")
 
-                    if os.path.isfile(path):
-                        os.remove(path)
-                        logging.debug(f"Removed {name} file")
+                if os.path.isfile(path):
+                    os.remove(path)
+                    logging.debug(f"Removed {name} file")
 
                 logging.debug("Removing module for unload %r", module)
                 self.modules.remove(module)
 
                 asyncio.ensure_future(
-                    asyncio.wait_for(asyncio.gather(module.on_unload()), timeout=5)
+                    asyncio.wait_for(
+                        asyncio.gather(
+                            module.on_unload(),
+                        ),
+                        timeout=5,
+                    )
                 )
 
                 to_remove += module.commands.values()
diff --git a/friendly-telegram/log.py b/hikka/log.py
similarity index 84%
rename from friendly-telegram/log.py
rename to hikka/log.py
index 2acffe4..c6b5048 100755
--- a/friendly-telegram/log.py
+++ b/hikka/log.py
@@ -1,5 +1,7 @@
+"""Main logging part"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,7 +16,17 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+# TODO: Replace with native bot logging, if inline is enabled
 
 import logging
 
diff --git a/hikka/main.py b/hikka/main.py
new file mode 100755
index 0000000..20d3e6d
--- /dev/null
+++ b/hikka/main.py
@@ -0,0 +1,630 @@
+"""Main script, where all the fun starts"""
+
+#    Friendly Telegram (telegram userbot)
+#    Copyright (C) 2018-2021 The Authors
+
+#    This program is free software: you can redistribute it and/or modify
+#    it under the terms of the GNU Affero General Public License as published by
+#    the Free Software Foundation, either version 3 of the License, or
+#    (at your option) any later version.
+
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU Affero General Public License for more details.
+
+#    You should have received a copy of the GNU Affero General Public License
+#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+
+import argparse
+import asyncio
+import collections
+import importlib
+import json
+import logging
+import os
+import random
+import socket
+import sqlite3
+import sys
+
+from telethon import TelegramClient, events
+from telethon.errors.rpcerrorlist import (
+    PhoneNumberInvalidError,
+    ApiIdInvalidError,
+    AuthKeyDuplicatedError,
+)
+from telethon.network.connection import ConnectionTcpFull
+from telethon.network.connection import ConnectionTcpMTProxyRandomizedIntermediate
+from telethon.sessions import SQLiteSession
+
+from . import utils, loader, database
+from .dispatcher import CommandDispatcher
+from .translations.core import Translator
+
+from math import ceil
+from .version import __version__
+
+try:
+    from .web import core
+except ImportError:
+    web_available = False
+    logging.exception("Unable to import web")
+else:
+    web_available = True
+
+
+def run_config(db, data_root, phone=None, modules=None):
+    """Load configurator.py"""
+    from . import configurator
+
+    return configurator.run(db, data_root, phone, phone is None, modules)
+
+
+def get_config_key(key):
+    """Parse and return key from config"""
+    try:
+        with open("config.json", "r") as f:
+            config = json.loads(f.read())
+
+        return config.get(key, False)
+    except FileNotFoundError:
+        return False
+
+
+def save_config_key(key, value):
+    try:
+        # Try to open our newly created json config
+        with open("config.json", "r") as f:
+            config = json.loads(f.read())
+    except FileNotFoundError:
+        # If it doesn't exist, just default config to none
+        # It won't cause problems, bc after new save
+        # we will create new one
+        config = {}
+
+    # Assign config value
+    config[key] = value
+
+    # And save config
+    with open("config.json", "w") as f:
+        f.write(json.dumps(config))
+
+    return True
+
+
+def gen_port():
+    if "OKTETO" in os.environ:
+        return 8080
+
+    # But for own server we generate new free port, and assign to it
+
+    port = get_config_key("port")
+    if port:
+        return port
+
+    # If we didn't get port from config, generate new one
+    # First, try to randomly get port
+    port = random.randint(1024, 65536)
+
+    # Then ensure it's free
+    while (
+        not socket.socket(
+            socket.AF_INET,
+            socket.SOCK_STREAM,
+        ).connect_ex(("localhost", port))
+    ):
+        # Until we find the free port, generate new one
+        port = random.randint(1024, 65536)
+
+    return port
+
+
+def parse_arguments():
+    """Parse the arguments"""
+    parser = argparse.ArgumentParser()
+    parser.add_argument("--setup", "-s", action="store_true")
+    parser.add_argument("--port", dest="port", action="store", default=gen_port(), type=int)  # fmt: skip
+    parser.add_argument("--phone", "-p", action="append")
+    parser.add_argument("--token", "-t", action="append", dest="tokens")
+    parser.add_argument("--no-nickname", "-nn", dest="no_nickname", action="store_true")
+    parser.add_argument("--hosting", "-lh", dest="hosting", action="store_true")
+    parser.add_argument("--web-only", dest="web_only", action="store_true")
+    parser.add_argument("--no-web", dest="disable_web", action="store_false")
+    parser.add_argument(
+        "--data-root",
+        dest="data_root",
+        default="",
+        help="Root path to store session files in",
+    )
+    parser.add_argument(
+        "--no-auth",
+        dest="no_auth",
+        action="store_true",
+        help="Disable authentication and API token input, exitting if needed",
+    )
+    parser.add_argument(
+        "--proxy-host",
+        dest="proxy_host",
+        action="store",
+        help="MTProto proxy host, without port",
+    )
+    parser.add_argument(
+        "--proxy-port",
+        dest="proxy_port",
+        action="store",
+        type=int,
+        help="MTProto proxy port",
+    )
+    parser.add_argument(
+        "--proxy-secret",
+        dest="proxy_secret",
+        action="store",
+        help="MTProto proxy secret",
+    )
+    parser.add_argument(
+        "--docker-deps-internal",
+        dest="docker_deps_internal",
+        action="store_true",
+        help="This is for internal use only. If you use it, things will go wrong.",
+    )
+    parser.add_argument(
+        "--root",
+        dest="disable_root_check",
+        action="store_true",
+        help="Disable `force_insecure` warning",
+    )
+    arguments = parser.parse_args()
+    logging.debug(arguments)
+    if sys.platform == "win32":
+        # Subprocess support; not needed in 3.8 but not harmful
+        asyncio.set_event_loop(asyncio.ProactorEventLoop())
+
+    return arguments
+
+
+class SuperList(list):
+    """
+    Makes able: await self.allclients.send_message("foo", "bar")
+    """
+
+    def __getattribute__(self, attr):
+        if hasattr(list, attr):
+            return list.__getattribute__(self, attr)
+
+        for obj in self:  # TODO: find other way
+            attribute = getattr(obj, attr)
+            if callable(attribute):
+                if asyncio.iscoroutinefunction(attribute):
+
+                    async def foobar(*args, **kwargs):
+                        return [await getattr(_, attr)(*args, **kwargs) for _ in self]
+
+                    return foobar
+                return lambda *args, **kwargs: [
+                    getattr(_, attr)(*args, **kwargs) for _ in self
+                ]
+
+            return [getattr(x, attr) for x in self]
+
+
+class InteractiveAuthRequired(Exception):
+    def __init__(self) -> None:
+        super().__init__()
+
+
+def raise_auth():
+    raise InteractiveAuthRequired()
+
+
+class Hikka:
+    def __init__(self):
+        self.arguments = parse_arguments()
+        self.loop = asyncio.get_event_loop()
+
+        self.clients = SuperList()
+        self._get_phones()
+        self._get_api_token()
+        self._get_proxy()
+
+    def _get_proxy(self) -> None:
+        """
+        Get proxy tuple from --proxy-host, --proxy-port and --proxy-secret
+        and connection to use (depends on proxy - provided or not)
+        """
+        if (
+            self.arguments.proxy_host is not None
+            and self.arguments.proxy_port is not None
+            and self.arguments.proxy_secret is not None
+        ):
+            logging.debug(
+                "Using proxy: %s:%s",
+                self.arguments.proxy_host,
+                self.arguments.proxy_port,
+            )
+            self.proxy, self.conn = (
+                (
+                    self.arguments.proxy_host,
+                    self.arguments.proxy_port,
+                    self.arguments.proxy_secret,
+                ),
+                ConnectionTcpMTProxyRandomizedIntermediate,
+            )
+            return
+
+        self.proxy, self.conn = None, ConnectionTcpFull
+
+    def _get_phones(self) -> None:
+        """Get phones from the --phone, and environment"""
+        phones = {
+            phone.split(":", maxsplit=1)[0]: phone
+            for phone in map(
+                lambda f: f[6:-8],
+                filter(
+                    lambda f: f.startswith("hikka-") and f.endswith(".session"),
+                    os.listdir(
+                        self.arguments.data_root
+                        or os.path.dirname(utils.get_base_dir()),
+                    ),
+                ),
+            )
+        }
+
+        phones.update(
+            **(
+                {
+                    phone.split(":", maxsplit=1)[0]: phone
+                    for phone in self.arguments.phone
+                }
+                if self.arguments.phone
+                else {}
+            )
+        )
+
+        self.phones = phones
+
+    def _get_api_token(self) -> None:
+        """Get API Token from disk or environment"""
+        api_token_type = collections.namedtuple("api_token", ("ID", "HASH"))
+
+        # Try to retrieve credintials from file, or from env vars
+        try:
+            with open(
+                os.path.join(
+                    self.arguments.data_root or os.path.dirname(utils.get_base_dir()),
+                    "api_token.txt",
+                )
+            ) as f:
+                api_token = api_token_type(*[line.strip() for line in f.readlines()])
+        except FileNotFoundError:
+            try:
+                from . import api_token
+            except ImportError:
+                try:
+                    api_token = api_token_type(
+                        os.environ["api_id"],
+                        os.environ["api_hash"],
+                    )
+                except KeyError:
+                    api_token = None
+
+        self.api_token = api_token
+
+    def _init_web(self) -> None:
+        """Initialize web"""
+        if web_available and not getattr(self.arguments, "disable_web", False):
+            self.web = None
+            return
+
+        self.web = core.Web(
+            data_root=self.arguments.data_root,
+            api_token=self.api_token,
+            proxy=self.proxy,
+            connection=self.conn,
+        )
+
+    def _get_token(self) -> None:
+        while self.api_token is None:
+            if self.arguments.no_auth:
+                return
+            if self.web:
+                self.loop.run_until_complete(self.web.start(self.arguments.port))
+                self._web_banner()
+                self.loop.run_until_complete(self.web.wait_for_api_token_setup())
+                self.api_token = self.web.api_token
+            else:
+                run_config({}, self.arguments.data_root)
+                importlib.invalidate_caches()
+                self._get_api_token()
+
+    async def fetch_clients_from_web(self) -> None:
+        for client in self.web.clients:
+            session = SQLiteSession(
+                os.path.join(
+                    self.arguments.data_root or os.path.dirname(utils.get_base_dir()),
+                    f"hikka-+{'x' * (len(client.phone) - 5)}{client.phone[-4:]}-{(await client.get_me()).id}",
+                )
+            )
+
+            session.set_dc(
+                client.session.dc_id,
+                client.session.server_address,
+                client.session.port,
+            )
+            session.auth_key = client.session.auth_key
+            session.save()
+            client.session = session
+
+        self.clients = list(set(self.clients + self.web.clients))
+
+    def _web_banner(self) -> None:
+        print("‚úÖ Web mode ready for configuration")
+        print(f"üåê Please visit http://127.0.0.1:{self.web.port}")
+
+    async def wait_for_web_auth(self, token) -> None:
+        timeout = 5 * 60
+        polling_interval = 1
+        for _ in range(ceil(timeout * polling_interval)):
+            await asyncio.sleep(polling_interval)
+
+            for client in self.clients:
+                if client.loader.inline.pop_web_auth_token(token):
+                    return True
+
+    def _initial_setup(self) -> bool:
+        if self.arguments.no_auth:
+            return False
+
+        if not self.web:
+            try:
+                phone = input("Please enter your phone: ")
+                self.phones = {phone.split(":", maxsplit=1)[0]: phone}
+            except (EOFError, OSError):
+                raise
+
+            return True
+
+        if not self.web.running.is_set():
+            self.loop.run_until_complete(self.web.start(self.arguments.port))
+            self._web_banner()
+
+        self.loop.run_until_complete(self.web.wait_for_clients_setup())
+
+        return True
+
+    def _init_clients(self) -> None:
+        for phone_id, phone in self.phones.items():
+            session = os.path.join(
+                self.arguments.data_root or os.path.dirname(utils.get_base_dir()),
+                f'hikka{f"-{phone_id}" if phone_id else ""}',
+            )
+
+            try:
+                client = TelegramClient(
+                    session,
+                    self.api_token.ID,
+                    self.api_token.HASH,
+                    connection=self.conn,
+                    proxy=self.proxy,
+                    connection_retries=None,
+                )
+
+                client.start(
+                    phone=raise_auth
+                    if self.web
+                    else lambda: input("Phone: ")
+                )
+                client.phone = phone
+
+                self.clients.append(client)
+            except sqlite3.OperationalError:
+                print(
+                    "Check that this is the only instance running. "
+                    f"If that doesn't help, delete the file named 'hikka-{phone or ''}.session'"
+                )
+                continue
+            except (TypeError, AuthKeyDuplicatedError):
+                os.remove(f"{session}.session")
+                self.main()
+            except (ValueError, ApiIdInvalidError):
+                # Bad API hash/ID
+                run_config({}, self.arguments.data_root)
+                return
+            except PhoneNumberInvalidError:
+                print(
+                    "Phone number is incorrect. Use international format (+XX...) "
+                    "and don't put spaces in it."
+                )
+                continue
+            except InteractiveAuthRequired:
+                print(f"Session {session} was terminated and re-auth is required")
+                continue
+
+    def _init_loop(self) -> None:
+        loops = [self.amain_wrapper(client) for client in self.clients]
+        self.loop.run_until_complete(asyncio.gather(*loops))
+
+    async def amain_wrapper(self, client) -> None:
+        """Wrapper around amain"""
+        async with client:
+            first = True
+            while await self.amain(first, client):
+                first = False
+
+    async def _badge(self, client) -> None:
+        """Call the badge in shell"""
+        try:
+            import git
+
+            repo = git.Repo()
+
+            build = repo.heads[0].commit.hexsha
+            diff = repo.git.log(["HEAD..origin/master", "--oneline"])
+            upd = r"Update required" if diff else r"Up-to-date"
+
+            termux = bool(
+                os.popen(
+                    'echo $PREFIX | grep -o "com.termux"'
+                ).read()
+            )
+            _platform = "Termux" if termux else "Unknown"
+
+            logo1 = f"""
+
+                        ‚ñà ‚ñà ‚ñà ‚ñà‚ñÑ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà
+                        ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà
+
+                     ‚Ä¢ Build: {build[:7]}
+                     ‚Ä¢ Version: {'.'.join(list(map(str, list(__version__))))}
+                     ‚Ä¢ {upd}
+                     ‚Ä¢ Platform: {_platform}
+                     - Started for {(await client.get_me()).id} -"""
+
+            print(logo1)
+
+            logging.info(f"=== BUILD: {build} ===")
+            logging.info(
+                f"=== VERSION: {'.'.join(list(map(str, list(__version__))))} ==="
+            )
+            logging.info(f"=== PLATFORM: {_platform} ===")
+        except Exception:
+            logging.exception("Badge error")
+
+    async def _handle_setup(self, client, db) -> None:
+        await db.init()
+        modules = loader.Modules()
+        babelfish = Translator([], [], self.arguments.data_root)
+        await babelfish.init(client)
+
+        modules.register_all(db)
+
+        modules.send_config(db, babelfish)
+        await modules.send_ready(client, db, self.clients)
+
+        for handler in logging.getLogger().handlers:
+            handler.setLevel(50)
+
+        db_ = db.read()
+        db_ = run_config(
+            db_,
+            self.arguments.data_root,
+            getattr(client, "phone", "Unknown Number"),
+            modules,
+        )
+
+    async def _add_dispatcher(self, client, modules, db) -> None:
+        dispatcher = CommandDispatcher(modules, db, self.arguments.no_nickname)
+        client.dispatcher = dispatcher
+        await dispatcher.init(client)
+        modules.check_security = dispatcher.check_security
+
+        client.add_event_handler(
+            dispatcher.handle_incoming,
+            events.NewMessage,
+        )
+
+        client.add_event_handler(
+            dispatcher.handle_incoming,
+            events.ChatAction,
+        )
+
+        client.add_event_handler(
+            dispatcher.handle_command,
+            events.NewMessage(forwards=False),
+        )
+
+        client.add_event_handler(
+            dispatcher.handle_command,
+            events.MessageEdited(),
+        )
+
+    async def amain(self, first, client) -> None:
+        """Entrypoint for async init, run once for each user"""
+        setup = self.arguments.setup
+        web_only = self.arguments.web_only
+        client.parse_mode = "HTML"
+        await client.start()
+
+        handlers = logging.getLogger().handlers
+        db = database.Database(client)
+        await db.init()
+
+        if setup:
+            self._handle_setup(client, db)
+            return False
+
+        logging.debug("got db")
+        logging.info("Loading logging config...")
+        for handler in handlers:
+            handler.setLevel(db.get(__name__, "loglevel", logging.WARNING))
+
+        to_load = ["loader.py"] if self.arguments.docker_deps_internal else None
+
+        babelfish = Translator(
+            db.get(__name__, "langpacks", []),
+            db.get(__name__, "language", ["en"]),
+            self.arguments.data_root,
+        )
+
+        await babelfish.init(client)
+        modules = loader.Modules()
+        client.loader = modules
+
+        if self.arguments.docker_deps_internal:
+            # Loader has installed all dependencies
+            return  # We are done
+
+        if self.web:
+            await self.web.add_loader(client, modules, db)
+            await self.web.start_if_ready(
+                len(self.clients),
+                self.arguments.port,
+            )
+
+        if not web_only:
+            await self._add_dispatcher(client, modules, db)
+
+        modules.register_all(db, to_load)
+        modules.send_config(db, babelfish)
+        await modules.send_ready(client, db, self.clients)
+
+        if first:
+            await self._badge(client)
+
+        await client.run_until_disconnected()
+
+    def main(self) -> None:
+        """Main entrypoint"""
+        self._init_web()
+        save_config_key("port", self.arguments.port)
+        self._get_token()
+
+        if not self.clients and not self.phones and not self._initial_setup():
+            return
+
+        self._init_clients()
+
+        self.loop.set_exception_handler(
+            lambda _, x: logging.error(
+                "Exception on event loop! %s",
+                x["message"],
+                exc_info=x.get("exception", None),
+            )
+        )
+
+        self._init_loop()
+
+
+hikka = Hikka()
diff --git a/friendly-telegram/modules/corectrl.py b/hikka/modules/corectrl.py
similarity index 81%
rename from friendly-telegram/modules/corectrl.py
rename to hikka/modules/corectrl.py
index e950f73..6d86261 100755
--- a/friendly-telegram/modules/corectrl.py
+++ b/hikka/modules/corectrl.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,12 +14,7 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
-import os
-
-import telethon
-from telethon.tl.types import Message
+from telethon.tl.types import Message, Channel
 
 from .. import loader, main, utils
 
@@ -46,14 +41,12 @@ class CoreMod(loader.Module):
         "alias_removed": "‚úÖ <b>Alias</b> <code>{}</code> <b>removed.",
         "no_alias": "<b>üö´ Alias</b> <code>{}</code> <b>does not exist</b>",
         "no_pack": "<b>‚ùì What translation pack should be added?</b>",
-        "bad_pack": "<b>‚úÖ Invalid translation pack specified</b>",
+        "bad_pack": "<b>üö´ Invalid translation pack specified</b>",
         "trnsl_saved": "<b>‚úÖ Translation pack added</b>",
         "packs_cleared": "<b>‚úÖ Translations cleared</b>",
         "lang_set": "<b>‚úÖ Language changed</b>",
         "db_cleared": "<b>‚úÖ Database cleared</b>",
-        "geek": "üï∂ <b>Congrats! You are Geek!</b>\n\n<b>GeekTG version: {}.{}.{}</b>\n<b>Branch: master</b>",
-        "geek_beta": "üï∂ <b>Congrats! You are Geek!</b>\n\n<b>GeekTG version: {}.{}.{}beta</b>\n<b>Branch: beta</b>\n\n<i>üîÆ You're using the unstable branch (<b>beta</b>). You receive fresh but untested updates. Report any bugs to @chat_ftg or @hikari_chat</i>",
-        "geek_alpha": "üï∂ <b>Congrats! You are Geek!</b>\n\n<b>GeekTG version: {}.{}.{}alpha</b>\n<b>Branch: alpha</b>\n\n<i>üîÆ You're using <b><u>very</u></b> unstable branch (<b>alpha</b>). You receive fresh but untested updates. You <b><u>can't ask for help, only report bugs</u></b></i>",
+        "hikka": "üë©‚Äçüé§ <b>You are Hikka!</b>\n<b>Hikka version: {}.{}.{}</b>",
     }
 
     async def client_ready(self, client, db):
@@ -85,22 +78,13 @@ class CoreMod(loader.Module):
         module = self.allmodules.get_classname(module)
         return f"{str(chatid)}.{module}" if module else chatid
 
-    async def ftgvercmd(self, message: Message) -> None:
-        """Get GeekTG version"""
-        ver = getattr(main, "__version__", False)
-
-        branch = os.popen("git rev-parse --abbrev-ref HEAD").read()  # skipcq: BAN-B605, BAN-B607
-
-        if "beta" in branch:
-            await utils.answer(message, self.strings("geek_beta").format(*ver))
-        elif "alpha" in branch:
-            await utils.answer(message, self.strings("geek_alpha").format(*ver))
-        else:
-            await utils.answer(message, self.strings("geek").format(*ver))
+    async def hikkacmd(self, message: Message) -> None:
+        """Get Hikka version"""
+        ver = main.__version__
+        await utils.answer(message, self.strings("hikka").format(*ver))
 
     async def blacklistcmd(self, message: Message) -> None:
-        """.blacklist [id]
-        Blacklist the bot from operating somewhere"""
+        """Blacklist the bot from operating somewhere"""
         chatid = await self.blacklistcommon(message)
 
         self._db.set(
@@ -112,19 +96,17 @@ class CoreMod(loader.Module):
         await utils.answer(message, self.strings("blacklisted", message).format(chatid))
 
     async def unblacklistcmd(self, message: Message) -> None:
-        """.unblacklist [id]
-        Unblacklist the bot from operating somewhere"""
+        """Unblacklist the bot from operating somewhere"""
         chatid = await self.blacklistcommon(message)
 
         self._db.set(
             main.__name__,
             "blacklist_chats",
             list(
-                set(self._db.get(main.__name__, "blacklist_chats", [])) - {chatid}
+                set(self._db.get(main.__name__, "blacklist_chats", [])) - set([chatid])
             ),
         )
 
-
         await utils.answer(
             message, self.strings("unblacklisted", message).format(chatid)
         )
@@ -145,8 +127,7 @@ class CoreMod(loader.Module):
             return
 
     async def blacklistusercmd(self, message: Message) -> None:
-        """.blacklistuser [id]
-        Prevent this user from running any commands"""
+        """Prevent this user from running any commands"""
         user = await self.getuser(message)
 
         self._db.set(
@@ -160,19 +141,18 @@ class CoreMod(loader.Module):
         )
 
     async def unblacklistusercmd(self, message: Message) -> None:
-        """.unblacklistuser [id]
-        Allow this user to run permitted commands"""
+        """Allow this user to run permitted commands"""
         user = await self.getuser(message)
 
         self._db.set(
             main.__name__,
             "blacklist_users",
-            list(set(self._db.get(main.__name__, "blacklist_users", [])) - {user}),
+            list(set(self._db.get(main.__name__, "blacklist_users", [])) - set([user])),  # skipcq: PTC-W0018
         )
 
-
         await utils.answer(
-            message, self.strings("user_unblacklisted", message).format(user)
+            message,
+            self.strings("user_unblacklisted", message).format(user),
         )
 
     @loader.owner
@@ -186,6 +166,7 @@ class CoreMod(loader.Module):
 
         if len(args) != 1:
             await utils.answer(message, self.strings("prefix_incorrect", message))
+            return
 
         oldprefix = self._db.get(main.__name__, "command_prefix", ".")
         self._db.set(main.__name__, "command_prefix", args)
@@ -261,7 +242,6 @@ class CoreMod(loader.Module):
 
     async def addtrnslcmd(self, message: Message) -> None:
         """Add a translation pack
-        .addtrnsl <pack>
         Restart required after use"""
         args = utils.get_args(message)
 
@@ -279,7 +259,7 @@ class CoreMod(loader.Module):
             await utils.answer(message, self.strings("bad_pack", message))
             return
 
-        if isinstance(pack, telethon.tl.types.Channel) and not pack.megagroup:
+        if isinstance(pack, Channel) and not pack.megagroup:
             self._db.setdefault(main.__name__, {}).setdefault("langpacks", []).append(
                 pack.id
             )
@@ -295,8 +275,6 @@ class CoreMod(loader.Module):
 
     async def setlangcmd(self, message: Message) -> None:
         """Change the preferred language used for translations
-        Specify the language as space separated list of ISO 639-1 language codes in order of preference (e.g. fr en)
-        With no parameters, all translations are disabled
         Restart required after use"""
         langs = utils.get_args(message)
         self._db.set(main.__name__, "language", langs)
diff --git a/friendly-telegram/modules/help.py b/hikka/modules/help.py
similarity index 80%
rename from friendly-telegram/modules/help.py
rename to hikka/modules/help.py
index f298866..89802d7 100755
--- a/friendly-telegram/modules/help.py
+++ b/hikka/modules/help.py
@@ -1,12 +1,12 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-# meta pic: https://img.icons8.com/fluency/48/000000/chatbot.png
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import inspect
 from .. import loader, utils, main, security
@@ -20,7 +20,7 @@ logger = logging.getLogger(__name__)
 
 @loader.tds
 class HelpMod(loader.Module):
-    """Help module, made specifically for GeekTG with <3"""
+    """Help module, made specifically for Hikka with <3"""
 
     strings = {
         "name": "Help",
@@ -32,14 +32,12 @@ class HelpMod(loader.Module):
         "mod_tmpl": "\n{} <code>{}</code>",
         "first_cmd_tmpl": ": ( {}",
         "cmd_tmpl": " | {}",
-        "args": "üö´ <b>Args are incorrect</b>",
-        "set_cat": "‚ÑπÔ∏è <b>{} placed in category {}</b>",
         "no_mod": "üö´ <b>Specify module to hide</b>",
         "hidden_shown": "üëì <b>{} modules hidden, {} module shown:</b>\n{}\n{}",
         "ihandler": "\nüéπ <code>{}</code> üëâüèª ",
         "undoc_ihandler": "ü¶• No docs",
-        "joined": "üë©‚Äçüíº <b>Joined the</b> <a href='https://t.me/GeekTGChat'>support chat</a>",
-        "join": "üë©‚Äçüíº <b>Join the</b> <a href='https://t.me/GeekTGChat'>support chat</a>",
+        "joined": "üë©‚Äçüíº <b>Joined the</b> <a href='https://t.me/hikka_talks'>support chat</a>",
+        "join": "üë©‚Äçüíº <b>Join the</b> <a href='https://t.me/hikka_talks'>support chat</a>",
     }
 
     def __init__(self):
@@ -47,9 +45,9 @@ class HelpMod(loader.Module):
             "core_emoji",
             "‚ñ™Ô∏è",
             lambda: "Core module bullet",
-            "geek_emoji",
-            "üï∂",
-            lambda: "Geek-only module bullet",
+            "hikka_emoji",
+            "üë©‚Äçüé§",
+            lambda: "Hikka-only module bullet",
             "plain_emoji",
             "‚ñ´Ô∏è",
             lambda: "Plain module bullet"
@@ -66,7 +64,7 @@ class HelpMod(loader.Module):
         *Split modules by spaces"""
         modules = utils.get_args(message)
         if not modules:
-            await utils.answer(message, self.strings("no_mod"))
+            await utils.answer(message, self.strings("no_mod", message))
             return
 
         mods = [
@@ -90,7 +88,7 @@ class HelpMod(loader.Module):
 
         await utils.answer(
             message,
-            self.strings("hidden_shown").format(
+            self.strings("hidden_shown", message).format(
                 len(hidden),
                 len(shown),
                 "\n".join([f"üëÅ‚Äçüó® <i>{m}</i>" for m in hidden]),
@@ -123,7 +121,7 @@ class HelpMod(loader.Module):
                 if args in self.allmodules.commands:
                     module = self.allmodules.commands[args].__self__
                 else:
-                    await utils.answer(message, self.strings("bad_module").format(args))
+                    await utils.answer(message, self.strings("bad_module", message).format(args))
                     return
 
             try:
@@ -131,7 +129,7 @@ class HelpMod(loader.Module):
             except KeyError:
                 name = getattr(module, "name", "ERROR")
 
-            reply = self.strings("single_mod_header").format(utils.escape_html(name))
+            reply = self.strings("single_mod_header", message).format(utils.escape_html(name))
             if module.__doc__:
                 reply += (
                     "<i>\n‚ÑπÔ∏è " + utils.escape_html(inspect.getdoc(module)) + "\n</i>"
@@ -163,11 +161,11 @@ class HelpMod(loader.Module):
                         reply += self.strings("undoc_ihandler", message)
 
             for name, fun in commands.items():
-                reply += self.strings("single_cmd").format(prefix, name)
+                reply += self.strings("single_cmd", message).format(prefix, name)
                 if fun.__doc__:
                     reply += utils.escape_html(inspect.getdoc(fun))
                 else:
-                    reply += self.strings("undoc_cmd")
+                    reply += self.strings("undoc_cmd", message)
 
             await utils.answer(message, reply)
             return
@@ -189,15 +187,8 @@ class HelpMod(loader.Module):
         hidden = list(filter(lambda module: module in mods, self.get("hide", [])))
         self.set("hide", hidden)
 
-        reply = self.strings("all_header").format(count, len(hidden) if not force else 0)
+        reply = self.strings("all_header", message).format(count, len(hidden) if not force else 0)
         shown_warn = False
-        cats = {}
-
-        for mod_name, cat in self._db.get("Help", "cats", {}).items():
-            if cat not in cats:
-                cats[cat] = []
-
-            cats[cat].append(mod_name)
 
         plain_ = []
         core_ = []
@@ -231,16 +222,16 @@ class HelpMod(loader.Module):
                 except Exception:
                     pass
 
-            core = mod.__origin__ == "<file>"
+            core = mod.__origin__ == "<core>"
 
             if core:
                 emoji = self.config['core_emoji']
             elif inline:
-                emoji = self.config['geek_emoji']
+                emoji = self.config['hikka_emoji']
             else:
                 emoji = self.config['plain_emoji']
 
-            tmp += self.strings("mod_tmpl").format(emoji, name)
+            tmp += self.strings("mod_tmpl", message).format(emoji, name)
 
             first = True
 
@@ -252,10 +243,10 @@ class HelpMod(loader.Module):
 
             for cmd in commands:
                 if first:
-                    tmp += self.strings("first_cmd_tmpl").format(cmd)
+                    tmp += self.strings("first_cmd_tmpl", message).format(cmd)
                     first = False
                 else:
-                    tmp += self.strings("cmd_tmpl").format(cmd)
+                    tmp += self.strings("cmd_tmpl", message).format(cmd)
 
             icommands = [
                 name
@@ -265,24 +256,21 @@ class HelpMod(loader.Module):
 
             for cmd in icommands:
                 if first:
-                    tmp += self.strings("first_cmd_tmpl").format(f"üéπ {cmd}")
+                    tmp += self.strings("first_cmd_tmpl", message).format(f"üéπ {cmd}")
                     first = False
                 else:
-                    tmp += self.strings("cmd_tmpl").format(f"üéπ {cmd}")
+                    tmp += self.strings("cmd_tmpl", message).format(f"üéπ {cmd}")
 
             if commands or icommands:
                 tmp += " )"
-                if inline:
-                    inline_ += [tmp]
-                elif core:
+                if core:
                     core_ += [tmp]
+                elif inline:
+                    inline_ += [tmp]
                 else:
                     plain_ += [tmp]
             elif not shown_warn and (mod.commands or mod.inline_handlers):
-                reply = (
-                    "<i>You have permissions to execute only this commands</i>\n"
-                    + reply
-                )
+                reply = f"<i>You have permissions to execute only this commands</i>\n{reply}"
                 shown_warn = True
 
         plain_.sort(key=lambda x: x.split()[1])
@@ -292,17 +280,18 @@ class HelpMod(loader.Module):
         await utils.answer(message, f"{reply}\n{''.join(core_)}{''.join(plain_)}{''.join(inline_)}")
 
     async def supportcmd(self, message):
-        """Joins the support GeekTG chat"""
+        """Joins the support Hikka chat"""
         if await self.allmodules.check_security(
-            message, security.OWNER | security.SUDO
+            message,
+            security.OWNER | security.SUDO,
         ):
-            await self._client(JoinChannelRequest("https://t.me/GeekTGChat"))
+            await self._client(JoinChannelRequest("https://t.me/hikka_talks"))
 
             try:
                 await self.inline.form(
                     self.strings("joined", message),
                     reply_markup=[
-                        [{"text": "üë©‚Äçüíº Chat", "url": "https://t.me/GeekTGChat"}]
+                        [{"text": "üë©‚Äçüíº Chat", "url": "https://t.me/hikka_talks"}]
                     ],
                     ttl=10,
                     message=message,
@@ -314,7 +303,7 @@ class HelpMod(loader.Module):
                 await self.inline.form(
                     self.strings("join", message),
                     reply_markup=[
-                        [{"text": "üë©‚Äçüíº Chat", "url": "https://t.me/GeekTGChat"}]
+                        [{"text": "üë©‚Äçüíº Chat", "url": "https://t.me/hikka_talks"}]
                     ],
                     ttl=10,
                     message=message,
@@ -324,5 +313,4 @@ class HelpMod(loader.Module):
 
     async def client_ready(self, client, db) -> None:
         self._client = client
-        self.is_bot = await client.is_bot()
         self._db = db
diff --git a/friendly-telegram/modules/geek_config.py b/hikka/modules/hikka_config.py
similarity index 83%
rename from friendly-telegram/modules/geek_config.py
rename to hikka/modules/hikka_config.py
index 1222467..2cb05fe 100755
--- a/friendly-telegram/modules/geek_config.py
+++ b/hikka/modules/hikka_config.py
@@ -1,16 +1,14 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-# <3 title: GeekConfig [geek]
-# <3 pic: https://img.icons8.com/external-filled-outline-wichaiwi/64/000000/external-multitasking-generation-z-filled-outline-wichaiwi.png
-# <3 desc: Interactive configurator for GeekTG
-
-# scope: inline_content
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+# scope: inline
 
 from .. import loader, utils
 from telethon.tl.types import Message
@@ -21,12 +19,6 @@ import ast
 
 logger = logging.getLogger(__name__)
 
-
-def chunks(lst: Union[list, tuple, set], n: int) -> List[list]:
-    for i in range(0, len(lst), n):
-        yield lst[i : i + n]
-
-
 blacklist = [
     "Raphielgang Configuration Placeholder",
     "Uniborg configuration placeholder",
@@ -35,11 +27,11 @@ blacklist = [
 
 
 @loader.tds
-class GeekConfigMod(loader.Module):
-    """Interactive configurator for GeekTG"""
+class HikkaConfigMod(loader.Module):
+    """Interactive configurator for Hikka Userbot"""
 
     strings = {
-        "name": "GeekConfig",
+        "name": "HikkaConfig",
         "configure": "üéö <b>Here you can configure your modules' configs</b>",
         "configuring_mod": "üéö <b>Choose config option for mod</b> <code>{}</code>",
         "configuring_option": "üéö <b>Configuring option </b><code>{}</code><b> of mod </b><code>{}</code>\n<i>‚ÑπÔ∏è {}</i>\n\n<b>Default: </b><code>{}</code>\n\n<b>Current: </b><code>{}</code>",
@@ -78,6 +70,7 @@ class GeekConfigMod(loader.Module):
                         query = ast.literal_eval(query)
                     except (ValueError, SyntaxError):
                         pass
+
                     self._db.setdefault(module.__module__, {}).setdefault(
                         "__config__", {}
                     )[option] = query
@@ -108,7 +101,10 @@ class GeekConfigMod(loader.Module):
         )
 
     async def inline__configure_option(
-        self, call: CallbackQuery, mod: str, config_opt: str
+        self,
+        call: CallbackQuery,
+        mod: str,
+        config_opt: str,
     ) -> None:  # noqa
         for module in self.allmodules.modules:
             if module.strings("name") == mod:
@@ -140,7 +136,7 @@ class GeekConfigMod(loader.Module):
                     ],
                 )
 
-    async def inline__configure(self, call: CallbackQuery, mod: str) -> None:  # noqa
+    async def inline__configure(self, call: CallbackQuery, mod: str) -> None:
         btns = []
         for module in self.allmodules.modules:
             if module.strings("name") == mod:
@@ -155,7 +151,7 @@ class GeekConfigMod(loader.Module):
 
         await call.edit(
             self.strings("configuring_mod").format(utils.escape_html(mod)),
-            reply_markup=list(chunks(btns, 2))
+            reply_markup=list(utils.chunks(btns, 2))
             + [
                 [
                     {"text": "üëà Back", "callback": self.inline__global_config},
@@ -165,15 +161,16 @@ class GeekConfigMod(loader.Module):
         )
 
     async def inline__global_config(
-        self, call: Union[Message, CallbackQuery]
-    ) -> None:  # noqa
+        self,
+        call: Union[Message, CallbackQuery],
+    ) -> None:
         to_config = [
             mod.strings("name")
             for mod in self.allmodules.modules
             if hasattr(mod, "config") and mod.strings("name") not in blacklist
         ]
         kb = []
-        for mod_row in chunks(to_config, 3):
+        for mod_row in utils.chunks(to_config, 3):
             row = [
                 {"text": btn, "callback": self.inline__configure, "args": (btn,)}
                 for btn in mod_row
@@ -184,7 +181,9 @@ class GeekConfigMod(loader.Module):
 
         if isinstance(call, Message):
             await self.inline.form(
-                self.strings("configure"), reply_markup=kb, message=call
+                self.strings("configure"),
+                reply_markup=kb,
+                message=call,
             )
         else:
             await call.edit(self.strings("configure"), reply_markup=kb)
diff --git a/hikka/modules/hikka_info.py b/hikka/modules/hikka_info.py
new file mode 100755
index 0000000..cf51f9a
--- /dev/null
+++ b/hikka/modules/hikka_info.py
@@ -0,0 +1,98 @@
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+# scope: inline
+
+from .. import loader, main, utils
+import logging
+import git
+
+from telethon.utils import get_display_name
+from ..inline.types import InlineQuery
+from aiogram.types import (
+    InlineQueryResultArticle,
+    InputTextMessageContent,
+    InlineKeyboardMarkup,
+    InlineKeyboardButton,
+)
+
+logger = logging.getLogger(__name__)
+
+
+@loader.tds
+class HikkaInfoMod(loader.Module):
+    """Show userbot info"""
+
+    strings = {"name": "HikkaInfo"}
+
+    def get(self, *args) -> dict:
+        return self._db.get(self.strings["name"], *args)
+
+    def set(self, *args) -> None:
+        return self._db.set(self.strings["name"], *args)
+
+    async def client_ready(self, client, db) -> None:
+        self._db = db
+        self._client = client
+        self._me = await client.get_me()
+        self.markup = InlineKeyboardMarkup()
+        self.markup.row(
+            InlineKeyboardButton("ü§µ‚Äç‚ôÄÔ∏è Support chat", url="https://t.me/hikka_talks")
+        )
+
+    async def info_inline_handler(self, query: InlineQuery) -> None:
+        """
+        Send userbot info
+        @allow: all
+        """
+
+        try:
+            repo = git.Repo()
+            ver = repo.heads[0].commit.hexsha
+        except Exception:
+            ver = "unknown"
+
+        try:
+            diff = repo.git.log(["HEAD..origin/alpha", "--oneline"])
+            upd = (
+                "‚ö†Ô∏è Update required </b><code>.update</code><b>"
+                if diff
+                else "‚úÖ Up-to-date"
+            )
+        except Exception:
+            upd = ""
+
+        await query.answer(
+            [
+                InlineQueryResultArticle(
+                    id=utils.rand(20),
+                    title="Send userbot info",
+                    description="‚Ñπ This will not compromise any sensitive data",
+                    input_message_content=InputTextMessageContent(
+                        (
+                            "<b>üë©‚Äçüé§ Hikka Userbot</b>\n"
+                            f'<b>ü§¥ Owner: <a href="tg://user?id={self._me.id}">{utils.escape_html(get_display_name(self._me))}</a></b>\n\n'
+                            f"<b>üîÆ Version: </b><i>{'.'.join(list(map(str, list(main.__version__))))}</i>\n"
+                            f"<b>üß± Build: </b><a href=\"https://github.com/hikariatama/Hikka/commit/{ver}\">{ver[:8] or 'Unknown'}</a>\n"
+                            f"<b>üìº Command prefix: </b>¬´<code>{utils.escape_html((self._db.get(main.__name__, 'command_prefix', False) or '.')[0] )}</code>¬ª\n"
+                            f"<b>{upd}</b>\n"
+                            f"<b>{utils.get_named_platform()}</b>\n"
+                        ),
+                        "HTML",
+                        disable_web_page_preview=True,
+                    ),
+                    thumb_url="https://github.com/hikariatama/Hikka/raw/master/assets/hikka_pfp.png",
+                    thumb_width=128,
+                    thumb_height=128,
+                    reply_markup=self.markup,
+                )
+            ],
+            cache_time=0,
+        )
diff --git a/friendly-telegram/modules/geek_security.py b/hikka/modules/hikka_security.py
similarity index 90%
rename from friendly-telegram/modules/geek_security.py
rename to hikka/modules/hikka_security.py
index 18e0ed9..653d688 100755
--- a/friendly-telegram/modules/geek_security.py
+++ b/hikka/modules/hikka_security.py
@@ -1,11 +1,13 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-# meta pic: https://img.icons8.com/stickers/100/000000/enter-pin.png
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
 # scope: inline
 
 from types import FunctionType
@@ -36,16 +38,12 @@ from ..security import (
 logger = logging.getLogger(__name__)
 
 
-def chunks(lst: list, n: int) -> List[list]:
-    return [lst[i : i + n] for i in range(0, len(lst), n)]
-
-
 @loader.tds
-class GeekSecurityMod(loader.Module):
-    """Control security settings (geek3.0.8alpha+)"""
+class HikkaSecurityMod(loader.Module):
+    """Control security settings"""
 
     strings = {
-        "name": "GeekSecurity",
+        "name": "HikkaSecurity",
         "no_command": "üö´ <b>Command </b><code>{}</code><b> not found!</b>",
         "permissions": "üîê <b>Here you can configure permissions for </b><code>{}{}</code>",
         "close_menu": "üôà Close this menu",
@@ -103,7 +101,7 @@ class GeekSecurityMod(loader.Module):
         )
 
         self._me = (await client.get_me()).id
-        self._is_geek = hasattr(self, 'inline')
+        self._is_hikka = hasattr(self, 'inline')
 
     async def inline__switch_perm(
         self, call: aiogram.types.CallbackQuery, command: str, group: str, level: bool
@@ -157,15 +155,14 @@ class GeekSecurityMod(loader.Module):
         perms = self._get_current_perms(command)
         buttons = [
             {
-                "text": f"{'‚úÖ' if level else 'üö´'} {self.strings[group]}",
+                "text": f"{('üö´' if not level else '‚úÖ')} {self.strings[group]}",
                 "callback": self.inline__switch_perm,
                 "args": (command.__name__[:-3], group, not level),
             }
             for group, level in perms.items()
         ]
 
-
-        return chunks(buttons, 2) + [
+        return utils.chunks(buttons, 2) + [
             [{"text": self.strings("close_menu"), "callback": self.inline_close}]
         ]
 
@@ -173,15 +170,14 @@ class GeekSecurityMod(loader.Module):
         perms = self._get_current_bm()
         buttons = [
             {
-                "text": f"{'‚úÖ' if level else 'üö´'} {self.strings[group]}",
+                "text": f"{('üö´' if not level else '‚úÖ')} {self.strings[group]}",
                 "callback": self.inline__switch_perm_bm,
                 "args": (group, not level),
             }
             for group, level in perms.items()
         ]
 
-
-        return chunks(buttons, 2) + [
+        return utils.chunks(buttons, 2) + [
             [{"text": self.strings("close_menu"), "callback": self.inline_close}]
         ]
 
@@ -288,7 +284,7 @@ class GeekSecurityMod(loader.Module):
         if isinstance(user, int):
             user = await self._client.get_entity(user)
 
-        if self._is_geek and not confirmed:
+        if self._is_hikka and not confirmed:
             await self.inline.form(
                 self.strings("warning").format(
                     user.id, utils.escape_html(get_display_name(user)), group
@@ -322,7 +318,7 @@ class GeekSecurityMod(loader.Module):
             utils.escape_html(get_display_name(user)),
         )
 
-        if not self._is_geek:
+        if not self._is_hikka:
             m += f"\n\n{self.strings('restart')}"
 
         if isinstance(message, Message):
@@ -341,16 +337,15 @@ class GeekSecurityMod(loader.Module):
         self._db.set(
             security.__name__,
             group,
-            list(set(self._db.get(security.__name__, group, [])) - {user.id}),
+            list(set(self._db.get(security.__name__, group, [])) - set([user.id])),  # skipcq: PTC-W0018
         )
 
-
         m = self.strings(f"{group}_removed").format(
             user.id,
             utils.escape_html(get_display_name(user)),
         )
 
-        if not self._is_geek:
+        if not self._is_hikka:
             m += f"\n\n{self.strings('restart')}"
 
         await utils.answer(
diff --git a/friendly-telegram/modules/geek_settings.py b/hikka/modules/hikka_settings.py
similarity index 80%
rename from friendly-telegram/modules/geek_settings.py
rename to hikka/modules/hikka_settings.py
index e4c104c..8353b97 100755
--- a/friendly-telegram/modules/geek_settings.py
+++ b/hikka/modules/hikka_settings.py
@@ -1,15 +1,14 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-# meta pic: https://img.icons8.com/pastel-glyph/344/sun-glasses--v2.png
 # scope: inline
-# scope: geektg_only
-# meta developer: @hikariatama
 
 from .. import loader, utils, main
 from telethon.tl.types import Message
@@ -20,14 +19,13 @@ logger = logging.getLogger(__name__)
 
 
 @loader.tds
-class GeekSettingsMod(loader.Module):
-    """Advanced settings for GeekTG"""
+class HikkaSettingsMod(loader.Module):
+    """Advanced settings for Hikka Userbot"""
 
     strings = {
-        "name": "GeekSettings",
+        "name": "HikkaSettings",
         "watchers": "üëÄ <b>Watchers:</b>\n\n<b>{}</b>",
         "mod404": "üö´ <b>Watcher {} not found</b>",
-        "already_disabled": "üëÄ <b>Watcher {} is already disabled</b>",
         "disabled": "üëÄ <b>Watcher {} is now <u>disabled</u></b>",
         "enabled": "üëÄ <b>Watcher {} is now <u>enabled</u></b>",
         "args": "üö´ <b>You need to specify watcher name</b>",
@@ -35,9 +33,16 @@ class GeekSettingsMod(loader.Module):
         "no_cmd": "üî∞ <b>Please, specify command to toggle NoNick for</b>",
         "cmd_nn": "üî∞ <b>NoNick for </b><code>{}</code><b> is now {}</b>",
         "cmd404": "üî∞ <b>Command not found</b>",
-        "inline_settings": "‚öôÔ∏è <b>Here you can configure your GeekTG settings</b>",
+        "inline_settings": "‚öôÔ∏è <b>Here you can configure your Hikka settings</b>",
         "confirm_update": "ü™Ç <b>Please, confirm that you want to update. Your userbot will be restarted</b>",
         "confirm_restart": "üîÑ <b>Please, confirm that you want to restart</b>",
+        "suggest_fs": "‚úÖ Suggest FS for modules",
+        "do_not_suggest_fs": "üö´ Suggest FS for modules",
+        "use_fs": "‚úÖ Always use FS for modules",
+        "do_not_use_fs": "üö´ Always use FS for modules",
+        "btn_restart": "üîÑ Restart",
+        "btn_update": "ü™Ç Update",
+        "close_menu": "üòå Close menu",
     }
 
     def get_watchers(self) -> tuple:
@@ -188,12 +193,13 @@ class GeekSettingsMod(loader.Module):
             nn = list(set(nn))  # skipcq: PTC-W0018
             await utils.answer(message, self.strings("user_nn").format("on"))
         else:
-            nn = list(set(nn) - {u})
+            nn = list(set(nn) - set([u]))  # skipcq: PTC-W0018
             await utils.answer(message, self.strings("user_nn").format("off"))
 
         self._db.set(main.__name__, "nonickusers", nn)
 
     async def nonickcmdcmd(self, message: Message) -> None:
+        """Allow certain command to be executed without nickname"""
         args = utils.get_args_raw(message)
         if not args:
             return await utils.answer(message, self.strings("no_cmd"))
@@ -212,7 +218,7 @@ class GeekSettingsMod(loader.Module):
                 ),
             )
         else:
-            nn = list(set(nn) - {args})
+            nn = list(set(nn) - set([args]))  # skipcq: PTC-W0018
             await utils.answer(
                 message,
                 self.strings("cmd_nn").format(
@@ -227,7 +233,7 @@ class GeekSettingsMod(loader.Module):
         self._db.set(main.__name__, key, state)
 
         if key == "no_nickname" and state and self._db.get(main.__name__, "command_prefix", ".") == ".":
-            await call.answer("Warning! You enabled NoNick with default prefix! You may get muted in GeekTG chats. Change prefix or disable NoNick!", show_alert=True)
+            await call.answer("Warning! You enabled NoNick with default prefix! You may get muted in Hikka chats. Change prefix or disable NoNick!", show_alert=True)
         else:
             await call.answer("Configuration value saved!")
 
@@ -339,15 +345,57 @@ class GeekSettingsMod(loader.Module):
                     }
                 ),
             ],
+            [
+                (
+                    {
+                        "text": self.strings("suggest_fs"),
+                        "callback": self.inline__setting,
+                        "args": (
+                            "disable_modules_fs",
+                            True,
+                        ),
+                    }
+                    if not self._db.get(main.__name__, "disable_modules_fs", False)
+                    else {
+                        "text": self.strings("do_not_suggest_fs"),
+                        "callback": self.inline__setting,
+                        "args": (
+                            "disable_modules_fs",
+                            False,
+                        ),
+                    }
+                ),
+            ],
+            [
+                (
+                    {
+                        "text": self.strings("use_fs"),
+                        "callback": self.inline__setting,
+                        "args": (
+                            "permanent_modules_fs",
+                            False,
+                        ),
+                    }
+                    if self._db.get(main.__name__, "permanent_modules_fs", False)
+                    else {
+                        "text": self.strings("do_not_use_fs"),
+                        "callback": self.inline__setting,
+                        "args": (
+                            "permanent_modules_fs",
+                            True,
+                        ),
+                    }
+                ),
+            ],
             [
                 {
-                    "text": "üîÑ Restart",
+                    "text": self.strings("btn_restart"),
                     "callback": self.inline__restart,
                     "args": (True,),
                 },
-                {"text": "ü™Ç Update", "callback": self.inline__update, "args": (True,)},
+                {"text": self.strings("btn_update"), "callback": self.inline__update, "args": (True,)},
             ],
-            [{"text": "üòå Close menu", "callback": self.inline__close}],
+            [{"text": self.strings("close_menu"), "callback": self.inline__close}],
         ]
 
     @loader.owner
diff --git a/hikka/modules/inline_stuff.py b/hikka/modules/inline_stuff.py
new file mode 100644
index 0000000..d08cff6
--- /dev/null
+++ b/hikka/modules/inline_stuff.py
@@ -0,0 +1,57 @@
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the CC BY-NC-ND 4.0
+# üåê https://creativecommons.org/licenses/by-nc-nd/4.0
+
+# scope: inline
+# scope: hikka_only
+# meta developer: @hikariatama
+
+from .. import loader, utils
+from telethon.tl.types import Message
+from aiogram.types import CallbackQuery
+import logging
+import re
+
+logger = logging.getLogger(__name__)
+
+
+@loader.tds
+class InlineStuffMod(loader.Module):
+    """Provides support for inline stuff"""
+
+    strings = {"name": "InlineStuff"}
+
+    async def client_ready(self, client, db) -> None:
+        self._db = db
+        self._client = client
+        self._bot_id = (await self.inline.bot.get_me()).id
+
+    async def inline__close(self, call: CallbackQuery) -> None:
+        await call.delete()
+
+    async def watcher(self, message: Message) -> None:
+        if (
+            not getattr(message, "out", False)
+            or not getattr(message, "via_bot_id", False)
+            or message.via_bot_id != self._bot_id
+            or "Loading Hikka gallery..." not in getattr(message, "raw_text", "")
+        ):
+            return
+
+        id_ = re.search(r"#id: ([a-zA-Z0-9]+)", message.raw_text).group(1)
+
+        m = await message.respond("üë©‚Äçüé§ <b>Opening gallery... wait</b>")
+
+        await self.inline.gallery(
+            message=m,
+            next_handler=self.inline._custom_map[id_]["handler"],
+            caption=self.inline._custom_map[id_].get("caption", ""),
+        )
+
+        await message.delete()
diff --git a/friendly-telegram/modules/loader.py b/hikka/modules/loader.py
similarity index 63%
rename from friendly-telegram/modules/loader.py
rename to hikka/modules/loader.py
index 84be420..7c7278a 100755
--- a/friendly-telegram/modules/loader.py
+++ b/hikka/modules/loader.py
@@ -1,5 +1,7 @@
+"""Loads and registers modules"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,7 +16,17 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+# scope: inline
 
 import asyncio
 import importlib
@@ -29,28 +41,33 @@ from importlib.abc import SourceLoader
 from importlib.machinery import ModuleSpec
 import telethon
 from telethon.tl.types import Message
+import functools
+from typing import Any, Union
+from aiogram.types import CallbackQuery
 
 import requests
 
 from .. import loader, utils, main
+from ..compat import geek
 
 logger = logging.getLogger(__name__)
 
 VALID_URL = r"[-[\]_.~:/?#@!$&'()*+,;%<=>a-zA-Z0-9]+"
+
 VALID_PIP_PACKAGES = re.compile(
-    r"^\s*# requires:(?: ?)((?:{url} )*(?:{url}))\s*$".format(url=VALID_URL),
+    r"^\s*# ?requires:(?: ?)((?:{url} )*(?:{url}))\s*$".format(url=VALID_URL),
     re.MULTILINE,
 )
+
 USER_INSTALL = "PIP_TARGET" not in os.environ and "VIRTUAL_ENV" not in os.environ
+
 GIT_REGEX = re.compile(
     r"^https?://github\.com((?:/[a-z0-9-]+){2})(?:/tree/([a-z0-9-]+)((?:/[a-z0-9-]+)*))?/?$",
     flags=re.IGNORECASE,
 )
 
 
-class StringLoader(
-    SourceLoader
-):  # pylint: disable=W0223 # False positive, implemented in SourceLoader
+class StringLoader(SourceLoader):  # pylint: disable=W0223
     """Load a python module/file from a string"""
 
     def __init__(self, data, origin):
@@ -107,7 +124,7 @@ def get_git_api(url):
 
     branch = m.group(2)
     path_ = m.group(3)
-    api_url = f"https://api.github.com/repos{m.group(1)}/contents"
+    api_url = "https://api.github.com/repos{}/contents".format(m.group(1))
 
     if path_ is not None and len(path_) > 0:
         api_url += path_
@@ -125,7 +142,7 @@ class LoaderMod(loader.Module):
     strings = {
         "name": "Loader",
         "repo_config_doc": "Fully qualified URL to a module repo",
-        "avail_header": "<b>üì• Available official modules from repo</b>",
+        "avail_header": "<b>üì≤ Official modules from repo</b>",
         "select_preset": "<b>‚ö†Ô∏è Please select a preset</b>",
         "no_preset": "<b>üö´ Preset not found</b>",
         "preset_loaded": "<b>‚úÖ Preset loaded</b>",
@@ -134,48 +151,40 @@ class LoaderMod(loader.Module):
         "provide_module": "<b>‚ö†Ô∏è Provide a module to load</b>",
         "bad_unicode": "<b>üö´ Invalid Unicode formatting in module</b>",
         "load_failed": "<b>üö´ Loading failed. See logs for details</b>",
-        "loaded": "<b>üì• Module </b><code>{}</code>{}<b> loaded.</b>{}",
+        "loaded": "<b>ü™Å Module </b><code>{}</code>{}<b> loaded.</b>{}",
         "no_class": "<b>What class needs to be unloaded?</b>",
-        "unloaded": "<b>üì§ Module unloaded.</b>",
+        "unloaded": "<b>üî• Module unloaded.</b>",
         "not_unloaded": "<b>üö´ Module not unloaded.</b>",
         "requirements_failed": "<b>üö´ Requirements installation failed</b>",
         "requirements_installing": "<b>üîÑ Installing requirements...</b>",
         "requirements_restart": "<b>üîÑ Requirements installed, but a restart is required</b>",
         "all_modules_deleted": "<b>‚úÖ All modules deleted</b>",
-        "no_modules": "<b>‚ö†Ô∏è You have no custom modules!</b>",
-        "searching": "<b>üîç Searching...</b>",
-        "file": "<b>üì• File of module {}:<b>",
-        "module_link": 'üì• <a href="{}">Link</a> for module {}: \n<code>{}</code>',
-        "not_found_info": "üö´ Request to find module with name {} failed due to:",
-        "not_found_c_info": "üö´ Request to find module with command {} failed due to:",
-        "not_found": "<b>üö´ Module was not found</b>",
-        "file_core": "<b>File of core module {}:</b>",
-        "loading": "<b>üîÑ Loading...</b>",
-        "url_invalid": "<b>üö´ URL invalid</b>",
-        "args_incorrect": "<b>üö´ Args incorrect</b>",
-        "repo_loaded": "<b>‚úÖ Repository loaded</b>",
-        "repo_not_loaded": "<b>üö´ Repository not loaded</b>",
-        "repo_unloaded": "<b>üîÑ Repository unloaded, but restart is required to unload repository modules</b>",
-        "repo_not_unloaded": "<b>üö´ Repository not unloaded</b>",
         "single_cmd": "\nüìç <code>{}{}</code> üëâüèª ",
         "undoc_cmd": "üëÅ‚Äçüó® No docs",
         "ihandler": "\nüéπ <i>Inline</i>: <code>{}</code> üëâüèª ",
         "undoc_ihandler": "üëÅ‚Äçüó® No docs",
-        "chandler": "\nüñ± <i>Callback</i>: <code>{}</code> üëâüèª ",
-        "undoc_chandler": "üëÅ‚Äçüó® No docs",
-        "inline_init_failed": """üö´ <b>This module requires GeekTG inline feature and initialization of InlineManager failed</b>
-<i>Please, remove one of your old bots from @BotFather and restart userbot to load this module</i>""",
-        "version_incompatible": "üö´ <b>This module requires GeekTG {}+\nPlease, update with </b><code>.update</code>",
-        "non_heroku": "‚ôìÔ∏è <b>This module is not supported on Heroku</b>",
+        "inline_init_failed": (
+            "üö´ <b>This module requires Hikka inline feature and "
+            "initialization of InlineManager failed</b>\n"
+            "<i>Please, remove one of your old bots from @BotFather and "
+            "restart userbot to load this module</i>"
+        ),
+        "version_incompatible": "üö´ <b>This module requires Hikka {}+\nPlease, update with </b><code>.update</code>",
         "ffmpeg_required": "üö´ <b>This module requires FFMPEG, which is not installed</b>",
-        "developer": "\nüßë‚Äçüíª <b>Developer: </b><code>{}</code>"
+        "developer": "\n\nüßë‚Äçüíª <b>Developer: </b><code>{}</code>",
+        "module_fs": "üíø <b>Would you like to save this module to filesystem, so it won't get unloaded after restart?</b>",
+        "save": "üíø Save",
+        "no_save": "üö´ Don't save",
+        "save_for_all": "üíΩ Always save to fs",
+        "never_save": "üö´ Never save to fs",
+        "will_save_fs": "üíΩ Now all modules, loaded with .loadmod will be saved to filesystem",
     }
 
     def __init__(self):
         super().__init__()
         self.config = loader.ModuleConfig(
             "MODULES_REPO",
-            "https://raw.githubusercontent.com/GeekTG/FTG-Modules/main/",
+            "https://mods.hikariatama.ru/",
             lambda m: self.strings("repo_config_doc", m),
         )
 
@@ -207,7 +216,7 @@ class LoaderMod(loader.Module):
 
     @loader.owner
     async def dlpresetcmd(self, message: Message) -> None:
-        """Set preset. Defaults to full"""
+        """Set modules preset"""
         args = utils.get_args(message)
 
         if not args:
@@ -241,7 +250,7 @@ class LoaderMod(loader.Module):
             preset = "minimal"
 
         r = await utils.run_sync(
-            requests.get, self.config["MODULES_REPO"] + "/" + preset + ".txt"
+            requests.get, self.config["MODULES_REPO"].strip("/") + "/" + preset + ".txt"
         )
         r.raise_for_status()
         return set(filter(lambda x: x, r.text.split("\n")))
@@ -251,7 +260,7 @@ class LoaderMod(loader.Module):
             if urllib.parse.urlparse(module_name).netloc:
                 url = module_name
             else:
-                url = self.config["MODULES_REPO"] + module_name + ".py"
+                url = self.config["MODULES_REPO"].strip("/") + "/" + module_name + ".py"
 
             r = await utils.run_sync(requests.get, url)
 
@@ -268,6 +277,30 @@ class LoaderMod(loader.Module):
         except Exception:
             logger.exception(f"Failed to load {module_name}")
 
+    async def _inline__load(
+        self,
+        call: CallbackQuery,
+        doc: str,
+        path_: Union[str, None],
+        mode: str,
+    ) -> None:
+        save = False
+        if mode == "all_yes":
+            self._db.set(main.__name__, "permanent_modules_fs", True)
+            self._db.set(main.__name__, "disable_modules_fs", False)
+            await call.answer(self.strings("will_save_fs"))
+            save = True
+        elif mode == "all_no":
+            self._db.set(main.__name__, "disable_modules_fs", True)
+            self._db.set(main.__name__, "permanent_modules_fs", False)
+        elif mode == "once":
+            save = True
+
+        if path_ is not None:
+            await self.load_module(doc, call, origin=path_, save_fs=save)
+        else:
+            await self.load_module(doc, call, save_fs=save)
+
     @loader.owner
     async def loadmodcmd(self, message: Message) -> None:
         """Loads the module file"""
@@ -291,69 +324,142 @@ class LoaderMod(loader.Module):
 
         logger.debug("Loading external module...")
 
+        if message.file:
+            await message.edit("")
+            message = await message.respond("üë©‚Äçüé§")
+
         try:
             doc = doc.decode("utf-8")
         except UnicodeDecodeError:
             await utils.answer(message, self.strings("bad_unicode", message))
             return
 
+        if (
+            not self._db.get(main.__name__, "disable_modules_fs", False)
+            and not self._db.get(main.__name__, "permanent_modules_fs", False)
+        ):
+            await self.inline.form(
+                self.strings("module_fs"),
+                message=message,
+                reply_markup=[
+                    [
+                        {
+                            "text": self.strings("save"),
+                            "callback": self._inline__load,
+                            "args": (doc, path_, "once"),
+                        },
+                        {
+                            "text": self.strings("no_save"),
+                            "callback": self._inline__load,
+                            "args": (doc, path_, "no"),
+                        },
+                    ],
+                    [
+                        {
+                            "text": self.strings("save_for_all"),
+                            "callback": self._inline__load,
+                            "args": (doc, path_, "all_yes"),
+                        }
+                    ],
+                    [
+                        {
+                            "text": self.strings("never_save"),
+                            "callback": self._inline__load,
+                            "args": (doc, path_, "all_no"),
+                        }
+                    ],
+                ],
+            )
+            return
+
         if path_ is not None:
-            await self.load_module(doc, message, origin=path_)
+            await self.load_module(
+                doc,
+                message,
+                origin=path_,
+                save_fs=self._db.get(main.__name__, "permanent_modules_fs", False)
+                and not self._db.get(main.__name__, "disable_modules_fs", False),
+            )
         else:
-            await self.load_module(doc, message)
+            await self.load_module(
+                doc,
+                message,
+                save_fs=self._db.get(main.__name__, "permanent_modules_fs", False)
+                and not self._db.get(main.__name__, "disable_modules_fs", False),
+            )
 
     async def load_module(
-        self, doc, message, name=None, origin="<string>", did_requirements=False
-    ):
-        if re.search(r"# ?scope: ?non_heroku", doc) and 'DYNO' in os.environ:
-            if isinstance(message, Message):
-                await utils.answer(message, self.strings("non_heroku"))
-            return
-
-        if re.search(r"# ?scope: ?ffmpeg", doc) and os.system('ffmpeg -version'):  # skipcq: BAN-B605, BAN-B607
+        self,
+        doc: str,
+        message: Message,
+        name: Union[str, None] = None,
+        origin: str = "<string>",
+        did_requirements: bool = False,
+        save_fs: bool = False,
+    ) -> None:
+        if any(
+            line.replace(" ", "") == "#scope:ffmpeg" for line in doc.splitlines()
+        ) and os.system("ffmpeg -version"):
             if isinstance(message, Message):
                 await utils.answer(message, self.strings("ffmpeg_required"))
             return
 
-        if re.search(r"# ?scope: ?inline", doc) and not self.inline.init_complete:
+        if (
+            any(line.replace(" ", "") == "#scope:inline" for line in doc.splitlines())
+            and not self.inline.init_complete
+        ):
             if isinstance(message, Message):
                 await utils.answer(message, self.strings("inline_init_failed"))
             return
 
-        if re.search(r"# ?scope: ?geektg_min", doc):
-            ver = re.search(r"# ?scope: ?geektg_min ([0-9]+\.[0-9]+\.[0-9]+)", doc).group(1)
-            ver_ = tuple(map(int, ver.split('.')))
+        if re.search(r"# ?scope: ?hikka_min", doc):
+            ver = re.search(
+                r"# ?scope: ?hikka_min ([0-9]+\.[0-9]+\.[0-9]+)",
+                doc,
+            ).group(1)
+            ver_ = tuple(map(int, ver.split(".")))
             if main.__version__ < ver_:
-                await utils.answer(message, self.strings('version_incompatible').format(ver))
+                await utils.answer(
+                    message,
+                    self.strings("version_incompatible").format(ver),
+                )
                 return
 
         developer = re.search(r"# ?meta developer: ?(.+)", doc)
         developer = developer.group(1) if developer else False
-        developer = self.strings('developer').format(developer) if developer else ""
+        developer = self.strings("developer").format(developer) if developer else ""
 
         if name is None:
             uid = "__extmod_" + str(uuid.uuid4())
         else:
             uid = name.replace("%", "%%").replace(".", "%d")
 
-        module_name = "friendly-telegram.modules." + uid
+        module_name = "hikka.modules." + uid
+
+        doc = geek.compat(doc)
 
         try:
             try:
                 spec = ModuleSpec(module_name, StringLoader(doc, origin), origin=origin)
-                instance = self.allmodules.register_module(spec, module_name, origin)
-            except ImportError:
+                instance = self.allmodules.register_module(spec, module_name, origin, save_fs=save_fs)
+            except ImportError as e:
                 logger.info(
                     "Module loading failed, attemping dependency installation",
                     exc_info=True,
                 )
                 # Let's try to reinstall dependencies
-                requirements = list(
-                    filter(
-                        lambda x: x and x[0] not in ("-", "_", "."),
-                        map(str.strip, VALID_PIP_PACKAGES.search(doc)[1].split(" ")),
+                try:
+                    requirements = list(
+                        filter(
+                            lambda x: x and x[0] not in ("-", "_", "."),
+                            map(
+                                str.strip,
+                                VALID_PIP_PACKAGES.search(doc)[1].split(" "),
+                            ),
+                        )
                     )
-                )
+                except TypeError:
+                    raise Exception("No valid pip packages specified in code") from e
 
                 logger.debug("Installing requirements: %r", requirements)
 
@@ -363,14 +469,16 @@ class LoaderMod(loader.Module):
                 if did_requirements:
                     if message is not None:
                         await utils.answer(
-                            message, self.strings("requirements_restart", message)
+                            message,
+                            self.strings("requirements_restart", message),
                         )
 
                     return True  # save to database despite failure, so it will work after restart
 
                 if message is not None:
                     await utils.answer(
-                        message, self.strings("requirements_installing", message)
+                        message,
+                        self.strings("requirements_installing", message),
                     )
 
                 pip = await asyncio.create_subprocess_exec(
@@ -391,7 +499,8 @@ class LoaderMod(loader.Module):
                 if rc != 0:
                     if message is not None:
                         await utils.answer(
-                            message, self.strings("requirements_failed", message)
+                            message,
+                            self.strings("requirements_failed", message),
                         )
 
                     return False
@@ -399,7 +508,12 @@ class LoaderMod(loader.Module):
                 importlib.invalidate_caches()
 
                 return await self.load_module(
-                    doc, message, name, origin, True
+                    doc,
+                    message,
+                    name,
+                    origin,
+                    True,
+                    save_fs,
                 )  # Try again
             except loader.LoadError as e:
                 if message:
@@ -414,8 +528,21 @@ class LoaderMod(loader.Module):
             return False
 
         instance.inline = self.inline
-        if hasattr(instance, '__version__') and isinstance(instance.__version__, tuple):
-            version = "<b><i> (v" + ".".join(list(map(str, list(instance.__version__)))) + ")</i></b>"
+        instance.get = functools.partial(
+            self._mod_get,
+            mod=instance.strings["name"],
+        )
+        instance.set = functools.partial(
+            self._mod_set,
+            mod=instance.strings["name"],
+        )
+
+        if hasattr(instance, "__version__") and isinstance(instance.__version__, tuple):
+            version = (
+                "<b><i> (v"
+                + ".".join(list(map(str, list(instance.__version__))))
+                + ")</i></b>"
+            )
         else:
             version = ""
 
@@ -423,7 +550,10 @@ class LoaderMod(loader.Module):
             try:
                 self.allmodules.send_config_one(instance, self._db, self.babel)
                 await self.allmodules.send_ready_one(
-                    instance, self._client, self._db, self.allclients
+                    instance,
+                    self._client,
+                    self._db,
+                    self.allclients,
                 )
             except loader.LoadError as e:
                 if message:
@@ -453,13 +583,22 @@ class LoaderMod(loader.Module):
                     f"<i>\n‚ÑπÔ∏è {utils.escape_html(inspect.getdoc(instance))}</i>\n"
                 )
 
-            if re.search(r"# ?scope: ?disable_onload_docs", doc):
+            if any(
+                line.replace(" ", "") == "#scope:disable_onload_docs"
+                for line in doc.splitlines()
+            ):
                 return await utils.answer(
                     message,
-                    self.strings("loaded", message).format(modname.strip(), version, modhelp) + developer,
+                    self.strings("loaded", message).format(
+                        modname.strip(), version, modhelp
+                    )
+                    + developer,
                 )
 
-            for _name, fun in instance.commands.items():
+            for _name, fun in sorted(
+                instance.commands.items(),
+                key=lambda x: x[0],
+            ):
                 modhelp += self.strings("single_cmd", message).format(prefix, _name)
 
                 if fun.__doc__:
@@ -469,7 +608,10 @@ class LoaderMod(loader.Module):
 
             if self.inline.init_complete:
                 if hasattr(instance, "inline_handlers"):
-                    for _name, fun in instance.inline_handlers.items():
+                    for _name, fun in sorted(
+                        instance.inline_handlers.items(),
+                        key=lambda x: x[0],
+                    ):
                         modhelp += self.strings("ihandler", message).format(
                             f"@{self.inline._bot_username} {_name}"
                         )
@@ -487,107 +629,26 @@ class LoaderMod(loader.Module):
                         else:
                             modhelp += self.strings("undoc_ihandler", message)
 
-                if hasattr(instance, "callback_handlers"):
-                    for _name, fun in instance.callback_handlers.items():
-                        modhelp += self.strings("chandler", message).format(_name)
-
-                        if fun.__doc__:
-                            modhelp += utils.escape_html(
-                                "\n".join(
-                                    [
-                                        line.strip()
-                                        for line in inspect.getdoc(fun).splitlines()
-                                        if not line.strip().startswith("@")
-                                    ]
-                                )
-                            )
-                        else:
-                            modhelp += self.strings("undoc_chandler", message)
-
             try:
                 await utils.answer(
                     message,
-                    self.strings("loaded", message).format(modname.strip(), version, modhelp) + developer,
+                    self.strings("loaded", message).format(
+                        modname.strip(),
+                        version,
+                        modhelp,
+                    )
+                    + developer,
                 )
             except telethon.errors.rpcerrorlist.MediaCaptionTooLongError:
                 await message.reply(
-                    self.strings("loaded", message).format(modname.strip(), version, modhelp) + developer
-                )
-
-        return True
-
-    @loader.owner
-    async def dlrepocmd(self, message: Message) -> None:
-        """Downloads and installs all modules from repo"""
-        args = utils.get_args(message)
-
-        if len(args) == 1:
-            repo_url = args[0]
-            git_api = get_git_api(repo_url)
-
-            if git_api is None:
-                return await utils.answer(message, self.strings("url_invalid", message))
-
-            await utils.answer(message, self.strings("loading", message))
-
-            if await self.load_repo(git_api):
-                self._db.set(
-                    __name__,
-                    "loaded_repositories",
-                    list(
-                        set(self._db.get(__name__, "loaded_repositories", [])).union(
-                            [repo_url]
-                        )
-                    ),
-                )
-
-                await utils.answer(message, self.strings("repo_loaded", message))
-            else:
-                await utils.answer(message, self.strings("repo_not_loaded", message))
-        else:
-            await utils.answer(message, self.strings("args_incorrect", message))
-
-    @loader.owner
-    async def unloadrepocmd(self, message: Message) -> None:
-        """Removes loaded repository"""
-        args = utils.get_args(message)
-
-        if len(args) == 1:
-            repoUrl = args[0]
-            repos = set(self._db.get(__name__, "loaded_repositories", []))
-
-            try:
-                repos.remove(repoUrl)
-            except KeyError:
-                return await utils.answer(
-                    message, self.strings("repo_not_unloaded", message)
+                    self.strings("loaded", message).format(
+                        modname.strip(),
+                        version,
+                        modhelp,
+                    )
+                    + developer
                 )
 
-            self._db.set(__name__, "loaded_repositories", list(repos))
-
-            await utils.answer(message, self.strings("repo_unloaded", message))
-        else:
-            await utils.answer(message, self.strings("args_incorrect", message))
-
-    async def load_repo(self, git_api):
-        req = await utils.run_sync(requests.get, git_api)
-
-        if req.status_code != 200:
-            return False
-
-        files = req.json()
-
-        if not isinstance(files, list):
-            return False
-
-        await asyncio.gather(
-            *[
-                self.download_and_install(f["download_url"])
-                for f in filter(
-                    lambda f: f["name"].endswith(".py") and f["type"] == "file", files
-                )
-            ]
-        )
         return True
 
     @loader.owner
@@ -605,12 +666,10 @@ class LoaderMod(loader.Module):
         without_prefix = []
 
         for mod in worked:
-            if not mod.startswith("friendly-telegram.modules.") or not mod:
+            if not mod.startswith("hikka.modules.") or not mod:
                 raise Exception("Assertion error")
 
-            without_prefix += [
-                unescape_percent(mod[len("friendly-telegram.modules.") :])
-            ]
+            without_prefix += [unescape_percent(mod[len("hikka.modules.") :])]
 
         it = set(self._db.get(__name__, "loaded_modules", [])).difference(
             without_prefix
@@ -620,14 +679,21 @@ class LoaderMod(loader.Module):
         self._db.set(__name__, "unloaded_modules", list(it))
 
         await utils.answer(
-            message, self.strings("unloaded" if worked else "not_unloaded", message)
+            message,
+            self.strings("unloaded" if worked else "not_unloaded", message),
         )
 
+    def _mod_get(self, *args, mod: str = None) -> Any:
+        return self._db.get(mod, *args)
+
+    def _mod_set(self, *args, mod: str = None) -> bool:
+        return self._db.set(mod, *args)
+
     @loader.owner
     async def clearmodulescmd(self, message: Message) -> None:
         """Delete all installed modules"""
-        self._db.set("friendly-telegram.modules.loader", "loaded_modules", [])
-        self._db.set("friendly-telegram.modules.loader", "unloaded_modules", [])
+        self._db.set("hikka.modules.loader", "loaded_modules", [])
+        self._db.set("hikka.modules.loader", "unloaded_modules", [])
 
         await utils.answer(message, self.strings("all_modules_deleted", message))
 
@@ -648,25 +714,3 @@ class LoaderMod(loader.Module):
         self._db = db
         self._client = client
         await self._update_modules()
-
-
-def get_module(module):
-    name = module.name
-    sysmod = sys.modules.get(module.__module__)
-    origin = sysmod.__spec__.origin
-    loader_ = sysmod.__loader__
-    cname = type(loader_).__name__
-    r = [name, None, None]
-
-    if cname == "SourceFileLoader":
-        r[1] = "path"
-        r[2] = loader_.get_filename()
-    elif cname == "StringLoader":
-        if origin == "<string>":
-            r[1] = "text"
-            r[2] = loader_.data
-        else:
-            r[1] = "link"
-            r[2] = origin
-
-    return r
diff --git a/friendly-telegram/modules/nocollisions.py b/hikka/modules/nocollisions.py
similarity index 96%
rename from friendly-telegram/modules/nocollisions.py
rename to hikka/modules/nocollisions.py
index b616a2f..a55054f 100755
--- a/friendly-telegram/modules/nocollisions.py
+++ b/hikka/modules/nocollisions.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,8 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
 import asyncio
 import logging
 
diff --git a/hikka/modules/okteto.py b/hikka/modules/okteto.py
new file mode 100644
index 0000000..05c9b5a
--- /dev/null
+++ b/hikka/modules/okteto.py
@@ -0,0 +1,85 @@
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+from .. import loader
+import logging
+import asyncio
+import os
+import time
+from telethon.tl.functions.messages import GetScheduledHistoryRequest
+
+logger = logging.getLogger(__name__)
+
+
+@loader.tds
+class OktetoMod(loader.Module):
+    """Stuff related to Hikka Okteto cloud installation"""
+
+    strings = {"name": "Okteto"}
+
+    async def client_ready(self, client, db) -> None:
+        if "OKTETO" not in os.environ:
+            raise loader.LoadError(
+                "This module can be loaded only if userbot is installed to ‚òÅÔ∏è Okteto"
+            )
+
+        self._db = db
+        self._client = client
+        self._env_wait_interval = 10
+        self._overall_polling_interval = 60 * 60
+        self._plan = 3 * 24 * 60 * 60
+        self._messages_interval = 60 * 60
+        self._exception_timeout = 10
+        self._send_interval = 5
+        self._bot = "@WebpageBot"
+        self._task = asyncio.ensure_future(self._okteto_poller())
+
+    async def on_unload(self) -> None:
+        self._task.cancel()
+
+    async def _okteto_poller(self) -> None:
+        """Creates queue to Webpage bot to reset Okteto polling after app goes to sleep"""
+        while True:
+            try:
+                if "OKTETO_URI" not in os.environ:
+                    await asyncio.sleep(self._env_wait_interval)
+                    continue
+
+                uri = os.environ["OKTETO_URI"]
+                current_queue = (
+                    await self._client(
+                        GetScheduledHistoryRequest(
+                            peer=self._bot,
+                            hash=0,
+                        ),
+                    )
+                ).messages
+
+                try:
+                    last_date = max(
+                        time.mktime(m.date.timetuple()) for m in current_queue
+                    )
+                except ValueError:
+                    last_date = time.time()
+
+                while last_date < time.time() + self._plan:
+                    last_date += self._messages_interval
+                    await self._client.send_message(
+                        self._bot,
+                        uri,
+                        schedule=last_date,
+                    )
+                    logger.debug(f"Scheduled Okteto pinger to {last_date}")
+                    await asyncio.sleep(self._send_interval)
+
+                await asyncio.sleep(self._overall_polling_interval)
+            except Exception:
+                logger.exception("Caught exception on Okteto poller")
+                await asyncio.sleep(self._exception_timeout)
diff --git a/friendly-telegram/modules/python.py b/hikka/modules/python.py
similarity index 88%
rename from friendly-telegram/modules/python.py
rename to hikka/modules/python.py
index 56274e4..d2b1bde 100755
--- a/friendly-telegram/modules/python.py
+++ b/hikka/modules/python.py
@@ -1,10 +1,12 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import logging
 import telethon
@@ -37,7 +39,7 @@ class PythonMod(loader.Module):
         "name": "Python",
         "eval": "<b>üé¨ Code:</b>\n<code>{}</code>\n<b>ü™Ñ Result:</b>\n<code>{}</code>",
         "err": "<b>üé¨ Code:</b>\n<code>{}</code>\n\n<b>üö´ Error:</b>\n<code>{}</code>",
-        "db_permission": "‚ö†Ô∏è <b>Do not use </b><code>db.set</code><b>, </b><code>db.get</code><b> and other db operations. You have core modules to control anything you want</b>\n\n<i>Theses commands may <b><u>crash</u></b> your userbot or even make it <b><u>unusable</u></b>! Do it on your own risk</i>\n\n<i>If you issue any errors after allowing this option, <b><u>you will not get any help in support chat</u></b>!</i>"
+        "db_permission": "‚ö†Ô∏è <b>Do not use </b><code>db.set</code><b>, </b><code>db.get</code><b> and other db operations. You have core modules to control anything you want</b>\n\n<i>Theses commands may <b><u>crash</u></b> your userbot or even make it <b><u>unusable</u></b>! Do it on your own risk</i>\n\n<i>If you issue any errors after allowing this option, <b><u>you will not get any help in support chat</u></b>!</i>",
     }
 
     async def client_ready(self, client, db):
@@ -79,7 +81,7 @@ class PythonMod(loader.Module):
             )
         except FakeDbException:
             await self.inline.form(
-                self.strings('db_permission'),
+                self.strings("db_permission"),
                 message=message,
                 reply_markup=[
                     [
@@ -87,12 +89,9 @@ class PythonMod(loader.Module):
                             "text": "‚úÖ Allow",
                             "callback": self.inline__allow,
                         },
-                        {
-                            "text": "üö´ Cancel",
-                            "callback": self.inline__close
-                        }
+                        {"text": "üö´ Cancel", "callback": self.inline__close},
                     ]
-                ]
+                ],
             )
             return
         except Exception:
@@ -131,17 +130,18 @@ class PythonMod(loader.Module):
                 "f": telethon.tl.functions,
                 "c": self._client,
                 "m": message,
-                "loader": loader,
                 "lookup": self.lookup,
                 "self": self,
             },
             **(
                 {
                     "db": self._db,
-                } if self._db.get(main.__name__, "enable_db_eval", False) else {
+                }
+                if self._db.get(main.__name__, "enable_db_eval", False)
+                else {
                     "db": FakeDb(),
                 }
-            )
+            ),
         }
 
     def get_sub(self, it, _depth: int = 1) -> dict:
diff --git a/hikka/modules/quickstart.py b/hikka/modules/quickstart.py
new file mode 100644
index 0000000..ad701aa
--- /dev/null
+++ b/hikka/modules/quickstart.py
@@ -0,0 +1,120 @@
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+from .. import loader
+import logging
+from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
+from random import choice
+
+logger = logging.getLogger(__name__)
+imgs = [
+    "https://pa1.narvii.com/6644/16e88ec137d2ad2583937e7909b6a166c70f3f2a_hq.gif",
+    "https://c.tenor.com/O3qIam1dAQQAAAAC/hug-cuddle.gif",
+    "https://pa1.narvii.com/6853/8efac13a077dac28e6a500a5dd2a7f97dec668fd_hq.gif",
+    "https://static.tumblr.com/ef1af4bfc7f5a5be30a24539d536e1ce/cehtffd/k3Hpiifhs/tumblr_static_tumblr_static__focused_v3.gif",
+    "https://i.gifer.com/W9IO.gif",
+    "https://c.tenor.com/6w7XKLSqFEUAAAAC/anime-hug.gif",
+    "https://i2.wp.com/metanorn.net/wp-content/uploads/2011/08/NS3-04b.gif",
+]
+
+
+@loader.tds
+class QuickstartMod(loader.Module):
+    """Notifies user about userbot installation"""
+
+    strings = {
+        "name": "Quickstart",
+        "quickstart": "üë©‚Äçüé§üá¨üáß <b>Hello.</b> You've just installed <b>Hikka</b> userbot.\n\n‚ùì <b>Need help?</b> Feel free to join our support chat. We help <b>everyone</b>.\n\nüìº <b>Official modules sources: </b>\n‚ñ´Ô∏è @hikarimods\n‚ñ´Ô∏è @hikarimods_database\n‚ñ´Ô∏è <code>.dlmod</code>",
+        "quickstart_ru": "üë©‚Äçüé§üá∑üá∫ <b>–ü—Ä–∏–≤–µ—Ç.</b> –¢–≤–æ–π —é–∑–µ—Ä–±–æ—Ç <b>Hikka</b> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.\n\n‚ùì <b>–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å?</b> –í—Å—Ç—É–ø–∞–π –≤ –Ω–∞—à —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏. –ú—ã –ø–æ–º–æ–≥–∞–µ–º <b>–≤—Å–µ–º</b>\n\nüìº <b>–û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –º–æ–¥—É–ª–µ–π: </b>\n‚ñ´Ô∏è @hikarimods\n‚ñ´Ô∏è @hikarimods_database\n‚ñ´Ô∏è <code>.dlmod</code>",
+    }
+
+    def get(self, *args) -> dict:
+        return self._db.get(self.strings["name"], *args)
+
+    def set(self, *args) -> None:
+        return self._db.set(self.strings["name"], *args)
+
+    async def client_ready(self, client, db) -> None:
+        self._me = (await client.get_me()).id
+
+        mark = InlineKeyboardMarkup()
+        mark.add(
+            InlineKeyboardButton(
+                "ü•∑ Support chat",
+                url="https://t.me/hikka_talks",
+            ),
+        )
+
+        mark.add(
+            InlineKeyboardButton(
+                "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
+                callback_data="hikka_qs_sw_lng_ru",
+            ),
+        )
+
+        await self.inline.bot.send_animation(
+            self._me,
+            animation=choice(imgs),
+            caption=self.strings("quickstart"),
+            parse_mode="HTML",
+            reply_markup=mark,
+        )
+
+        db.set("hikka", "disable_quickstart", True)
+
+    async def quickstart_callback_handler(self, call: CallbackQuery) -> None:
+        if not call.data.startswith("hikka_qs_sw_lng_"):
+            return
+
+        lang = call.data.split("_")[-1]
+        if lang == "ru":
+            mark = InlineKeyboardMarkup()
+            mark.add(
+                InlineKeyboardButton(
+                    "ü•∑ –ß–∞—Ç –ø–æ–º–æ—â–∏",
+                    url="https://t.me/hikka_talks",
+                ),
+            )
+            mark.add(
+                InlineKeyboardButton(
+                    "üá¨üáß English",
+                    callback_data="hikka_qs_sw_lng_en",
+                ),
+            )
+
+            await self.inline.bot.edit_message_caption(
+                chat_id=call.message.chat.id,
+                message_id=call.message.message_id,
+                caption=self.strings("quickstart_ru"),
+                parse_mode="HTML",
+                reply_markup=mark,
+            )
+        elif lang == "en":
+            mark = InlineKeyboardMarkup()
+            mark.add(
+                InlineKeyboardButton(
+                    "ü•∑ Support chat",
+                    url="https://t.me/hikka_talks",
+                ),
+            )
+            mark.add(
+                InlineKeyboardButton(
+                    "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
+                    callback_data="hikka_qs_sw_lng_ru",
+                ),
+            )
+
+            await self.inline.bot.edit_message_caption(
+                chat_id=call.message.chat.id,
+                message_id=call.message.message_id,
+                caption=self.strings("quickstart"),
+                parse_mode="HTML",
+                reply_markup=mark,
+            )
diff --git a/friendly-telegram/modules/raphielgang_config.py b/hikka/modules/raphielgang_config.py
similarity index 95%
rename from friendly-telegram/modules/raphielgang_config.py
rename to hikka/modules/raphielgang_config.py
index 1657a8c..b4ad3ae 100755
--- a/friendly-telegram/modules/raphielgang_config.py
+++ b/hikka/modules/raphielgang_config.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,8 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
 import itertools
 import logging
 
diff --git a/friendly-telegram/modules/test.py b/hikka/modules/test.py
similarity index 89%
rename from friendly-telegram/modules/test.py
rename to hikka/modules/test.py
index 69f37ee..d11e29d 100755
--- a/friendly-telegram/modules/test.py
+++ b/hikka/modules/test.py
@@ -1,19 +1,21 @@
-"""
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
-"""
-
-# scope: inline_content
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
+
+# scope: inline
 
 import time
 
 import logging
 from io import BytesIO
 
-from .. import loader, utils
+from .. import loader, utils, main
 
 from typing import Union
 from telethon.tl.types import Message
@@ -33,8 +35,8 @@ class TestMod(loader.Module):
         "name": "Tester",
         "set_loglevel": "üö´ <b>Please specify verbosity as an integer or string</b>",
         "no_logs": "‚ÑπÔ∏è <b>You don't have any logs at verbosity {}.</b>",
-        "logs_filename": "geektg-logs.txt",
-        "logs_caption": "üóû GeekTG logs with verbosity {}",
+        "logs_filename": "hikka-logs.txt",
+        "logs_caption": "üè© <b>Hikka logs with verbosity </b><code>{}</code>\n\nüë©‚Äçüé§ <b>Hikka version: {}.{}.{}</b>\n‚è± <b>Uptime: {}</b>\n<b>{}</b>",
         "suspend_invalid_time": "üö´ <b>Invalid time to suspend</b>",
         "suspended": "ü•∂ <b>Bot suspended for</b> <code>{}</code> <b>seconds</b>",
         "results_ping": "‚è± <b>Ping:</b> <code>{}</code> <b>ms</b>",
@@ -188,22 +190,24 @@ class TestMod(loader.Module):
         logs = BytesIO(logs)
         logs.name = self.strings("logs_filename")
 
+        other = (*main.__version__, utils.formatted_uptime(), utils.get_named_platform())
+
         if isinstance(message, Message):
+            await message.delete()
             await utils.answer(
-                message, logs, caption=self.strings("logs_caption").format(named_lvl)
+                message, logs, caption=self.strings("logs_caption").format(named_lvl, *other)
             )
         else:
             await message.delete()
             await self._client.send_file(
                 message.form["chat"],
                 logs,
-                caption=self.strings("logs_caption").format(named_lvl),
+                caption=self.strings("logs_caption").format(named_lvl, *other),
             )
 
     @loader.owner
     async def suspendcmd(self, message: Message) -> None:
-        """.suspend <time>
-        Suspends the bot for N seconds"""
+        """<time> - Suspends the bot for N seconds"""
         try:
             time_sleep = float(utils.get_args_raw(message))
             await utils.answer(
@@ -216,7 +220,7 @@ class TestMod(loader.Module):
     async def pingcmd(self, message: Message) -> None:
         """Test your userbot ping"""
         start = time.perf_counter_ns()
-        message = await utils.answer(message, "<code>Ping checking...</code>")
+        message = await utils.answer(message, "<code>üêª Bear with us while ping is checking...</code>")
         end = time.perf_counter_ns()
 
         if isinstance(message, (list, tuple, set)):
diff --git a/friendly-telegram/modules/uniborg_config.py b/hikka/modules/uniborg_config.py
similarity index 95%
rename from friendly-telegram/modules/uniborg_config.py
rename to hikka/modules/uniborg_config.py
index ba7a8db..9ef4a9e 100755
--- a/friendly-telegram/modules/uniborg_config.py
+++ b/hikka/modules/uniborg_config.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,8 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
 import itertools
 import logging
 
diff --git a/friendly-telegram/modules/updater.py b/hikka/modules/updater.py
similarity index 72%
rename from friendly-telegram/modules/updater.py
rename to hikka/modules/updater.py
index bdd8095..2f00187 100755
--- a/friendly-telegram/modules/updater.py
+++ b/hikka/modules/updater.py
@@ -1,5 +1,5 @@
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,7 +14,15 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import asyncio
 import atexit
@@ -45,29 +53,21 @@ class UpdaterMod(loader.Module):
         "restarting_caption": "üîÑ <b>Restarting...</b>",
         "downloading": "üîÑ <b>Downloading updates...</b>",
         "downloaded": "‚úÖ <b>Downloaded successfully.\nPlease type</b> \n<code>.restart</code> <b>to restart the bot.</b>",
-        "already_updated": "‚úÖ <b>Already up to date!</b>",
         "installing": "üîÅ <b>Installing updates...</b>",
         "success": "‚úÖ <b>Restart successful!</b>",
-        "heroku_warning": "‚ö†Ô∏è <b>Heroku API key has not been set. </b>Update was successful but updates will reset every time the bot restarts.",
         "origin_cfg_doc": "Git origin URL, for where to update from",
-        "lavhost": "üîÑ <b>Restart initiated, and will be complete in 3-5 seconds.</b>\n<i>This message <b>will not</b> be edited after restart is complete!</i>",
     }
 
     def __init__(self):
         self.config = loader.ModuleConfig(
             "GIT_ORIGIN_URL",
-            "https://github.com/GeekTG/Friendly-Telegram",
+            "https://github.com/hikariatama/Hikka",
             lambda m: self.strings("origin_cfg_doc", m),
         )
 
     @loader.owner
     async def restartcmd(self, message: Message) -> None:
         """Restarts the userbot"""
-        if os.environ.get("LAVHOST"):
-            await utils.answer(message, self.strings("lavhost"))
-            await self._client.send_message("@lavhostbot", "/restart")
-            return
-
         msg = (
             await utils.answer(message, self.strings("restarting_caption", message))
         )[0]
@@ -77,17 +77,17 @@ class UpdaterMod(loader.Module):
         logger.debug(f"Self-update. {sys.executable} -m {utils.get_base_dir()}")
 
         check = str(uuid.uuid4())
-        await self._db.set(__name__, "selfupdatecheck", check)
+        self._db.set(__name__, "selfupdatecheck", check)
         await asyncio.sleep(3)
         if self._db.get(__name__, "selfupdatecheck", "") != check:
             raise ValueError("An update is already in progress!")
         self._db.set(__name__, "selfupdatechat", utils.get_chat_id(message))
-        await self._db.set(__name__, "selfupdatemsg", message.id)
+        self._db.set(__name__, "selfupdatemsg", message.id)
 
     async def restart_common(self, message: Message) -> None:
         await self.prerestart_common(message)
         atexit.register(functools.partial(restart, *sys.argv[1:]))
-        [handler] = logging.getLogger().handlers
+        handler = logging.getLogger().handlers[0]
         handler.setLevel(logging.CRITICAL)
         for client in self.allclients:
             # Terminate main loop of all running clients
@@ -122,9 +122,7 @@ class UpdaterMod(loader.Module):
             repo.create_head("master", origin.refs.master)
             repo.heads.master.set_tracking_branch(origin.refs.master)
             repo.heads.master.checkout(True)
-            return (
-                False  # Heroku never needs to install dependencies because we redeploy
-            )
+            return False
 
     @staticmethod
     def req_common() -> None:
@@ -151,11 +149,6 @@ class UpdaterMod(loader.Module):
     @loader.owner
     async def updatecmd(self, message: Message, hard: bool = False) -> None:
         """Downloads userbot updates"""
-        if os.environ.get("LAVHOST"):
-            await utils.answer(message, self.strings("lavhost"))
-            await self._client.send_message("@lavhostbot", "/update")
-            return
-
         # We don't really care about asyncio at this point, as we are shutting down
         if hard:
             os.system(f"cd {utils.get_base_dir()} && cd .. && git reset --hard HEAD")  # skipcq: BAN-B605
@@ -175,23 +168,16 @@ class UpdaterMod(loader.Module):
             except telethon.errors.rpcerrorlist.MessageNotModifiedError:
                 pass
 
-            if heroku_key := os.environ.get("heroku_api_token"):
-                from .. import heroku
-
-                await self.prerestart_common(message)
-                heroku.publish(self.allclients, heroku_key)
-                # If we pushed, this won't return. If the push failed, we will get thrown at.
-                # So this only happens when remote is already up to date (remote is heroku, where we are running)
-                self._db.set(__name__, "selfupdatechat", None)
-                self._db.set(__name__, "selfupdatemsg", None)
-
-                await utils.answer(message, self.strings("already_updated", message))
-            else:
-                if req_update:
-                    self.req_common()
-                await self.restart_common(message)
+            if req_update:
+                self.req_common()
+            await self.restart_common(message)
         except GitCommandError:
-            await self.updatecmd(message, True)
+            if not hard:
+                await self.updatecmd(message, True)
+                return
+
+            logger.critical("Got update loop. Update manually via .terminal")
+            return
 
     @loader.unrestricted
     async def sourcecmd(self, message: Message) -> None:
@@ -220,15 +206,7 @@ class UpdaterMod(loader.Module):
 
     async def update_complete(self, client):
         logger.debug("Self update successful! Edit message")
-        heroku_key = os.environ.get("heroku_api_token")
-        herokufail = ("DYNO" in os.environ) and (heroku_key is None)
-
-        if herokufail:
-            logger.warning("heroku token not set")
-            msg = self.strings("heroku_warning")
-        else:
-            logger.debug("Self update successful! Edit message")
-            msg = self.strings("success")
+        msg = self.strings("success")
 
         await client.edit_message(
             self._db.get(__name__, "selfupdatechat"),
@@ -238,10 +216,10 @@ class UpdaterMod(loader.Module):
 
 
 def restart(*argv):
-    os.execl(  # skipcq: BAN-B606
-        sys.executable,  # skipcq: BAN-B606
-        sys.executable,  # skipcq: BAN-B606
-        "-m",  # skipcq: BAN-B606
-        os.path.relpath(utils.get_base_dir()),  # skipcq: BAN-B606
-        *argv,  # skipcq: BAN-B606
-    )  # skipcq: BAN-B606
+    os.execl(
+        sys.executable,
+        sys.executable,
+        "-m",
+        os.path.relpath(utils.get_base_dir()),
+        *argv,
+    )
diff --git a/friendly-telegram/security.py b/hikka/security.py
similarity index 62%
rename from friendly-telegram/security.py
rename to hikka/security.py
index cc87345..002f709 100755
--- a/friendly-telegram/security.py
+++ b/hikka/security.py
@@ -1,5 +1,7 @@
+"""Checks the commands' security"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,13 +16,19 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import logging
-
-import telethon
-from telethon.tl.functions.channels import GetParticipantRequest
-from telethon.tl.functions.messages import GetFullChatRequest
+from telethon.tl.types import Message
+from types import FunctionType
 
 from . import main
 
@@ -175,13 +183,31 @@ class SecurityManager:
 
         return config & self._db.get(__name__, "bounding_mask", DEFAULT_PERMISSIONS)
 
-    async def _check(self, message, func):
+    async def _check(
+        self,
+        message: Message,
+        func: FunctionType,
+        user: int = None,
+    ) -> bool:
+        """Checks if message sender is permitted to execute certain function"""
         self._reload_rights()
+
         config = self.get_flags(func)
 
-        if not config:  # Either False or 0, either way we can failfast
+        if not config:
             return False
 
+        if not user:
+            user = message.sender_id
+            check_message = True
+        else:
+            check_message = False
+
+        if check_message and message.out:
+            # If message was sent from the account, where
+            # userbot is installed, skip security check
+            return True
+
         logger.debug("Checking security match for %d", config)
 
         f_owner = config & OWNER
@@ -208,22 +234,20 @@ class SecurityManager:
             or f_group_admin
         )
 
-        if f_owner and message.sender_id in self._owner + [self._me]:
-            return True
-
-        if f_sudo and message.sender_id in self._sudo:
-            return True
-
-        if f_support and message.sender_id in self._support:
+        if (
+            f_owner
+            and user in self._owner
+            or f_sudo
+            and user in self._sudo
+            or f_support
+            and user in self._support
+        ):
             return True
 
-        if message.sender_id in self._db.get(main.__name__, "blacklist_users", []):
+        if user in self._db.get(main.__name__, "blacklist_users", []):
             return False
 
-        if f_pm and message.is_private:
-            return True
-
-        if f_group_member and message.is_group:
+        if f_group_member and message.is_group or f_pm and message.is_private:
             return True
 
         if message.is_channel:
@@ -233,91 +257,60 @@ class SecurityManager:
 
                 chat = await message.get_chat()
 
-                if not chat.creator and not (
-                    chat.admin_rights and chat.admin_rights.post_messages
+                if (
+                    not chat.creator
+                    and not chat.admin_rights
+                    or not chat.creator
+                    and not chat.admin_rights.post_messages
                 ):
                     return False
 
-                if self._any_admin and f_group_admin_any:
-                    return True
-
-                if f_group_admin:
+                if self._any_admin and f_group_admin_any or f_group_admin:
                     return True
-            else:
-                if f_group_admin_any or f_group_owner:
-                    participant = await message.client(
-                        GetParticipantRequest(
-                            await message.get_input_chat(),
-                            await message.get_input_sender(),
-                        )
-                    )
-                    participant = participant.participant
-
-                    if isinstance(
-                        participant, telethon.types.ChannelParticipantCreator
-                    ):
-                        return True
-
-                    if isinstance(participant, telethon.types.ChannelParticipantAdmin):
-                        if self._any_admin and f_group_admin_any:
-                            return True
-                        rights = participant.admin_rights
-
-                        if (
-                            f_group_admin
-                            or f_group_admin_add_admins
-                            and rights.add_admins
-                            or f_group_admin_change_info
-                            and rights.change_info
-                            or f_group_admin_ban_users
-                            and rights.ban_users
-                            or f_group_admin_delete_messages
-                            and rights.delete_messages
-                            or f_group_admin_pin_messages
-                            and rights.pin_messages
-                            or f_group_admin_invite_users
-                            and rights.invite_users
-                        ):
-                            return True
-
-                chat = await message.get_chat()
+            elif f_group_admin_any or f_group_owner:
+                participant = await message.client.get_permissions(
+                    message.peer_id,
+                    user,
+                )
 
-            if message.out:
-                if chat.creator and f_group_owner:
+                if participant.is_creator:
                     return True
-                me_id = (await message.client.get_me(True)).user_id
 
-                if (
-                    f_owner
-                    and me_id in self._owner
-                    or f_sudo
-                    and me_id in self._sudo
-                    or f_support
-                    and me_id in self._support
-                ):
-                    return True
+                if participant.is_admin:
+                    if self._any_admin and f_group_admin_any:
+                        return True
 
-        elif message.is_group:
-            if f_group_admin_any or f_group_owner:
-                full_chat = await message.client(GetFullChatRequest(message.chat_id))
-                participants = full_chat.full_chat.participants.participants
-                participant = next(
-                    (
-                        possible_participant
-                        for possible_participant in participants
-                        if possible_participant.user_id == message.sender_id
-                    ),
-                    None,
-                )
+                    if (
+                        f_group_admin
+                        or f_group_admin_add_admins
+                        and participant.add_admins
+                        or f_group_admin_change_info
+                        and participant.change_info
+                        or f_group_admin_ban_users
+                        and participant.ban_users
+                        or f_group_admin_delete_messages
+                        and participant.delete_messages
+                        or f_group_admin_pin_messages
+                        and participant.pin_messages
+                        or f_group_admin_invite_users
+                        and participant.invite_users
+                    ):
+                        return True
+            return False
 
-                if not participant:
-                    return
+        if message.is_group:
+            participant = await message.client.get_permissions(
+                message.peer_id,
+                user,
+            )
 
-                if isinstance(participant, telethon.types.ChatParticipantCreator):
-                    return True
+            if not participant:
+                return False
 
             if (
-                isinstance(participant, telethon.types.ChatParticipantAdmin)
+                (f_group_admin_any or f_group_owner)
+                and participant.is_creator
+                or participant.is_admin
                 and f_group_admin_any
             ):
                 return True
diff --git a/hikka/translations/core.py b/hikka/translations/core.py
new file mode 100755
index 0000000..f4fefa0
--- /dev/null
+++ b/hikka/translations/core.py
@@ -0,0 +1,91 @@
+#    Friendly Telegram (telegram userbot)
+#    Copyright (C) 2018-2021 The Authors
+
+#    This program is free software: you can redistribute it and/or modify
+#    it under the terms of the GNU Affero General Public License as published by
+#    the Free Software Foundation, either version 3 of the License, or
+#    (at your option) any later version.
+
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU Affero General Public License for more details.
+
+#    You should have received a copy of the GNU Affero General Public License
+#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+import json
+import logging
+
+import telethon
+from babel import negotiate_locale
+from telethon.tl.types import MessageEntityHashtag
+
+logger = logging.getLogger(__name__)
+
+MAGIC = "#hikka_translate_pack"
+
+
+class Translator:
+    def __init__(self, packs, languages, data_root):
+        self._packs = packs
+        self._languages = languages
+        self._data_root = data_root
+
+    async def init(self, client):
+        self._data = {}
+        for pack in self._packs:
+            try:
+                [message] = await client.get_messages(pack, 1)
+            except (ValueError, telethon.errors.rpcerrorlist.ChannelPrivateError):
+                # We can't access the channel
+                logger.warning(
+                    "No translation pack found for %r", pack, exc_info=True
+                )
+                continue
+            if not message.document or not message.entities:
+                logger.info(
+                    "Last message in translation pack %r has no document/entities",
+                    pack,
+                )
+                continue
+            found = False
+            for ent in filter(
+                lambda x: isinstance(x, MessageEntityHashtag), message.entities
+            ):
+                if (
+                    message.message[ent.offset : ent.offset + ent.length] == MAGIC
+                    and message.file
+                ):
+                    logger.debug("Got translation message")
+                    found = True
+                    break
+            if not found:
+                logger.info("Didn't find translation hashtags")
+                continue
+            try:
+                ndata = json.loads(
+                    (await message.download_media(bytes)).decode("utf-8")
+                )
+            except (json.decoder.JSONDecodeError, UnicodeDecodeError):
+                logger.exception("Unable to decode %s", pack)
+                continue
+            try:
+                self._data.setdefault(ndata["language"], {}).update(ndata["data"])
+            except KeyError:
+                logger.exception("Translation pack follows wrong format")
+
+    def set_preferred_languages(self, languages):
+        self._languages = languages
+
+    def getkey(self, key, lang_code=None):
+        locales = []
+        for locale, strings in self._data.items():
+            if key in strings:
+                locales += [locale]
+        target_locales = [lang_code] if lang_code else self._languages
+        locale = negotiate_locale(target_locales, locales)
+        return self._data.get(locale, {}).get(key, False)
+
+    def gettext(self, english_text):
+        return self.getkey(english_text) or english_text
diff --git a/friendly-telegram/translations/dynamic.py b/hikka/translations/dynamic.py
similarity index 91%
rename from friendly-telegram/translations/dynamic.py
rename to hikka/translations/dynamic.py
index 9f734bd..c6caa32 100755
--- a/friendly-telegram/translations/dynamic.py
+++ b/hikka/translations/dynamic.py
@@ -14,9 +14,6 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Friendly Telegram Userbot
-#    by GeekTG Team
-
 
 class Strings:
     def __init__(self, prefix, strings, babel):
@@ -25,7 +22,7 @@ class Strings:
         self._babel = babel
 
     def __getitem__(self, key):
-        return self._babel.getkey(self._prefix + key) or self._strings[key]
+        return self._babel.getkey(f"{self._prefix}{key}") or self._strings[key]
 
     def __call__(self, key, message=None):
         if isinstance(message, str):
diff --git a/hikka/types.py b/hikka/types.py
new file mode 100644
index 0000000..cde5ae6
--- /dev/null
+++ b/hikka/types.py
@@ -0,0 +1,66 @@
+import logging
+
+
+class Module:
+    strings = {"name": "Unknown"}
+
+    """There is no help for this module"""
+
+    def config_complete(self):
+        """Will be called when module.config is populated"""
+
+    async def client_ready(self, client, db):
+        """Will be called after client is ready (after config_loaded)"""
+
+    async def on_unload(self):
+        """Will be called after unloading / reloading module"""
+
+    # Called after client_ready, for internal use only. Must not be used by non-core modules
+    async def _client_ready2(self, client, db):
+        pass
+
+
+class LoadError(Exception):
+    def __init__(self, error_message):  # skipcq: PYL-W0231
+        self._error = error_message
+
+    def __str__(self) -> str:
+        return self._error
+
+
+class ModuleConfig(dict):
+    """Like a dict but contains doc for each key"""
+
+    def __init__(self, *entries):
+        keys = []
+        values = []
+        defaults = []
+        docstrings = []
+        for i, entry in enumerate(entries):
+            if i % 3 == 0:
+                keys.append(entry)
+            elif i % 3 == 1:
+                values.append(entry)
+                defaults.append(entry)
+            else:
+                docstrings.append(entry)
+
+        super().__init__(zip(keys, values))
+        self._docstrings = dict(zip(keys, docstrings))
+        self._defaults = dict(zip(keys, defaults))
+
+    def getdoc(self, key, message=None):
+        """Get the documentation by key"""
+        ret = self._docstrings[key]
+        if callable(ret):
+            try:
+                ret = ret(message)
+            except TypeError:  # Invalid number of params
+                logging.debug("%s using legacy doc trnsl", key)
+                ret = ret()
+
+        return ret
+
+    def getdef(self, key):
+        """Get the default value by key"""
+        return self._defaults[key]
diff --git a/friendly-telegram/utils.py b/hikka/utils.py
similarity index 53%
rename from friendly-telegram/utils.py
rename to hikka/utils.py
index 2ebc04d..cd4354b 100755
--- a/friendly-telegram/utils.py
+++ b/hikka/utils.py
@@ -1,5 +1,7 @@
+"""Utilities"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,9 +16,15 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
-
-"""Utility functions to help modules do stuff"""
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import asyncio
 import functools
@@ -24,6 +32,8 @@ import io
 import logging
 import os
 import shlex
+import time
+from datetime import timedelta
 
 import telethon
 from telethon.tl.custom.message import Message
@@ -34,12 +44,24 @@ from telethon.tl.types import (
     MessageEntityMentionName,
     User,
     MessageMediaWebPage,
+    Channel,
+    Chat,
 )
 
+from aiogram.types import CallbackQuery
+
+from .inline.types import InlineCall
+
+import random
+
+from typing import Tuple, Union, List, Any
+
+from telethon.tl.functions.channels import CreateChannelRequest
+
 from . import __main__
 
 
-def get_args(message):
+def get_args(message: Message) -> List[str]:
     """Get arguments from message (str or Message), return list of arguments"""
     try:
         message = message.message
@@ -64,7 +86,7 @@ def get_args(message):
     return list(filter(lambda x: len(x) > 0, split))
 
 
-def get_args_raw(message):
+def get_args_raw(message: Message) -> str:
     """Get the parameters to the command as a raw string (not split)"""
     try:
         message = message.message
@@ -82,44 +104,46 @@ def get_args_raw(message):
     return ""
 
 
-def get_args_split_by(message, sep):
-    """Split args with a specific sep"""
+def get_args_split_by(message: Message, separator: str) -> List[str]:
+    """Split args with a specific separator"""
     raw = get_args_raw(message)
-    mess = raw.split(sep)
+    mess = raw.split(separator)
 
     return [section.strip() for section in mess if section]
 
 
-def get_chat_id(message):
+def get_chat_id(message: Message) -> int:
     """Get the chat ID, but without -100 if its a channel"""
     return telethon.utils.resolve_id(message.chat_id)[0]
 
 
-def get_entity_id(entity):
+def get_entity_id(
+    entity: Union[Chat, User, Channel, PeerChat, PeerChat, PeerChannel]
+) -> int:
     return telethon.utils.get_peer_id(entity)
 
 
-def escape_html(text):
+def escape_html(text: str) -> str:
     """Pass all untrusted/potentially corrupt input here"""
     return str(text).replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
 
 
-def escape_quotes(text):
+def escape_quotes(text: str) -> str:
     """Escape quotes to html quotes"""
     return escape_html(text).replace('"', "&quot;")
 
 
-def get_base_dir():
+def get_base_dir() -> str:
     """Get directory of this file"""
     return get_dir(__main__.__file__)
 
 
-def get_dir(mod):
+def get_dir(mod: str) -> str:
     """Get directory of given module"""
     return os.path.abspath(os.path.dirname(os.path.abspath(mod)))
 
 
-async def get_user(message):
+async def get_user(message: Message) -> Union[None, User]:
     """Get user who sent message, searching if not found easily"""
     try:
         return await message.client.get_entity(message.sender_id)
@@ -135,16 +159,22 @@ async def get_user(message):
         return await message.client.get_entity(message.sender_id)
 
     if isinstance(message.peer_id, (PeerChannel, PeerChat)):
+        try:
+            return await message.client.get_entity(message.sender_id)
+        except Exception:
+            pass
+
         async for user in message.client.iter_participants(
-            message.peer_id, aggressive=True
+            message.peer_id,
+            aggressive=True,
         ):
             if user.id == message.sender_id:
                 return user
 
-        logging.critical("WTF! user isn't in the group where they sent the message")
+        logging.error("User isn't in the group where they sent the message")
         return None
 
-    logging.critical("WTF! `peer_id` is not a user, chat or channel")
+    logging.error("`peer_id` is not a user, chat or channel")
     return None
 
 
@@ -152,7 +182,8 @@ def run_sync(func, *args, **kwargs):
     """Run a non-async function in a new thread and return an awaitable"""
     # Returning a coro
     return asyncio.get_event_loop().run_in_executor(
-        None, functools.partial(func, *args, **kwargs)
+        None,
+        functools.partial(func, *args, **kwargs),
     )
 
 
@@ -163,9 +194,10 @@ def run_async(loop, coro):
 
 
 def censor(
-    obj, to_censor=None, replace_with="redacted_{count}_chars"
-):  # pylint: disable=W0102
-    # Safe to disable W0102 because we don't touch to_censor, mutably or immutably.
+    obj,
+    to_censor=None,
+    replace_with="redacted_{count}_chars",
+):
     """May modify the original object, but don't rely on it"""
     if to_censor is None:
         to_censor = ["phone"]
@@ -179,9 +211,13 @@ def censor(
     return obj
 
 
-def relocate_entities(entities, offset, text=None):
+def relocate_entities(
+    entities: list,
+    offset: int,
+    text: Union[str, None] = None,
+) -> list:
     """Move all entities by offset (truncating at text)"""
-    length = len(text) if text is not None else 0  # TODO: refactor about text=None
+    length = len(text) if text is not None else 0
 
     for ent in entities.copy() if entities else ():
         ent.offset += offset
@@ -196,8 +232,11 @@ def relocate_entities(entities, offset, text=None):
     return entities
 
 
-async def answer(message, response, **kwargs):
+async def answer(message: Union[Message, CallbackQuery], response: str, **kwargs) -> list:
     """Use this to give the response to a command"""
+    if isinstance(message, (CallbackQuery, InlineCall)):
+        return await message.edit(response)
+    
     if isinstance(message, list):
         delete_job = asyncio.ensure_future(
             message[0].client.delete_messages(message[0].input_chat, message[1:])
@@ -206,13 +245,6 @@ async def answer(message, response, **kwargs):
     else:
         delete_job = None
 
-    if (
-        await message.client.is_bot()
-        and isinstance(response, str)
-        and len(response) > 4096
-    ):
-        kwargs.setdefault("asfile", True)
-
     kwargs.setdefault("link_preview", False)
 
     edit = message.out
@@ -220,21 +252,24 @@ async def answer(message, response, **kwargs):
     if not edit:
         kwargs.setdefault(
             "reply_to",
-            getattr(message, 'reply_to_msg_id', None),
+            getattr(message, "reply_to_msg_id", None),
         )
 
     parse_mode = telethon.utils.sanitize_parse_mode(
-        kwargs.pop("parse_mode", message.client.parse_mode)
+        kwargs.pop(
+            "parse_mode",
+            message.client.parse_mode,
+        )
     )
 
     if isinstance(response, str) and not kwargs.pop("asfile", False):
-        txt, ent = parse_mode.parse(response)
+        text, entity = parse_mode.parse(response)
 
-        if len(txt) >= 4096:
-            file = io.BytesIO(txt.encode("utf-8"))
+        if len(text) >= 4096:
+            file = io.BytesIO(text.encode("utf-8"))
             file.name = "command_result.txt"
 
-            ret = [
+            result = [
                 await message.client.send_file(
                     message.peer_id,
                     file,
@@ -245,18 +280,18 @@ async def answer(message, response, **kwargs):
             if message.out:
                 await message.delete()
 
-            return ret
+            return result
 
-        ret = [
+        result = [
             await (message.edit if edit else message.respond)(
-                txt, parse_mode=lambda t: (t, ent), **kwargs
+                text, parse_mode=lambda t: (t, entity), **kwargs
             )
         ]
     elif isinstance(response, Message):
         if message.media is None and (
             response.media is None or isinstance(response.media, MessageMediaWebPage)
         ):
-            ret = (
+            result = (
                 await message.edit(
                     response.message,
                     parse_mode=lambda t: (t, response.entities or []),
@@ -264,7 +299,7 @@ async def answer(message, response, **kwargs):
                 ),
             )
         else:
-            ret = (await message.respond(response, **kwargs),)
+            result = (await message.respond(response, **kwargs),)
     else:
         if isinstance(response, bytes):
             response = io.BytesIO(response)
@@ -280,19 +315,22 @@ async def answer(message, response, **kwargs):
         else:
             kwargs.setdefault(
                 "reply_to",
-                getattr(message, 'reply_to_msg_id', None),
+                getattr(message, "reply_to_msg_id", None),
+            )
+            result = (
+                await message.client.send_file(message.chat_id, response, **kwargs),
             )
-            ret = (await message.client.send_file(message.chat_id, response, **kwargs),)
 
     if delete_job:
         await delete_job
 
-    return ret
+    return result
 
 
-async def get_target(message, arg_no=0):
+async def get_target(message: Message, arg_no: int = 0) -> Union[int, None]:
     if any(
-        isinstance(ent, MessageEntityMentionName) for ent in (message.entities or [])
+        isinstance(entity, MessageEntityMentionName)
+        for entity in (message.entities or [])
     ):
         e = sorted(
             filter(lambda x: isinstance(x, MessageEntityMentionName), message.entities),
@@ -310,15 +348,15 @@ async def get_target(message, arg_no=0):
         return None
 
     try:
-        ent = await message.client.get_entity(user)
+        entity = await message.client.get_entity(user)
     except ValueError:
         return None
     else:
-        if isinstance(ent, User):
-            return ent.id
+        if isinstance(entity, User):
+            return entity.id
 
 
-def merge(a, b):
+def merge(a: dict, b: dict) -> dict:
     """Merge with replace dictionary a to dictionary b"""
     for key in a:
         if key in b:
@@ -332,3 +370,139 @@ def merge(a, b):
         b[key] = a[key]
 
     return b
+
+
+async def asset_channel(
+    client: "TelegramClient",  # noqa: F821
+    title: str,
+    description: str,
+) -> Tuple[Channel, bool]:
+    """
+    Create new channel (if needed) and return its entity
+    @client: Telegram client to create channel by
+    @title: Channel title
+    @description: Description
+    Returns peer and bool: is channel new or pre-existent
+    """
+    async for d in client.iter_dialogs():
+        if d.title == title:
+            return d.entity, False
+
+    return (
+        await client(
+            CreateChannelRequest(
+                title,
+                description,
+                megagroup=True,
+            )
+        )
+    ).chats[0], True
+
+
+def get_link(user: Union[User, Channel]) -> str:
+    """Get telegram permalink to entity"""
+    return (
+        f"tg://user?id={user.id}"
+        if isinstance(user, User)
+        else (
+            f"tg://resolve?domain={user.username}"
+            if getattr(user, "username", None)
+            else ""
+        )
+    )
+
+
+def chunks(_list: Union[list, tuple, set], n: int) -> list:
+    """Split provided `_list` into chunks of `n`"""
+    return [_list[i : i + n] for i in range(0, len(_list), n)]
+
+
+def get_named_platform() -> str:
+    """Returns formatted platform name"""
+    is_termux = bool(os.popen('echo $PREFIX | grep -o "com.termux"').read())
+    is_okteto = "OKTETO" in os.environ
+    is_lavhost = "LAVHOST" in os.environ
+
+    if is_termux:
+        return "üï∂ Termux"
+
+    if is_okteto:
+        return "‚òÅÔ∏è Okteto"
+
+    if is_lavhost:
+        return f"‚úåÔ∏è lavHost {os.environ['LAVHOST']}"
+
+    return "üìª VDS"
+
+
+def uptime() -> int:
+    """Returns userbot uptime in seconds"""
+    return round(time.perf_counter() - init_ts)
+
+
+def formatted_uptime() -> str:
+    """Returnes formmated uptime"""
+    return "{}".format(str(timedelta(seconds=uptime())))
+
+
+def ascii_face() -> str:
+    """Returnes cute ASCII-art face"""
+    return random.choice(
+        [
+            "„ÉΩ(‡πë‚ó†‹´‚ó†‡πë)Ôæâ",
+            "‚òú(‚åí‚ñΩ‚åí)‚òû",
+            "/|\\ ^._.^ /|\\",
+            "(‚óï·¥•‚óï ã)",
+            "·ïô(`‚ñΩ¬¥)·ïó",
+            "(‚òûÔæü‚àÄÔæü)‚òû",
+            "(‚úø‚ó†‚Äø‚ó†)",
+            "(‚ñ∞Àò‚ó°Àò‚ñ∞)",
+            "(Àµ Õ°¬∞ Õú ñ Õ°¬∞Àµ)",
+            " ï„Å£‚Ä¢·¥•‚Ä¢ î„Å£",
+            "( Õ°¬∞ ·¥• Õ°¬∞)",
+            " ï‚ô•·¥•‚ô• î",
+            "\\m/,(> . <)_\\m/",
+            "(‡πë‚Ä¢ÃÅ „ÉÆ ‚Ä¢ÃÄ‡πë)",
+            "Ÿ©(^‚Äø^)€∂",
+            "(„Å£ÀÜ⁄°ÀÜœÇ)",
+            "œà(ÔΩÄ‚àá¬¥)œà",
+            "‚äôœâ‚äô",
+            "Ÿ©(^·¥ó^)€∂",
+            "(¬¥„Éªœâ„Éª)„Å£Áî±",
+            "‚Äª\\(^o^)/‚Äª",
+            "Ÿ©(*‚ùõ‚ä∞‚ùõ)ÔΩû‚ù§",
+            "( Õ°~ Õú ñ Õ°¬∞)",
+            "‚úß‚ô°(‚óï‚Äø‚óï‚úø)",
+            "‡πÇ‡πè‡Ø∞‡πè‡πÉ ‡∏∑",
+            "‚à©ÔΩ°‚Ä¢ ·µï ‚Ä¢ÔΩ°‚à© ‚ô°",
+            "(‚ô°¬¥‡±™`‚ô°)",
+            "(‚óçÔºû‚ó°Ôºú‚óç)‚ãà„ÄÇ‚úß‚ô°",
+            "‚ô•(ÀÜ‚å£ÀÜ‘Ö)",
+            "‚ï∞(‚úø¬¥‚å£`‚úø)‚ïØ‚ô°",
+            " ï‚Ä¢·¥•‚Ä¢ î",
+            "·∂ò ‚óï·¥•‚óï·∂Ö",
+            "‚ñº„Éª·¥•„Éª‚ñº",
+            "„Äê‚âΩ‹´‚âº„Äë",
+            "‡∏Ö^‚Ä¢Ôªå‚Ä¢^‡∏Ö",
+            "(ŒÑ‚óû‡∏¥‡±™‚óü‡∏¥‚Äµ)",
+        ]
+    )
+
+
+def array_sum(array: List[Any]) -> List[Any]:
+    """Performs basic sum operation on array"""
+    result = []
+    for item in array:
+        result += item
+
+    return result
+
+
+def rand(size: int) -> str:
+    """Return random string of len `size`"""
+    return "".join(
+        [random.choice("abcdefghijklmnopqrstuvwxyz1234567890") for _ in range(size)]
+    )
+
+
+init_ts = time.perf_counter()
diff --git a/hikka/version.py b/hikka/version.py
new file mode 100644
index 0000000..6b28a74
--- /dev/null
+++ b/hikka/version.py
@@ -0,0 +1 @@
+__version__ = (1, 0, 15)
diff --git a/friendly-telegram/web/core.py b/hikka/web/core.py
similarity index 78%
rename from friendly-telegram/web/core.py
rename to hikka/web/core.py
index 7f48c81..a11bd6d 100755
--- a/friendly-telegram/web/core.py
+++ b/hikka/web/core.py
@@ -1,5 +1,7 @@
+"""Responsible for web init and mandatory ops"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,7 +16,15 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import asyncio
 import inspect
@@ -24,10 +34,10 @@ import aiohttp_jinja2
 import jinja2
 from aiohttp import web
 
-from . import initial_setup, root
+from . import root
 
 
-class Web(initial_setup.Web, root.Web):
+class Web(root.Web):
     def __init__(self, **kwargs):
         self.runner = None
         self.port = None
@@ -40,8 +50,11 @@ class Web(initial_setup.Web, root.Web):
             filters={"getdoc": inspect.getdoc, "ascii": ascii},
             loader=jinja2.FileSystemLoader("web-resources"),
         )
+        self.app["static_root_url"] = "/static"
+
         super().__init__(**kwargs)
         self.app.router.add_get("/favicon.ico", self.favicon)
+        self.app.router.add_static("/static/", "web-resources/static")
 
     async def start_if_ready(self, total_count, port):
         if total_count <= len(self.client_data):
diff --git a/friendly-telegram/web/initial_setup.py b/hikka/web/root.py
old mode 100755
new mode 100644
similarity index 57%
rename from friendly-telegram/web/initial_setup.py
rename to hikka/web/root.py
index 2fcb6a9..58e7941
--- a/friendly-telegram/web/initial_setup.py
+++ b/hikka/web/root.py
@@ -1,5 +1,7 @@
+"""Main bot page"""
+
 #    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
+#    Copyright (C) 2018-2021 The Authors
 
 #    This program is free software: you can redistribute it and/or modify
 #    it under the terms of the GNU Affero General Public License as published by
@@ -14,35 +16,44 @@
 #    You should have received a copy of the GNU Affero General Public License
 #    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-#    Modded by GeekTG Team
+# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+#
+#              ¬© Copyright 2022
+#
+#          https://t.me/hikariatama
+#
+# üîí Licensed under the GNU GPLv3
+# üåê https://www.gnu.org/licenses/agpl-3.0.html
 
 import asyncio
 import collections
 import os
-import re
 import string
 
 import aiohttp_jinja2
 import telethon
 from aiohttp import web
 
-from .. import utils
+from .. import utils, main
+
+from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
 
 
 class Web:
     def __init__(self, **kwargs):
-        self.heroku_api_token = os.environ.get("heroku_api_token")
         self.api_token = kwargs.pop("api_token")
         self.data_root = kwargs.pop("data_root")
         self.connection = kwargs.pop("connection")
-        self.hosting = kwargs.pop("hosting")
-        self.default_app = kwargs.pop("default_app")
         self.proxy = kwargs.pop("proxy")
         self.redirect_url = None
         super().__init__(**kwargs)
-        self.app.router.add_get("/initialSetup", self.initial_setup)
+        self.app.router.add_get("/", self.root)
         self.app.router.add_put("/setApi", self.set_tg_api)
         self.app.router.add_post("/sendTgCode", self.send_tg_code)
+        self.app.router.add_post("/check_session", self.check_session)
+        self.app.router.add_post("/web_auth", self.web_auth)
+        self.app.router.add_post("/okteto", self.okteto)
         self.app.router.add_post("/tgCode", self.tg_code)
         self.app.router.add_post("/finishLogin", self.finish_login)
         self.api_set = asyncio.Event()
@@ -50,34 +61,36 @@ class Web:
         self.clients = []
         self.clients_set = asyncio.Event()
         self.root_redirected = asyncio.Event()
+        self._sessions = []
 
+    @aiohttp_jinja2.template("root.jinja2")
     async def root(self, request):
-        if self.clients_set.is_set():
-            await self.ready.wait()
-        if self.redirect_url:
-            self.root_redirected.set()
-            return web.Response(status=302, headers={"Location": self.redirect_url})
-        if self.client_data:
-            return await super().root(request)
-        return await self.initial_setup(request)
-
-    @aiohttp_jinja2.template("initial_root.jinja2")
-    async def initial_setup(self, request):
         return {
-            "api_done": self.api_token is not None,
+            "skip_creds": self.api_token is not None,
             "tg_done": bool(self.client_data),
-            "heroku_token": self.heroku_api_token,
-            "hosting": self.hosting,
-            "default_app": self.default_app,
+            "okteto": "OKTETO" in os.environ,
+            "lavhost": "LAVHOST" in os.environ,
         }
 
+    async def check_session(self, request):
+        return web.Response(body=("1" if self._check_session(request) else "0"))
+
     def wait_for_api_token_setup(self):
         return self.api_set.wait()
 
     def wait_for_clients_setup(self):
         return self.clients_set.wait()
 
+    def _check_session(self, request) -> bool:
+        if not main.hikka.clients:
+            return True
+
+        return request.cookies.get("session", None) in self._sessions
+
     async def set_tg_api(self, request):
+        if not self._check_session(request):
+            return web.Response(status=401)
+
         text = await request.text()
         if len(text) < 36:
             return web.Response(status=400)
@@ -101,6 +114,9 @@ class Web:
         return web.Response()
 
     async def send_tg_code(self, request):
+        if not self._check_session(request):
+            return web.Response(status=401)
+
         text = await request.text()
         phone = telethon.utils.parse_phone(text)
         if not phone:
@@ -118,7 +134,18 @@ class Web:
         self.sign_in_clients[phone] = client
         return web.Response()
 
+    async def okteto(self, request):
+        if "OKTETO_URI" in os.environ:
+            return web.Response(status=418)
+
+        text = await request.text()
+        os.environ["OKTETO_URI"] = text
+        return web.Response(body="URI_SAVED")
+
     async def tg_code(self, request):
+        if not self._check_session(request):
+            return web.Response(status=401)
+
         text = await request.text()
         if len(text) < 6:
             return web.Response(status=400)
@@ -159,14 +186,66 @@ class Web:
         return web.Response()
 
     async def finish_login(self, request):
+        if not self._check_session(request):
+            return web.Response(status=401)
+
         if not self.clients:
             return web.Response(status=400)
-        text = await request.text()
-        if text:
-            if not re.fullmatch(r"[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}", text):
-                return web.Response(status=400)
-            self.heroku_api_token = text
-        else:
-            self.heroku_api_token = None
+
+        first_session = not bool(main.hikka.clients)
+
+        await main.hikka.fetch_clients_from_web()
+
         self.clients_set.set()
-        return web.Response()
+
+        return web.Response(body=("1" if first_session else "0"))
+
+    async def web_auth(self, request):
+        if self._check_session(request):
+            return web.Response(body=request.cookies.get("session", "unauthorized"))
+
+        token = utils.rand(8)
+
+        markup = InlineKeyboardMarkup()
+        markup.add(
+            InlineKeyboardButton(
+                "üîì Authorize user", callback_data=f"authorize_web_{token}"
+            )
+        )
+
+        ops = []
+
+        for user in self.client_data.values():
+            try:
+                bot = user[0].inline.bot
+                msg = await bot.send_message(
+                    (await user[1].get_me()).id,
+                    (
+                        "üë©‚Äçüé§üîê <b>Click button below to confirm web application ops</b>\n\n"
+                        "<i>If you did not request any codes, simply ignore this message</i>"
+                    ),
+                    parse_mode="HTML",
+                    disable_web_page_preview=True,
+                    reply_markup=markup,
+                )
+                ops += [bot.delete_message(msg.chat.id, msg.message_id)]
+            except Exception:
+                pass
+
+        session = f"hikka_{utils.rand(16)}"
+
+        if not ops:
+            # If no auth message was sent, just leave it empty
+            # probably, request was a bug and user doesn't have
+            # inline bot or did not authorize any sessions
+            return web.Response(body=session)
+
+        if not await main.hikka.wait_for_web_auth(token):
+            return web.Response(body="TIMEOUT")
+
+        for op in ops:
+            await op
+
+        self._sessions += [session]
+
+        return web.Response(body=session)
diff --git a/install-heroku.ps1 b/install-heroku.ps1
deleted file mode 100644
index 3ff68ee..0000000
--- a/install-heroku.ps1
+++ /dev/null
@@ -1,62 +0,0 @@
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-#    Modded by GeekTG Team
-
-if (Test-Path "Friendly-Telegram" -PathType Container)
-{
-	if (Test-Path (Join-Path "Friendly-Telegram" "Friendly-Telegram") -PathType Container)
-	{
-		Set-Location "Friendly-Telegram"
-	}
-	python -m friendly-telegram
-	exit
-}
-
-Write-Output("Downloading Python...")
-Invoke-WebRequest -Uri "https://www.python.org/ftp/python/3.9.6/python-3.9.6.exe" -OutFile (Join-Path $env:TEMP "python-installer.exe")
-Write-Output("Installing Python...")
-Start-Process (Join-Path $env:TEMP "python-installer.exe") @("/quiet"; "InstallAllUsers=0"; "PrependPath=1"; "Include_test=0"; "InstallLauncherAllUsers=0") -Wait
-Write-Output("Locating Git...")
-$ret = Invoke-RestMethod -Uri "https://api.github.com/repos/git-for-windows/git/releases" -Headers @{ 'User-Agent' = 'Friendly-Telegram installer' }
-foreach ($release in $ret)
-{
-	$asset_id = $release.assets | Where { $_.name -Match ("^Git-[0-9]+\.[0-9]+\.[0-9]+-" + (Get-WmiObject -Class Win32_OperatingSystem -ComputerName $env:computername -ea 0).OSArchitecture + ".exe$") } | % { $_.id }
-	if (-not [string]::IsNullOrEmpty($asset_id))
-	{
-		break
-	}
-}
-if ( [string]::IsNullOrEmpty($asset_id))
-{
-	Write-Error "Unable to locate Git"
-	exit
-}
-$download_url = "https://api.github.com/repos/git-for-windows/git/releases/assets/" + $asset_id
-Write-Output("Downloading Git...")
-Invoke-WebRequest -Uri $download_url -OutFile (Join-Path $env:TEMP "git-scm-installer.exe") -Headers @{ 'User-Agent' = 'Friendly-Telegram installer'; 'Accept' = 'application/octet-stream' }
-Write-Output("Installing Git...")
-Start-Process (Join-Path $env:TEMP "git-scm-installer.exe") @("/VERYSILENT"; "/NORESTART"; "/NOCANCEL"; "/SP-"; "/CURRENTUSER"; "/NOCLOSEAPPLICATIONS"; "/NORESTARTAPPLICATIONS"; '/COMPONENTS=""') -Wait
-Write-Output("Done")
-
-# https://stackoverflow.com/a/31845512
-$env:Path = [System.Environment]::GetEnvironmentVariable("Path", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path", "User")
-git clone https://github.com/GeekTG/Friendly-Telegram
-
-Set-Location Friendly-Telegram
-python -m pip install -r requirements.txt
-python -m friendly-telegram
-python -m friendly-telegram --heroku # Stopgap
diff --git a/install.ps1 b/install.ps1
deleted file mode 100644
index 754b92b..0000000
--- a/install.ps1
+++ /dev/null
@@ -1,62 +0,0 @@
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-#    Modded by GeekTG Team
-
-if (Test-Path "Friendly-Telegram" -PathType Container)
-{
-	if (Test-Path (Join-Path "Friendly-Telegram" "Friendly-Telegram") -PathType Container)
-	{
-		Set-Location "Friendly-Telegram"
-	}
-	python -m friendly-telegram
-	exit
-}
-
-Write-Output("Downloading Python...")
-Invoke-WebRequest -Uri "https://www.python.org/ftp/python/3.7.4/python-3.7.4.exe" -OutFile (Join-Path $env:TEMP "python-installer.exe")
-Write-Output("Installing Python...")
-Start-Process (Join-Path $env:TEMP "python-installer.exe") @("/quiet"; "InstallAllUsers=0"; "PrependPath=1"; "Include_test=0"; "InstallLauncherAllUsers=0") -Wait
-Write-Output("Locating Git...")
-$ret = Invoke-RestMethod -Uri "https://api.github.com/repos/git-for-windows/git/releases" -Headers @{ 'User-Agent' = 'Friendly-Telegram installer' }
-foreach ($release in $ret)
-{
-	$asset_id = $release.assets | Where { $_.name -Match ("^Git-[0-9]+\.[0-9]+\.[0-9]+-" + (Get-WmiObject -Class Win32_OperatingSystem -ComputerName $env:computername -ea 0).OSArchitecture + ".exe$") } | % { $_.id }
-	if (-not [string]::IsNullOrEmpty($asset_id))
-	{
-		break
-	}
-}
-if ( [string]::IsNullOrEmpty($asset_id))
-{
-	Write-Error "Unable to locate Git"
-	exit
-}
-$download_url = "https://api.github.com/repos/git-for-windows/git/releases/assets/" + $asset_id
-Write-Output("Downloading Git...")
-Invoke-WebRequest -Uri $download_url -OutFile (Join-Path $env:TEMP "git-scm-installer.exe") -Headers @{ 'User-Agent' = 'Friendly-Telegram installer'; 'Accept' = 'application/octet-stream' }
-Write-Output("Installing Git...")
-Start-Process (Join-Path $env:TEMP "git-scm-installer.exe") @("/VERYSILENT"; "/NORESTART"; "/NOCANCEL"; "/SP-"; "/CURRENTUSER"; "/NOCLOSEAPPLICATIONS"; "/NORESTARTAPPLICATIONS"; '/COMPONENTS=""') -Wait
-Write-Output("Done")
-
-# https://stackoverflow.com/a/31845512
-$env:Path = [System.Environment]::GetEnvironmentVariable("Path", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path", "User")
-git clone https://github.com/GeekTG/Friendly-Telegram
-
-Set-Location Friendly-Telegram
-python -m pip install -r requirements.txt
-python -m friendly-telegram
-python -m friendly-telegram # TODO pass args
diff --git a/install.sh b/install.sh
old mode 100644
new mode 100755
index ab00c43..118a2c1
--- a/install.sh
+++ b/install.sh
@@ -1,26 +1,8 @@
 #!/bin/bash
 
-#    Friendly Telegram (telegram userbot)
-#    Copyright (C) 2018-2022 The Authors
-
-#    This program is free software: you can redistribute it and/or modify
-#    it under the terms of the GNU Affero General Public License as published by
-#    the Free Software Foundation, either version 3 of the License, or
-#    (at your option) any later version.
-
-#    This program is distributed in the hope that it will be useful,
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#    GNU Affero General Public License for more details.
-
-#    You should have received a copy of the GNU Affero General Public License
-#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-#    Modded by GeekTG Team
-
 if [ ! -n "$BASH" ]; then
 	echo "Non-bash shell detected, fixing..."
-	bash -c '. <('"$(command -v curl >/dev/null && echo 'curl -Ls' || echo 'wget -qO-')"' https://github.com/GeekTG/Friendly-Telegram/raw/master/install.sh) '"$*"
+	bash -c '. <('"$(command -v curl >/dev/null && echo 'curl -Ls' || echo 'wget -qO-')"' https://github.com/hikariatama/Hikka/master/install.sh) '"$*"
 	exit $?
 fi
 
@@ -36,66 +18,80 @@ endspin() {
 
 runin() {
 	# Runs the arguments and spins once per line of stdout (tee'd to logfile), also piping stderr to logfile
-	{ "$@" 2>>../ftg-install.log || return $?; } | while read -r line; do
+	{ "$@" 2>>../hikka-install.log || return $?; } | while read -r line; do
 		spin
-		printf "%s\n" "$line" >>../ftg-install.log
+		printf "%s\n" "$line" >>../hikka-install.log
 	done
 }
 
 runout() {
 	# Runs the arguments and spins once per line of stdout (tee'd to logfile), also piping stderr to logfile
-	{ "$@" 2>>ftg-install.log || return $?; } | while read -r line; do
+	{ "$@" 2>>hikka-install.log || return $?; } | while read -r line; do
 		spin
-		printf "%s\n" "$line" >>ftg-install.log
+		printf "%s\n" "$line" >>hikka-install.log
 	done
 }
 
 errorin() {
 	endspin "$@"
-	cat ../ftg-install.log
+	cat ../hikka-install.log
 }
 errorout() {
 	endspin "$@"
-	cat ftg-install.log
+	cat hikka-install.log
 }
 
-# Banner generated with following command:
-# pyfiglet -f smslant -w 50 friendly telegram | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g' | sed 's/^/printf "%s\\n" "/m;s/$/"/m'
-# Ugly, I know.
+##############################################################################
 
-banner() {
-	clear
-	clear
-	printf "\n\e[7;30;41m                    )  \e[0m"
-	printf "\n\e[7;30;41m (               ( /(  \e[0m"
-	printf "\n\e[7;30;41m )\\ )   (   (    )\\()) \e[0m"
-	printf "\n\e[7;30;41m(()/(   )\\  )\\ |((_)\\  \e[0m"
-	printf "\n\e[7;30;41m /((\e[7;30;42m_\e[7;30;41m)\e[7;30;42m_\e[7;30;41m((\e[7;30;42m_\e[7;30;41m)((\e[7;30;42m_\e[7;30;41m)|\e[7;30;42m_\e[7;30;41m((\e[7;30;42m_\e[7;30;41m) \e[0m"
-	printf "\n\e[7;30;41m(_)\e[0m\e[7;30;42m/ __| __| __| |/ /  \e[0m"
-	printf "\n\e[7;30;42m  | (_ | _|| _|  ' <   \e[0m"
-	printf "\n\e[7;30;42m   \\___|___|___|_|\\_\\ \e[0m\n\n"
+clear
+clear
+# Adapted from https://github.com/Silejonu/bash_loading_animations/blob/main/bash_loading_animations.sh
+
+BLA_metro=('[       ]' '[=      ]' '[==     ]' '[===    ]' '[====   ]' '[=====  ]' '[ ===== ]' '[ ======]' '[  =====]' '[   ====]' '[    ===]' '[     ==]' '[      =]' '[       ]' '[ ======]' '[ ===== ]' '[=====  ]' '[====   ]' '[===    ]' '[==     ]' '[=      ]' '[       ]')
 
+BLA::play_loading_animation_loop() {
+  while true ; do
+    for frame in ${!BLA_metro[*]} ; do
+      printf "\r%s" " ${BLA_metro[$frame]}"
+      sleep "0.05"
+    done
+  done
 }
 
-##############################################################################
+BLA::start_loading_animation() {
+  tput civis # Hide the terminal cursor
+  BLA::play_loading_animation_loop &
+  BLA_loading_animation_pid="${!}"
+}
+
+BLA::stop_loading_animation() {
+  kill "${BLA_loading_animation_pid}" &> /dev/null
+  printf "\r%s" "                    "
+  printf "\n"
+  tput cnorm # Restore the terminal cursor
+}
 
-banner
-printf '%s\n' "The process takes around 3-7 minutes"
-printf '%s' "Installing now...  "
+printf "\n\e[1;35;47m                   \e[0m"
+printf "\n\e[1;35;47m ‚ñà ‚ñà ‚ñà ‚ñà‚ñÑ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà \e[0m"
+printf "\n\e[1;35;47m ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà \e[0m"
+printf "\n\e[1;35;47m                   \e[0m"
+printf "\n\n\e[3;34;40m Installing...\e[0m\n\n"
+BLA::start_loading_animation
 
 ##############################################################################
 
 spin
 
-touch ftg-install.log
+touch hikka-install.log
 if [ ! x"$SUDO_USER" = x"" ]; then
-	chown "$SUDO_USER:" ftg-install.log
+	chown "$SUDO_USER:" hikka-install.log
 fi
 
 if [ ! x"" = x"$DYNO" ] && ! command -v python >/dev/null; then
 	# We are running in a heroku dyno without python, time to get ugly!
 	runout git clone https://github.com/heroku/heroku-buildpack-python || {
 		endspin "Bootstrap download failed!"
+		BLA::stop_loading_animation
 		exit 1
 	}
 	rm -rf .heroku .cache .profile.d requirements.txt runtime.txt .env
@@ -105,21 +101,23 @@ if [ ! x"" = x"$DYNO" ] && ! command -v python >/dev/null; then
 	STACK=heroku-18 runout bash heroku-buildpack-python/bin/compile /app /app/.cache /app/.env ||
 		{
 			endspin "Bootstrap install failed!"
+			BLA::stop_loading_animation
 			exit 1
 		}
 	rm -rf .cache
 	export PATH="/app/.heroku/python/bin:$PATH" # Prefer the bootstrapped python, incl. pip, over the system one.
 fi
 
-if [ -d "Friendly-Telegram/friendly-telegram" ]; then
-	cd Friendly-Telegram || {
+if [ -d "Hikka/hikka" ]; then
+	cd Hikka || {
 		endspin "Error: Install git package and re-run installer"
+		BLA::stop_loading_animation
 		exit 6
 	}
 	DIR_CHANGED="yes"
 fi
-if [ -f ".setup_complete" ] || [ -d "friendly-telegram" -a ! x"" = x"$DYNO" ]; then
-	# If ftg is already installed by this script, or its in Heroku and installed
+if [ -f ".setup_complete" ] || [ -d "hikka" -a ! x"" = x"$DYNO" ]; then
+	# If hikka is already installed by this script, or its in Heroku and installed
 	PYVER=""
 	if echo "$OSTYPE" | grep -qE '^linux-gnu.*'; then
 		PYVER="3"
@@ -127,7 +125,8 @@ if [ -f ".setup_complete" ] || [ -d "friendly-telegram" -a ! x"" = x"$DYNO" ]; t
 	endspin "Existing installation detected"
 	clear
 	banner
-	"python$PYVER" -m friendly-telegram "$@"
+	"python$PYVER" -m hikka "$@"
+	BLA::stop_loading_animation
 	exit $?
 elif [ "$DIR_CHANGED" = "yes" ]; then
 	cd ..
@@ -135,7 +134,7 @@ fi
 
 ##############################################################################
 
-echo "Installing..." >ftg-install.log
+echo "Installing..." >hikka-install.log
 
 if echo "$OSTYPE" | grep -qE '^linux-gnu.*' && [ -f '/etc/debian_version' ]; then
 	PKGMGR="apt install -y"
@@ -143,8 +142,9 @@ if echo "$OSTYPE" | grep -qE '^linux-gnu.*' && [ -f '/etc/debian_version' ]; the
 		# Relaunch as root, preserving arguments
 		if command -v sudo >/dev/null; then
 			endspin "Restarting as root..."
-			echo "Relaunching" >>ftg-install.log
-			sudo "$BASH" -c '. <('"$(command -v curl >/dev/null && echo 'curl -Ls' || echo 'wget -qO-')"' https://github.com/GeekTG/Friendly-Telegram/raw/master/install.sh) '"$*"
+			echo "Relaunching" >>hikka-install.log
+			sudo "$BASH" -c '. <('"$(command -v curl >/dev/null && echo 'curl -Ls' || echo 'wget -qO-')"' https://github.com/hikariatama/Hikka/master/install.sh) '"$*"
+			BLA::stop_loading_animation
 			exit $?
 		else
 			PKGMGR="true"
@@ -160,8 +160,9 @@ elif echo "$OSTYPE" | grep -qE '^linux-gnu.*' && [ -f '/etc/arch-release' ]; the
 		# Relaunch as root, preserving arguments
 		if command -v sudo >/dev/null; then
 			endspin "Restarting as root..."
-			echo "Relaunching" >>ftg-install.log
-			sudo "$BASH" -c '. <('"$(command -v curl >/dev/null && echo 'curl -Ls' || echo 'wget -qO-')"' https://github.com/GeekTG/Friendly-Telegram/raw/master/install.sh) '"$*"
+			echo "Relaunching" >>hikka-install.log
+			sudo "$BASH" -c '. <('"$(command -v curl >/dev/null && echo 'curl -Ls' || echo 'wget -qO-')"' https://github.com/hikariatama/Hikka/master/install.sh) '"$*"
+			BLA::stop_loading_animation
 			exit $?
 		else
 			PKGMGR="true"
@@ -179,7 +180,8 @@ elif echo "$OSTYPE" | grep -qE '^darwin.*'; then
 	PKGMGR="brew install"
 	PYVER="3"
 else
-	endspin "Unrecognised OS. Please follow https://ftg.geektg.ml/#installation"
+	endspin "Unrecognised OS. Please follow https://t.me/hikka_talks"
+	BLA::stop_loading_animation
 	exit 1
 fi
 
@@ -187,6 +189,7 @@ fi
 
 runout $PKGMGR "python$PYVER" git || {  # skipcq
 	errorout "Core install failed."
+	BLA::stop_loading_animation
 	exit 2
 }
 
@@ -212,14 +215,16 @@ if [ ! x"$SUDO_USER" = x"" ]; then
 fi
 
 # shellcheck disable=SC2086
-${SUDO_CMD}rm -rf Friendly-Telegram
+${SUDO_CMD}rm -rf Hikka
 # shellcheck disable=SC2086
-runout ${SUDO_CMD}git clone https://github.com/GeekTG/Friendly-Telegram || {
+runout ${SUDO_CMD}git clone https://github.com/hikariatama/Hikka/ || {
 	errorout "Clone failed."
+	BLA::stop_loading_animation
 	exit 3
 }
-cd Friendly-Telegram || {
+cd Hikka || {
 	endspin "Error: Install git package and re-run installer"
+	BLA::stop_loading_animation
 	exit 7
 }
 # shellcheck disable=SC2086
@@ -227,13 +232,15 @@ runin ${SUDO_CMD}"python$PYVER" -m pip install --upgrade pip setuptools wheel --
 # shellcheck disable=SC2086
 runin ${SUDO_CMD}"python$PYVER" -m pip install -r requirements.txt --upgrade --user --no-warn-script-location --disable-pip-version-check || {
 	errorin "Requirements failed!"
+	BLA::stop_loading_animation
 	exit 4
 }
 endspin "Installation successful. Launching setup interface..."
-rm -f ../ftg-install.log
+rm -f ../hikka-install.log
 touch .setup_complete
+BLA::stop_loading_animation
 # shellcheck disable=SC2086,SC2015
-${SUDO_CMD}"python$PYVER" -m friendly-telegram "$@" || {
+${SUDO_CMD}"python$PYVER" -m hikka "$@" || {
 	echo "Python scripts failed"
 	exit 5
 }
diff --git a/okteto-stack.yaml b/okteto-stack.yaml
new file mode 100644
index 0000000..13e8b3c
--- /dev/null
+++ b/okteto-stack.yaml
@@ -0,0 +1,11 @@
+name: hikka
+services:
+  worker:
+    public: true
+    build: .
+    replicas: 1
+    ports:
+      - 8080
+    resources:
+      cpu: 900m
+      memory: 2Gi
\ No newline at end of file
diff --git a/optional_requirements.txt b/optional_requirements.txt
new file mode 100644
index 0000000..99d81ae
--- /dev/null
+++ b/optional_requirements.txt
@@ -0,0 +1,7 @@
+Pillow
+requests
+emoji
+moviepy
+python-ffmpeg
+ffmpeg
+bs4
\ No newline at end of file
diff --git a/requirements.txt b/requirements.txt
old mode 100644
new mode 100755
index 8d4d427..bd05c00
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,12 +1,9 @@
 # Telegram connection
-Telethon-Mod==1.24.7
+Telethon-Mod==1.24.6
 
 # Config
 pythondialog==3.5.3
 
-# Heroku
-heroku3==5.1.4
-
 # Python Git Library
 gitpython==3.1.27
 
@@ -23,7 +20,7 @@ aiohttp_jinja2==1.5
 aiohttp
 
 # A very fast and expressive template engine.
-Jinja2==3.1.1
+Jinja2==3.0.3
 
 # Python HTTP for Humans.
 requests==2.27.1
diff --git a/runtime.txt b/runtime.txt
old mode 100644
new mode 100755
diff --git a/web-resources/base.jinja2 b/web-resources/base.jinja2
index f683a8d..ea12e16 100755
--- a/web-resources/base.jinja2
+++ b/web-resources/base.jinja2
@@ -18,7 +18,6 @@
 
     You should have received a copy of the GNU Affero General Public License
     along with this program.  If not, see <https://www.gnu.org/licenses/>.
-	Modded by GeekNet team, t.me/hikariatama
 -->
 
 
@@ -26,184 +25,24 @@
 <html>
   <head>
     <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">
-    <title>GeekTG</title>
+    <title>Hikka</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
-    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.light_blue-deep_purple.min.css"> 
-    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
+    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
     <script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
-    <style>
-      @import url('https://fonts.googleapis.com/css2?family=Open+Sans&display=swap');
-
-      * {
-        --menuMargin: 10px;
-        --hamburgerSize: 40px;
-        --accent: #46753a;
-      }
-
-      .padded {
-        padding: 16px;
-      }
-      .scroll-to-top {
-        display: block;
-        position: fixed;
-        bottom: 30px;
-        right: 30px;
-        z-index: 99;
-      }
-      body {
-        background: #121212;
-      }
-
-      .menu {
-        width: 180px;
-        /*min-height: 30vh;*/
-        padding: 15px 10px 15px 15px;
-        border-radius: 28px;
-        background: #181818;
-        border-radius: 15px;
-        box-sizing: border-box;
-        margin: var(--menuMargin);
-        position: fixed;
-        z-index: 50;
-        /*left: -180px;*/
-        margin-left: calc(-180px - var(--menuMargin));
-        margin-top: calc(var(--menuMargin) * 2 + 32px);
-        transition: margin .3s cubic-bezier(.26,.46,.69,1.06);
-      }
-
-      .menu.toggled {
-        margin-left: var(--menuMargin);
-      }
-
-      .menu_item {
-        width: 100%;
-        min-height: 32px;
-        border-radius: 10px;
-        cursor: pointer;
-        transition: background .1s ease;
-        background: transparent;
-        margin: 5px 0;
-        text-align: center;
-        display: flex;
-        user-select: none;
-        outline: none;
-      }
-
-      .menu_item:hover {
-        background: #202020;
-      }
-
-      .menu_item:active, .menu_item.toggled {
-        background: #262626;
-      }
-
-      .menu_item a {
-        color: var(--accent);
-        font-size: 15px;
-        text-decoration: none;
-        font-family: 'Open Sans';
-        line-height: 32px;
-      }
-
-      .menu_item i {
-        line-height: 32px;
-        color: #7b7b7b;
-        font-size: 20px;
-        margin-left: 10px;
-        margin-right: 5px;
-      }
-
-      .hamburger {
-        width: var(--hamburgerSize);
-        height: var(--hamburgerSize);
-        text-align: center;
-        border-radius: 50%;
-        margin: var(--menuMargin);
-        background: #181818;
-        color: #fff;
-        position: fixed;
-        cursor: pointer;
-        user-select: none;
-        outline: none;
-      }
-
-      .hamburger i {
-        line-height: var(--hamburgerSize);
-        color: var(--accent);
-      }
-
-      .main_content {
-        width: 100%;
-        height: 100%;
-        box-sizing: border-box;
-        padding: 20px;
-        padding-top: calc(var(--hamburgerSize) + var(--menuMargin) * 2);
-      }
-
-      @media screen and (max-width: 736px) {
-        .main_content {
-          padding: 15px;
-          padding-top: calc(var(--hamburgerSize) + var(--menuMargin) * 2);
-        }
-      }
-
-      #menu_img {
-        width: 100%;
-        height: 100%;
-      }
-    </style>
-    <link rel="icon" href="https://github.com/GeekTG/Friendly-Telegram/raw/master/friendly-telegram/bot_avatar.png">
-    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
+    <link rel="icon" href="https://github.com/hikariatama/Hikka/raw/master/assets/hikka_pfp.png">
     {% block head %}{% endblock %}
   </head>
   <body>
-    <div class="hamburger">
-      <img src="https://github.com/GeekTG/Friendly-Telegram/raw/master/friendly-telegram/bot_avatar.png" id="menu_img">
-    </div>
-    <div class="menu">
-      <div class="menu_item" id="modules">
-        <i class="material-icons">extension</i> <a href="/">Modules</a>
-      </div>
-      <div class="menu_item" id="team">
-        <i class="material-icons">groups</i> <a href="/team">Admins</a>
-      </div>
-      <div class="menu_item" id="chat">
-        <i class="material-icons">textsms</i> <a href="tg://resolve?domain=chat_ftg">Chat</a>
-      </div>
-      <div class="menu_item" id="settings">
-        <i class="material-icons">toggle_on</i> <a href="/settings">Permissions</a>
-      </div>
-    </div>
     <div class="main_content">
       {% block content %}
         <p><b>An internal error occured.</b></p>
       {% endblock %}
     </div>
 
+    <div id="blackhole"></div>
+
     {% block after %}
 
     {% endblock %}
-
-    <script>
-      document.querySelector('.hamburger').onclick = () => {
-        document.querySelector('.menu').classList.toggle('toggled');
-      }
-
-      document.querySelectorAll('.menu_item').forEach((elem) => {
-        elem.onclick = (e) => {
-          document.querySelector('.menu').classList.remove('toggled');
-          e.currentTarget.querySelector('a').click();
-        }
-      })
-
-      path = window.location.href.split('/')[window.location.href.split('/').length - 1]
-      if(document.getElementById(path)) {
-        document.getElementById(path).classList.add('toggled');
-      } else {
-        document.querySelector('#modules').classList.add('toggled');
-      }
-    </script>
-
   </body>
 </html>
diff --git a/web-resources/initial_root.jinja2 b/web-resources/initial_root.jinja2
deleted file mode 100755
index 4546b30..0000000
--- a/web-resources/initial_root.jinja2
+++ /dev/null
@@ -1,623 +0,0 @@
-<!--
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
-
-    Copyright 2022 t.me/hikariatama
-    Licensed under the GNU GPLv3
--->
-
-{% extends "base.jinja2" %}
-
-{% block head %}
-  <script src="https://cdn.jsdelivr.net/npm/scrypt-async@2.0.1/scrypt-async.min.js"></script>
-  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
-  <script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
-  <style>
-    @import url('https://fonts.googleapis.com/css2?family=Josefin+Sans&family=Open+Sans:wght@300&display=swap');
-    @import url('https://fonts.googleapis.com/css2?family=Hubballi&display=swap');
-    .button {
-      border-radius: 5px;
-      padding: 10px 20px;
-      border: none;
-      color: #eee;
-      margin: 5px 0;
-      background: transparent;
-      border: 2px solid #aaa;
-      cursor: pointer;
-      transition: box-shadow .2s ease;
-      user-select: none;
-    }
-
-
-
-    .button:hover {
-      box-shadow: inset 5px 5px 3px rgba(255, 255, 255, .1),
-                  inset -5px -5px 3px rgba(255, 255, 255, .1);
-    }
-
-    .signin_block {
-      display: inline-block;
-    }
-
-    .signin_block ul {
-      margin: 0;
-      list-style: none;
-      padding: 0;
-    }
-
-    .signin_block li {
-      width: 100%;
-    }
-
-    .signin_block h1 {
-      margin: 0;
-      color: #eee;
-      font-size: 22px;
-      padding: 10px;
-      font-family: "Open Sans";
-    }
-
-    .hamburger, .menu {
-      display: none;
-    }
-  </style>
-
-  <style type="text/css">
-    body, html {
-      width: 100%;
-      height: 100%;
-      margin: 0;
-      padding: 0;
-    }
-
-    body {
-      /*background: linear-gradient(-45deg, #007700 0%, #004400 100%);*/
-      transition: all 2s ease;
-      background: #16181d;
-    }
-
-    #sky {
-      width: 100vw;
-      height: 100vh;
-      position: fixed;
-      overflow: hidden;
-      margin: 0;
-      padding: 0;
-    }
-
-    #shootingstars {
-      margin: 0;
-      padding: 0;
-      width: 150vh;
-      height: 100vw;
-      position: fixed;
-      overflow: hidden;
-      transform: translatex(calc(50vw - 50%)) translatey(calc(50vh - 50%))
-        rotate(120deg);
-    }
-
-    .wish {
-      height: 2px;
-      top: 300px;
-      width: 100px;
-      margin: 0;
-      opacity: 0;
-      padding: 0;
-      background-color: white;
-      position: absolute;
-      background: linear-gradient(-45deg, white, rgba(0, 0, 255, 0));
-      filter: drop-shadow(0 0 6px white);
-      overflow: hidden;
-    }
-
-    .title {
-      font-size: 50px;
-      font-family: Hubballi;
-      text-align: center;
-      color: #fff;
-      width: 100%;
-      z-index: 2;
-      position: relative;
-      height: 50px;
-      line-height: 50px;
-    }
-
-    .description {
-      font-size: 24px;
-      color: #eee;
-      text-align: center;
-      width: 100%;
-      z-index: 2;
-      position: relative;
-      padding-top: 20px;
-      line-height: 1.3;
-      font-family: Hubballi;
-    }
-
-    .wrapper {
-      width: 100%;
-      height: 100%;
-      position: absolute;
-      justify-content: center;
-      align-items: center;
-      display: flex;
-      flex-direction: column;
-    }
-
-    #root {
-      position: absolute;
-      top:  0;
-      right: 0;
-      left: 0;
-      bottom: 0;
-      margin: auto;
-    }
-
-    .darken {
-      position: absolute;
-      width: 100%;
-      height: 100%;
-      z-index: 1;
-      background: rgba(0, 0, 0, .1);
-      top: 0;
-      bottom: 0;
-      right: 0;
-      left: 0;
-      margin: auto;
-    }
-
-    .main_content {
-      display: none;
-    }
-
-    .center {
-      justify-content: center;
-      align-items: center;
-      display: flex;
-      position: relative;
-      z-index: 2;
-      margin-top: 20px;
-    }
-
-    .blur {
-      padding: 4rem 8rem;
-      border-radius: 0.375rem;
-      background-color: rgba(22, 24, 29, .5);
-      border: 1px solid rgba(42, 46, 55, 1);
-      backdrop-filter: blur(6px);
-      position: relative;
-      z-index: 99;
-    }
-
-    .bg {
-      background: url(https://github.com/hikariatama/assets/raw/master/bg.png);
-      background-repeat: no-repeat;
-      background-size: contain;
-      width: 80vw;
-      height: 60vh;
-      position: absolute;
-      z-index: 1;
-      background-position: center;
-      display: none;
-      filter: hue-rotate(155deg);
-      transition: .3s;
-      animation: floating 5s infinite ease-in-out;
-    }
-
-    @keyframes floating {
-      from {
-        transform: translateY(-10px);
-      }
-
-      50% {
-        transform: translateY(10px);
-      }
-
-      to {
-        transform: translateY(-10px);
-      }
-    }
-
-    @media screen and (max-width: 736px) {
-      .blur {
-        width: 100%;
-        height: 100%;
-        padding: 1.5rem;
-        box-sizing: border-box;
-        display: flex;
-        flex-direction: column;
-        align-items: center;
-        justify-content: center;
-      }
-
-      .bg {
-        width: 100vh;
-        height: 100vw;
-        transform: rotate(90deg);
-      }
-    }
-
-    input {
-      background: transparent;
-      border: 1px solid #eee;
-      outline: none;
-      padding: 10px 15px;
-      border-radius: 10px;
-      color: #fff;
-      text-align: center;
-    }
-    label {
-      margin: 0 10px;
-      color: #eee;
-      user-select: none;
-    }
-
-    #continue_btn {
-      padding: 10px 15px;
-      background: #0d47a1;
-      border-radius: 10px;
-      user-select: none;
-      color: #fff;
-      cursor: pointer;
-      text-align: center;
-      border: 1px solid #1a237e;
-      margin: 10px 0;
-      transition: all .3s ease;
-      margin-left: 5px;
-    }
-
-    #continue_btn:hover {
-      background-color: #1a237e;
-    }
-
-    #continue_btn:active {
-      background-color: #311b92;
-    }
-
-    #continue_btn.error {
-      background-color: #c62828;
-      transition: all .3s ease;
-    }
-
-    #continue_btn, #block_api_id, #block_api_hash, #block_phone, #block_2fa {
-      display: none;
-    }
-
-    .red_state {
-      filter: hue-rotate(0deg);
-    }
-
-    .blue_state {
-      filter: hue-rotate(203deg);
-    }
-  </style>
-{% endblock %}
-
-{% block content %}
-{% endblock %}
-
-{% block after %}
-<div class="wrapper">
-  <div class="bg invert">
-    
-  </div>
-  <div class="blur">
-    <div class="title">GeekTG</div>
-    <div class="description">Ultimate userbot.<br>Best <span style="color:#28a0dc">Telegram</span> userbot.<br><b>Ever</b>.</div>
-    <div class="center">
-      <div class="button" id="get_started">Get started</div>
-      <span id="block_api_id">
-        <label class="api_id" for="api_id">API ID: </label>
-        <input class="api_id" id="api_id" placeholder="2020" style="width: 4em;">
-      </span>
-      <span id="block_api_hash">
-        <label class="api_hash" for="api_hash">API HASH: </label>
-        <input class="api_hash" id="api_hash" placeholder="w7i07l02i6hymgg03ncq6esmr3t4c9kl" style="width: 24em;">
-      </span>
-      <span id="block_phone">
-        <label class="phone" for="phone">Phone: </label>
-        <input class="phone" id="phone" placeholder="+79999999999" style="width: 12em;">
-      </span>
-      <span id="block_2fa">
-        <label class="_2fa" for="_2fa">2FA Password: </label>
-        <input class="_2fa" id="_2fa" placeholder="passw0rd" style="width: 12em;" type="password">
-      </span>
-      <div id="continue_btn">Continue</div>
-    </div>
-  </div>
-  <div id="root">
-
-  
-  </div>
-</div>
-<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
-<script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
-<script type="text/javascript">
-  $(document).ready(function() {
-      $('.bg').hide().delay(2000).fadeIn(500);
-  });
-  $("#get_started").click(() => {
-    $("#get_started").fadeOut(500, () => {
-      cnt_btn.setAttribute('current-step', 'api_id');
-      $("#block_api_id").hide().fadeIn(500);
-      $("#continue_btn").hide().fadeIn(500);
-    });
-  });
-
-  function isInt(value) {
-    var x = parseFloat(value);
-    return !isNaN(value) && (x | 0) === x;
-  }
-
-  function isValidPhone(p) {
-    var phoneRe = /^[+]?\d{11,13}$/;
-    return phoneRe.test(p);
-  }
-
-  var _api_id = "", _api_hash = "", _phone = "", _2fa_pass = "", _tg_pass = "";
-
-  const cnt_btn = document.querySelector('#continue_btn');
-  cnt_btn.onclick = (e) => {
-    if(cnt_btn.disabled) return;
-
-    let step = cnt_btn.getAttribute('current-step');
-    if(step == "api_id") {
-      let api_id = document.querySelector('#api_id').value;
-      if(api_id.length < 4 || !isInt(api_id)) {
-        $(".bg").addClass("red_state");
-        cnt_btn.disabled = true;
-        setTimeout(() => {
-          cnt_btn.disabled = false;
-          $(".bg").removeClass("red_state");
-        }, 1000);
-        return;
-      }
-
-      _api_id = parseInt(api_id);
-      cnt_btn.setAttribute('current-step', 'api_hash');
-      $("#block_api_id").fadeOut(() => {
-        $("#block_api_hash").hide().fadeIn();
-      });
-    } else if (step == "api_hash") {
-      let api_hash = document.querySelector('#api_hash').value;
-      if(api_hash.length != 32) {
-        $(".bg").addClass("red_state");
-        cnt_btn.disabled = true;
-        setTimeout(() => {
-          cnt_btn.disabled = false;
-          $(".bg").removeClass("red_state");
-        }, 1000);
-        return;
-      }
-
-      _api_hash = api_hash;
-      fetch("/setApi", {
-        method: "PUT",
-        body: _api_hash + _api_id,
-        credentials: "include"
-      })
-      .then(function (response) {
-        if (!response.ok) {
-          Swal.fire({
-            'icon': 'error', 
-            'title': 'Error occured while saving credentials'
-          });
-        } else {
-          cnt_btn.setAttribute('current-step', 'phone');
-          $("#block_api_hash").fadeOut(() => {
-            $("#block_phone").hide().fadeIn();
-          });
-        }
-      })
-      .catch(function (response) {
-        Swal.fire({
-          'icon': 'error', 
-          'title': 'Error occured while saving credentials'
-        });
-      });
-    } else if (step == "phone" || step == "2fa") {
-      if(step == "phone") {
-        let phone = document.querySelector('#phone').value;
-        if(!isValidPhone(phone)) {
-          $(".bg").addClass("red_state");
-          cnt_btn.disabled = true;
-          setTimeout(() => {
-            cnt_btn.disabled = false;
-            $(".bg").removeClass("red_state");
-          }, 1000);
-          return;
-        }
-
-        _phone = phone;
-        fetch("/sendTgCode", {method: "POST", body: _phone, credentials: "include"})
-        .then(function (response) {
-          if (!response.ok) {
-            Swal.fire({
-              'icon': 'error', 
-              'title': 'Code send failed'
-            });
-          } else {
-            Swal.fire({
-              title: 'Enter received code',
-              input: 'text',
-              inputAttributes: {
-                autocapitalize: 'off'
-              },
-              showCancelButton: false,
-              confirmButtonText: 'Confirm',
-              showLoaderOnConfirm: true,
-              preConfirm: (login) => {
-                _tg_pass = login
-                return fetch("/tgCode", {method: "POST", body: _tg_pass + "\n" + _phone + "\n" + _2fa_pass})
-                  .then(function(response) {
-                    if (!response.ok) {
-                      console.log(response);
-                      if (response.status == 403) {
-                        Swal.showValidationMessage('Code is incorrect!');
-                      } else if (response.status == 401) {
-                        cnt_btn.setAttribute('current-step', '2fa');
-                        $("#block_phone").fadeOut(() => {
-                          $("#block_2fa").hide().fadeIn();
-                        });
-                      } else if (response.status == 404) {
-                        // Code expired, must re-send code request. Close dialog and wait for user action.
-                        Swal.showValidationMessage('Code is expired!');
-                      } else {
-                        Swal.showValidationMessage('Internal server error');
-                      }
-                    } else {
-                      Swal.fire({
-                        title: 'Enter Heroku token',
-                        text: 'Leave empty to NOT install to Heroku',
-                        input: 'text',
-                        inputAttributes: {
-                          autocapitalize: 'off'
-                        },
-                        showCancelButton: false,
-                        confirmButtonText: 'Confirm',
-                        showLoaderOnConfirm: true,
-                        preConfirm: (heroku_token) => {
-                          return fetch("/finishLogin", {method: "POST", body: heroku_token, credentials: "include"})
-                                .then(function (response) {
-                                  if (!response.ok) {
-                                    Swal.fire({
-                                      'icon': 'error',
-                                      'text': 'Login confirmation error'
-                                    })
-                                  } else {
-                                    Swal.fire({
-                                      'icon': 'success',
-                                      'text': 'Auth successful!',
-                                      'timer': 1000
-                                    });
-                                    setTimeout(() => {
-                                      window.location.reload();
-                                    }, 1500);
-                                  }
-                                })
-                                .catch(function (response) {
-                                  Swal.fire({
-                                    'icon': 'error',
-                                    'text': 'Login confirmation error'
-                                  })
-                                });
-                        },
-                        allowOutsideClick: () => !Swal.isLoading()
-                      })
-                    }
-                  })
-                  .catch(error => {
-                    Swal.showValidationMessage(
-                      'Auth failed: ' + error.toString()
-                    )
-                  })
-              },
-              allowOutsideClick: () => !Swal.isLoading()
-            })
-          }
-        })
-        .catch(function (error) {
-          Swal.fire({
-            'icon': 'error', 
-            'title': 'Code send failed'
-          });
-        });
-      } else {
-        let _2fa = document.querySelector('#_2fa').value;
-        _2fa_pass = _2fa;
-        fetch("/tgCode", {method: "POST", body: _tg_pass + "\n" + _phone + "\n" + _2fa_pass})
-        .then(function(response) {
-          if (!response.ok) {
-            console.log(response);
-            if (response.status == 403) {
-              Swal.showValidationMessage('Code is incorrect!');
-            } else if (response.status == 401) {
-              cnt_btn.setAttribute('current-step', '2fa');
-              $("#block_phone").fadeOut(() => {
-                $("#block_2fa").hide().fadeIn();
-              });
-            } else if (response.status == 404) {
-              // Code expired, must re-send code request. Close dialog and wait for user action.
-              Swal.showValidationMessage('Code is expired!');
-            } else {
-              Swal.showValidationMessage('Internal server error');
-            }
-          } else {
-            {% if hosting %}
-              fetch("/finishLogin", {method: "POST", body: '', credentials: "include"})
-              .then(function (response) {
-                if (!response.ok) {
-                  Swal.fire({
-                    'icon': 'error',
-                    'text': 'Login confirmation error'
-                  })
-                } else {
-                  Swal.fire({
-                    'icon': 'success',
-                    'text': 'Auth successful!',
-                    'timer': 1000
-                  });
-                  setTimeout(() => {
-                    window.location.reload();
-                  }, 1500);
-                }
-              })
-              .catch(function (response) {
-                Swal.fire({
-                  'icon': 'error',
-                  'text': 'Login confirmation error'
-                })
-              });
-            {% else %}
-              Swal.fire({
-                title: 'Enter Heroku token',
-                text: 'Leave empty to NOT install to Heroku',
-                input: 'text',
-                inputAttributes: {
-                  autocapitalize: 'off'
-                },
-                showCancelButton: false,
-                confirmButtonText: 'Confirm',
-                showLoaderOnConfirm: true,
-                preConfirm: (heroku_token) => {
-                  return fetch("/finishLogin", {method: "POST", body: heroku_token, credentials: "include"})
-                        .then(function (response) {
-                          if (!response.ok) {
-                            Swal.fire({
-                              'icon': 'error',
-                              'text': 'Login confirmation error'
-                            })
-                          } else {
-                            Swal.fire({
-                              'icon': 'success',
-                              'text': 'Auth successful!',
-                              'timer': 1000
-                            });
-                            setTimeout(() => {
-                              window.location.reload();
-                            }, 1500);
-                          }
-                        })
-                        .catch(function (response) {
-                          Swal.fire({
-                            'icon': 'error',
-                            'text': 'Login confirmation error'
-                          })
-                        });
-                },
-                allowOutsideClick: () => !Swal.isLoading()
-              })
-            {% endif %}
-          }
-        })
-        .catch(error => {
-          Swal.showValidationMessage(
-            'Auth failed: ' + error.toString()
-          )
-        })
-      }
-    }
-  }
-</script>
-{% endblock %}
-
diff --git a/web-resources/root.jinja2 b/web-resources/root.jinja2
index a475846..a3e249f 100755
--- a/web-resources/root.jinja2
+++ b/web-resources/root.jinja2
@@ -1,6 +1,6 @@
 <!--
-    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
-    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
+    ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ   ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
+    ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
 
     Copyright 2022 t.me/hikariatama
     Licensed under the GNU GPLv3
@@ -9,248 +9,64 @@
 {% extends "base.jinja2" %}
 
 {% block head %}
-  <script src="https://cdn.jsdelivr.net/npm/scrypt-async@2.0.1/scrypt-async.min.js"></script>
-  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
-  <script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
-  <style>
-    @import url('https://fonts.googleapis.com/css2?family=Josefin+Sans&family=Open+Sans:wght@300&display=swap');
-    @import url('https://fonts.googleapis.com/css2?family=Hubballi&display=swap');
-    .button {
-      border-radius: 5px;
-      padding: 10px 20px;
-      border: none;
-      color: #eee;
-      margin: 5px 0;
-      background: transparent;
-      border: 2px solid #aaa;
-      cursor: pointer;
-      transition: box-shadow .2s ease;
-      user-select: none;
-    }
-
-
+  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
+  <script src="//cdnjs.cloudflare.com/ajax/libs/bodymovin/5.8.1/lottie.min.js"></script>
 
-    .button:hover {
-      box-shadow: inset 5px 5px 3px rgba(255, 255, 255, .1),
-                  inset -5px -5px 3px rgba(255, 255, 255, .1);
-    }
+  <link href="//cdn.jsdelivr.net/npm/css.gg/icons/all.css" rel="stylesheet">
 
-    .signin_block {
-      display: inline-block;
-    }
+  <link rel="stylesheet" href="{{ static("base.css") }}">
 
-    .signin_block ul {
-      margin: 0;
-      list-style: none;
-      padding: 0;
-    }
-
-    .signin_block li {
-      width: 100%;
+  <style>
+    .button i {
+      margin-left: .5em;
     }
 
-    .signin_block h1 {
-      margin: 0;
-      color: #eee;
-      font-size: 22px;
-      padding: 10px;
-      font-family: "Open Sans";
+    .button {
+      margin: 10px 5px;
     }
 
-    .hamburger, .menu {
+    .mountains {
       display: none;
     }
-  </style>
-
-  <style type="text/css">
-    body, html {
-      width: 100%;
-      height: 100%;
-      margin: 0;
-      padding: 0;
-    }
-
-    body {
-      /*background: linear-gradient(-45deg, #007700 0%, #004400 100%);*/
-      transition: all 2s ease;
-      background: #16181d;
-    }
-
-    #sky {
-      width: 100vw;
-      height: 100vh;
-      position: fixed;
-      overflow: hidden;
-      margin: 0;
-      padding: 0;
-    }
 
-    #shootingstars {
-      margin: 0;
-      padding: 0;
-      width: 150vh;
-      height: 100vw;
-      position: fixed;
-      overflow: hidden;
-      transform: translatex(calc(50vw - 50%)) translatey(calc(50vh - 50%))
-        rotate(120deg);
+    #tg_icon {
+      height: 40vh;
     }
 
-    .wish {
-      height: 2px;
-      top: 300px;
-      width: 100px;
-      margin: 0;
-      opacity: 0;
-      padding: 0;
-      background-color: white;
+    .auth {
       position: absolute;
-      background: linear-gradient(-45deg, white, rgba(0, 0, 255, 0));
-      filter: drop-shadow(0 0 6px white);
-      overflow: hidden;
-    }
-
-    .title {
-      font-size: 50px;
-      font-family: Hubballi;
-      text-align: center;
-      color: #fff;
-      width: 100%;
-      z-index: 2;
-      position: relative;
-      height: 50px;
-      line-height: 50px;
-    }
-
-    .description {
-      font-size: 24px;
-      color: #eee;
-      text-align: center;
-      width: 100%;
-      z-index: 2;
-      position: relative;
-      padding-top: 20px;
-      line-height: 1.3;
-      font-family: Hubballi;
-    }
-
-    .wrapper {
-      width: 100%;
-      height: 100%;
-      position: absolute;
-      justify-content: center;
-      align-items: center;
-      display: flex;
-      flex-direction: column;
-    }
-
-    #root {
-      position: absolute;
-      top:  0;
-      right: 0;
-      left: 0;
-      bottom: 0;
-      margin: auto;
-    }
-
-    .darken {
-      position: absolute;
-      width: 100%;
-      height: 100%;
-      z-index: 1;
-      background: rgba(0, 0, 0, .1);
       top: 0;
       bottom: 0;
       right: 0;
       left: 0;
       margin: auto;
-    }
-
-    .main_content {
-      display: none;
-    }
-
-    .center {
-      justify-content: center;
-      align-items: center;
-      display: flex;
-      position: relative;
-      z-index: 2;
-      margin-top: 20px;
-    }
-
-    .blur {
-      padding: 4rem 8rem;
-      border-radius: 0.375rem;
-      background-color: rgba(22, 24, 29, .5);
-      border: 1px solid rgba(42, 46, 55, 1);
-      backdrop-filter: blur(6px);
-      position: relative;
-      z-index: 99;
-    }
-
-    .bg {
-      background: url(https://github.com/hikariatama/assets/raw/master/bg.png);
-      background-repeat: no-repeat;
-      background-size: contain;
-      width: 80vw;
-      height: 60vh;
-      position: absolute;
-      z-index: 1;
-      background-position: center;
+      width: 70%;
+      height: 60%;
+      padding: 2rem;
       display: none;
     }
 
     @media screen and (max-width: 736px) {
-      .blur {
+      .auth {
         width: 100%;
         height: 100%;
-        padding: 1.5rem;
-        box-sizing: border-box;
-        display: flex;
-        flex-direction: column;
-        align-items: center;
-        justify-content: center;
-      }
-
-      .bg {
-        width: 100vh;
-        height: 100vw;
-        transform: rotate(90deg);
+        margin: 0;
       }
     }
-    .invert {
-      animation: hue_rot 50s infinite ease, floating 5s infinite ease-in-out;
-    }
-
-    @keyframes hue_rot {
-      from {
-        filter: hue-rotate(0deg);
-      }
-
-      50% {
-        filter: hue-rotate(180deg)
-      }
 
-      100% {
-        filter: hue-rotate(0deg);
-      }
+    .confirm_auth {
+      font-size: 36px;
+      text-align: center;
+      color: #fff;
+      padding: 10px 0;
     }
 
-    @keyframes floating {
-      from {
-        transform: translateY(-10px);
-      }
-
-      50% {
-        transform: translateY(10px);
-      }
-
-      to {
-        transform: translateY(-10px);
-      }
+    .waiting_for_auth {
+      font-size: 22px;
+      text-align: center;
+      color: #fff;
+      padding: 15px 0;
     }
-
   </style>
 {% endblock %}
 
@@ -258,60 +74,103 @@
 {% endblock %}
 
 {% block after %}
+<div class="blur auth vert_center">
+  <div id="tg_icon"></div>
+  <div class="waiting_for_auth">Waiting for permission...</div>
+  <div class="confirm_auth">Please, confirm action in <span style="color:#28a0dc">Telegram</span></div>
+</div>
 <div class="wrapper">
-  <div class="bg invert">
-    
-  </div>
-  <div class="blur">
-    <div class="title">GeekTG</div>
-    <div class="description">Ultimate userbot.<br>Best <span style="color:#28a0dc">Telegram</span> userbot.<br><b>Ever</b>.</div>
+  <div class="blur main">
+    <div class="title">Hikka</div>
+    <div class="description">Fresh and cute<br><span style="color:#28a0dc">Telegram</span> userbot.<br><span style="color: #18cc18; display: none" class="authorized">Authorized!</span></div>
     <div class="center">
-      <div class="button" id="restart">Restart</div>
+      <div class="button" id="get_started">
+        {% if not tg_done %}
+          <div class="horiz_center">
+            <div class="vert_center">
+              Get started
+            </div>
+
+            <div class="vert_center">
+              <i class="gg-arrow-right-r"></i>
+            </div>
+          </div>
+        {% else %}
+          <div class="horiz_center">
+            <div class="vert_center">
+              Add phone
+            </div>
+
+            <div class="vert_center">
+              <i class="gg-add-r"></i>
+            </div>
+          </div>
+        {% endif %}
+      </div>
+      {% if skip_creds %}
+        <div class="button" id="enter_api">
+          <div class="horiz_center">
+            <div class="vert_center">
+              Change API Creds
+            </div>
+
+            <div class="vert_center">
+              <i class="gg-brackets"></i>
+            </div>
+          </div>
+        </div>
+      {% endif %}
+      <span id="block_api_id">
+        <label class="api_id" for="api_id">Telegram API ID: </label>
+        <input class="api_id" id="api_id" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" style="width: 4em;">
+      </span>
+      <span id="block_api_hash">
+        <label class="api_hash" for="api_hash">Telegram API hash: </label>
+        <input class="api_hash" id="api_hash" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" style="width: 24em;">
+      </span>
+      <span id="block_phone">
+        <label class="phone" for="phone">Phone: </label>
+        <input class="phone" id="phone" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" style="width: 12em;">
+      </span>
+      <span id="block_2fa">
+        <label class="_2fa" for="_2fa">2FA Password: </label>
+        <input class="_2fa" id="_2fa" placeholder="password" style="width: 12em;" type="password">
+      </span>
+    </div>
+
+    <div class="horiz_center">
+      <div id="continue_btn" class="button">
+        <div class="horiz_center">
+          <div class="vert_center">
+            Continue
+          </div>
+
+          <div class="vert_center">
+            <i class="gg-arrow-right-r"></i>
+          </div>
+        </div>
+      </div>
     </div>
   </div>
-  <div class="darken"></div>
   <div id="root">
 
-  
   </div>
 </div>
-<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
-<script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>
-<script type="text/javascript">
-  $(document).ready(function() {
-      $('.bg').hide().delay(2000).fadeIn(500);
-  });
-  $("#restart").click(() => {
-    Swal.fire({
-      title: 'Are you sure, you want to restart?',
-      showCancelButton: true,
-      confirmButtonText: 'Restart',
-      showLoaderOnConfirm: true,
-      preConfirm: () => {
-        return fetch("/restart", {method: "POST"})
-          .then(function(response) {
-            $("#restart").fadeOut(100);
-            $(".description").html('Restarting...');
-            $(".bg").fadeOut(() => {
-              $(".bg").css({'background-image': 'url(https://github.com/hikariatama/assets/raw/master/moon.png)'});
-              $(".bg").delay(1000).fadeIn(500);
-            });
-            setTimeout(() => {
-              setInterval(() => {
-                fetch("/is_restart_complete", {method: "GET"})
-                .then(() => {window.location.reload();})
-              }, 1000);
-            }, 3000);
-          })
-          .catch(error => {
-            Swal.showValidationMessage(
-              'Restart failed: ' + error.toString()
-            )
-          })
-      },
-      allowOutsideClick: () => !Swal.isLoading()
-    })
-  });
+<script>
+  var skip_creds = "{{ skip_creds }}" == "True";
+  var auth_required = true;
+  fetch("/check_session", {
+      method: "POST",
+      credentials: "include"
+  })
+  .then(response => response.text())
+  .then((response) => {
+    auth_required = response != "1";
+  })
 </script>
+<script src="{{ static("root.js") }}"></script>
+<script src="{{ static("blackhole.js") }}"></script>
+{% if okteto %}
+  <script src="{{ static("okteto.js") }}"></script>
+{% endif %}
 {% endblock %}
-
diff --git a/web-resources/static/base.css b/web-resources/static/base.css
new file mode 100644
index 0000000..3094cd9
--- /dev/null
+++ b/web-resources/static/base.css
@@ -0,0 +1,249 @@
+@import url('https://fonts.googleapis.com/css2?family=Josefin+Sans&family=Open+Sans:wght@300&display=swap');
+@import url('https://fonts.googleapis.com/css2?family=Hubballi&display=swap');
+
+body,
+html {
+    width: 100%;
+    height: 100%;
+    margin: 0;
+    padding: 0;
+}
+
+body {
+    background: #16181d;
+    font-family: Hubballi;
+}
+
+#sky {
+    width: 100vw;
+    height: 100vh;
+    position: fixed;
+    overflow: hidden;
+    margin: 0;
+    padding: 0;
+}
+
+#shootingstars {
+    margin: 0;
+    padding: 0;
+    width: 150vh;
+    height: 100vw;
+    position: fixed;
+    overflow: hidden;
+    transform: translatex(calc(50vw - 50%)) translatey(calc(50vh - 50%)) rotate(120deg);
+}
+
+.wish {
+    height: 2px;
+    top: 300px;
+    width: 100px;
+    margin: 0;
+    opacity: 0;
+    padding: 0;
+    background-color: white;
+    position: absolute;
+    background: linear-gradient(-45deg, white, rgba(0, 0, 255, 0));
+    filter: drop-shadow(0 0 6px white);
+    overflow: hidden;
+}
+
+.title {
+    font-size: 50px;
+    font-family: Hubballi;
+    text-align: center;
+    color: #fff;
+    width: 100%;
+    z-index: 2;
+    position: relative;
+    height: 50px;
+    line-height: 50px;
+}
+
+.description {
+    font-size: 24px;
+    color: #eee;
+    text-align: center;
+    width: 100%;
+    z-index: 2;
+    position: relative;
+    padding-top: 20px;
+    line-height: 1.3;
+    font-family: Hubballi;
+}
+
+.wrapper {
+    width: 100%;
+    height: 100%;
+    position: absolute;
+    justify-content: center;
+    align-items: center;
+    display: flex;
+    flex-direction: column;
+}
+
+#root {
+    position: absolute;
+    top: 0;
+    right: 0;
+    left: 0;
+    bottom: 0;
+    margin: auto;
+}
+
+.darken {
+    position: absolute;
+    width: 100%;
+    height: 100%;
+    z-index: 1;
+    background: rgba(0, 0, 0, .1);
+    top: 0;
+    bottom: 0;
+    right: 0;
+    left: 0;
+    margin: auto;
+}
+
+.main_content {
+    display: none;
+}
+
+.center {
+    justify-content: center;
+    align-items: center;
+    display: flex;
+    position: relative;
+    z-index: 2;
+    margin-top: 20px;
+}
+
+.blur {
+    padding: 4rem 6rem;
+    border-radius: 0.375rem;
+    background-color: rgba(22, 24, 29, .5);
+    border: 1px solid rgba(42, 46, 55, 1);
+    backdrop-filter: blur(6px);
+    position: relative;
+    z-index: 99;
+}
+
+.bg {
+    background: url(https://github.com/hikariatama/assets/raw/master/bg.png);
+    background-repeat: no-repeat;
+    background-size: contain;
+    width: 80vw;
+    height: 60vh;
+    position: absolute;
+    z-index: 1;
+    background-position: center;
+    display: none;
+    animation: floating 5s infinite ease-in-out;
+    filter: hue-rotate(286deg);
+
+    transition: filter .25s cubic-bezier(0, .77, 0, .68);
+}
+
+.mountains {
+    transition: filter .25s cubic-bezier(0, .77, 0, .68);
+}
+
+@media screen and (max-width: 736px) {
+    .blur {
+        width: 100%;
+        height: 100%;
+        padding: 1.5rem;
+        box-sizing: border-box;
+        display: flex;
+        flex-direction: column;
+        align-items: center;
+        justify-content: center;
+    }
+    .bg {
+        width: 100vw;
+        top: 0;
+        height: 50vh;
+    }
+}
+
+@keyframes floating {
+    from {
+        transform: translateY(-10px);
+    }
+    50% {
+        transform: translateY(10px);
+    }
+    to {
+        transform: translateY(-10px);
+    }
+}
+
+
+.button {
+    border-radius: 5px;
+    padding: 10px 20px;
+    border: none;
+    color: #eee;
+    margin: 5px 0;
+    background: transparent;
+    border: 2px solid #aaa;
+    cursor: pointer;
+    transition: box-shadow .2s ease;
+    user-select: none;
+}
+
+.button:hover {
+    box-shadow: inset 5px 5px 3px rgba(255, 255, 255, .1), inset -5px -5px 3px rgba(255, 255, 255, .1);
+}
+
+input {
+    outline: none;
+    color: #fff;
+    text-align: center;
+    border-radius: 5px;
+    padding: 10px 20px;
+    border: none;
+    background: transparent;
+    border: 2px solid #aaa;
+    transition: box-shadow .2s ease;
+}
+
+input:focus {
+    box-shadow: inset 5px 5px 3px rgba(255, 255, 255, .1), inset -5px -5px 3px rgba(255, 255, 255, .1);
+}
+
+label {
+    margin: 0 10px;
+    color: #eee;
+    user-select: none;
+}
+
+#continue_btn,
+#block_api_id,
+#block_api_hash,
+#block_phone,
+#block_2fa {
+    display: none;
+}
+
+.red_state {
+    filter: hue-rotate(66deg);
+}
+
+.horiz_center {
+    justify-content: center;
+    align-items: center;
+    display: flex;
+}
+
+.vert_center {
+    justify-content: center;
+    align-items: center;
+    display: flex;
+    flex-direction: column;
+}
+
+#blackhole {
+    width: 100%;
+    height: 100%;
+    box-sizing: border-box;
+    position: absolute;
+} 
diff --git a/web-resources/static/blackhole.js b/web-resources/static/blackhole.js
new file mode 100644
index 0000000..433fc83
--- /dev/null
+++ b/web-resources/static/blackhole.js
@@ -0,0 +1,165 @@
+// Created by Darryl Huffman
+// https://codepen.io/darrylhuffman/pen/vXjVJg
+
+blackhole('#blackhole');
+
+function blackhole(element) {
+    var h = $(element).height(),
+        w = $(element).width(),
+        cw = w,
+        ch = h,
+        maxorbit = 300, // distance from center
+        centery = ch/2,
+        centerx = cw/2;
+
+    var startTime = new Date().getTime();
+    var currentTime = 0;
+
+    var stars = [];
+    window.expanse = false; // if clicked
+
+    var canvas = $('<canvas/>').attr({width: cw, height: ch}).appendTo(element);
+    var context = document.querySelector(element).querySelector('canvas').getContext("2d");
+
+    context.globalCompositeOperation = "multiply";
+
+    function setDPI(canvas, dpi) {
+        // Set up CSS size if it's not set up already
+        if (!canvas.get(0).style.width)
+            canvas.get(0).style.width = `${canvas.get(0).width}px`;
+        if (!canvas.get(0).style.height)
+            canvas.get(0).style.height = `${canvas.get(0).height}px`;
+
+        var scaleFactor = dpi / 96;
+        canvas.get(0).width = Math.ceil(canvas.get(0).width * scaleFactor);
+        canvas.get(0).height = Math.ceil(canvas.get(0).height * scaleFactor);
+        var ctx = canvas.get(0).getContext('2d');
+        ctx.scale(scaleFactor, scaleFactor);
+    }
+
+    function rotate(cx, cy, x, y, angle) {
+        var radians = angle,
+            cos = Math.cos(radians),
+            sin = Math.sin(radians),
+            nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
+            ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
+        return [nx, ny];
+    }
+
+    setDPI(canvas, 218);
+
+    var star = function(){
+
+        // Get a weighted random number, so that the majority of stars will form in the center of the orbit
+        var rands = [];
+        rands.push(Math.random() * (maxorbit/2) + 1);
+        rands.push(Math.random() * (maxorbit/2) + maxorbit);
+
+        this.orbital = (rands.reduce(function(p, c) {
+            return p + c;
+        }, 0) / rands.length);
+        // Done getting that random number, it's stored in this.orbital
+
+        this.x = centerx; // All of these stars are at the center x position at all times
+        this.y = centery + this.orbital; // Set Y position starting at the center y + the position in the orbit
+
+        this.yOrigin = centery + this.orbital;  // this is used to track the particles origin
+
+        this.speed = (Math.floor(Math.random() * 1.5) + 1)*Math.PI/180; // The rate at which this star will orbit
+        this.rotation = 0; // current Rotation
+        this.startRotation = (Math.floor(Math.random() * 360) + 1)*Math.PI/180; // Starting rotation.  If not random, all stars will be generated in a single line.  
+
+        this.id = stars.length;  // This will be used when expansion takes place.
+
+        this.collapseBonus = this.orbital - (maxorbit * 0.7); // This "bonus" is used to randomly place some stars outside of the blackhole on hover
+        if(this.collapseBonus < 0){ // if the collapse "bonus" is negative
+            this.collapseBonus = 0; // set it to 0, this way no stars will go inside the blackhole
+        }
+
+        stars.push(this);
+        this.color = `rgba(255,180,255,${1 - ((this.orbital) / 255 * 0.8)})`; // Color the star white, but make it more transparent the further out it is generated
+
+        this.hoverPos = centery + (maxorbit/2) + this.collapseBonus;  // Where the star will go on hover of the blackhole
+        this.expansePos = centery + (this.id%100)*-10 + (Math.floor(Math.random() * 20) + 1); // Where the star will go when expansion takes place
+
+
+        this.prevR = this.startRotation;
+        this.prevX = this.x;
+        this.prevY = this.y;
+
+        // The reason why I have yOrigin, hoverPos and expansePos is so that I don't have to do math on each animation frame.  Trying to reduce lag.
+    }
+    star.prototype.draw = function(){
+        // the stars are not actually moving on the X axis in my code.  I'm simply rotating the canvas context for each star individually so that they all get rotated with the use of less complex math in each frame.
+
+        if(!window.expanse){
+            this.rotation = this.startRotation + (currentTime * this.speed);
+            if(this.y > this.yOrigin){
+                this.y-= 2.5;
+            }
+            if(this.y < this.yOrigin-4){
+                this.y+= (this.yOrigin - this.y) / 10;
+            }
+        } else {
+            this.rotation = this.startRotation + (currentTime * (this.speed / 2));
+            if(this.y > this.expansePos){
+                this.y-= Math.floor(this.expansePos - this.y) / -140;
+            }
+        }
+
+        context.save();
+        context.fillStyle = this.color;
+        context.strokeStyle = this.color;
+        context.beginPath();
+        var oldPos = rotate(centerx,centery,this.prevX,this.prevY,-this.prevR);
+        context.moveTo(oldPos[0],oldPos[1]);
+        context.translate(centerx, centery);
+        context.rotate(this.rotation);
+        context.translate(-centerx, -centery);
+        context.lineTo(this.x,this.y);
+        context.stroke();
+        context.restore();
+
+
+        this.prevR = this.rotation;
+        this.prevX = this.x;
+        this.prevY = this.y;
+    }
+
+    window.expanse = false;
+
+    window.requestFrame = (function(){
+        return  window.requestAnimationFrame       ||
+            window.webkitRequestAnimationFrame ||
+            window.mozRequestAnimationFrame    ||
+            function( callback ){
+            window.setTimeout(callback, 1000 / 60);
+        };
+    })();
+
+    function loop(){
+        var now = new Date().getTime();
+        currentTime = (now - startTime) / 50;
+
+        context.fillStyle = 'rgba(25,25,25,0.2)'; // somewhat clear the context, this way there will be trails behind the stars 
+        context.fillRect(0, 0, cw, ch);
+
+        for(var i = 0; i < stars.length; i++){  // For each star
+            if(stars[i] != stars){
+                stars[i].draw(); // Draw it
+            }
+        }
+
+        requestFrame(loop);
+    }
+
+    function init(){
+        context.fillStyle = 'rgba(25,25,25,1)';  // Initial clear of the canvas, to avoid an issue where it all gets too dark
+        context.fillRect(0, 0, cw, ch);
+        for(var i = 0; i < 2000; i++){  // create 2000 stars
+            new star();
+        }
+        loop();
+    }
+    init();
+}
\ No newline at end of file
diff --git a/web-resources/static/okteto.js b/web-resources/static/okteto.js
new file mode 100644
index 0000000..5eeb5c5
--- /dev/null
+++ b/web-resources/static/okteto.js
@@ -0,0 +1,15 @@
+function okteto() {
+    fetch("/okteto", {
+        method: "POST",
+        credentials: "include",
+        body: window.location.href
+    })
+    .then(response => response.text())
+    .then((response) => {
+        if(response == "WAIT") {
+            setTimeout(() => {okteto();}, 5000);
+        }
+    })
+}
+
+okteto()
diff --git a/web-resources/static/root.js b/web-resources/static/root.js
new file mode 100644
index 0000000..4e40ce2
--- /dev/null
+++ b/web-resources/static/root.js
@@ -0,0 +1,289 @@
+function auth(callback) {
+    $(".main").fadeOut(500, () => {
+        $(".auth").hide().fadeIn(500);
+        bodymovin.loadAnimation({
+            container: document.getElementById("tg_icon"),
+            renderer: 'canvas',
+            loop: true,
+            autoplay: true,
+            path: 'https://raw.githubusercontent.com/hikariatama/Hikka/master/assets/noface.json',
+            rendererSettings: {
+                clearCanvas: true,
+            }
+        });
+        fetch("/web_auth", {
+            method: "POST",
+            credentials: "include",
+            timeout: 300000
+        })
+        .then(response => response.text())
+        .then((response) => {
+            if(response == "TIMEOUT") {
+                error_message("Code waiting timeout exceeded. Reload page and try again.");
+                $(".auth").fadeOut(500);
+                return
+            }
+
+            if(response.startsWith("hikka_")) {
+                $.cookie("session", response)
+                auth_required = false;
+                $(".authorized").hide().fadeIn(100);
+                $(".auth").fadeOut(500, () => {
+                    $(".main").fadeIn(500);
+                });
+                callback();
+                return;
+            }
+        })
+    })
+}
+
+$("#get_started")
+    .click(() => {
+        if(auth_required) return auth(() => {$("#get_started").click();});
+        $("#enter_api").fadeOut(500);
+        $("#get_started")
+            .fadeOut(500, () => {
+                $("#continue_btn")
+                    .hide()
+                    .fadeIn(500);
+
+                switch_block(_current_block);
+            });
+    });
+
+$("#enter_api")
+    .click(() => {
+        if(auth_required) return auth(() => {$("#enter_api").click();});
+        $("#get_started").fadeOut(500);
+        $("#enter_api")
+            .fadeOut(500, () => {
+                $("#continue_btn")
+                    .hide()
+                    .fadeIn(500);
+
+                switch_block("api_id");
+            });
+    });
+
+function isInt(value) {
+    var x = parseFloat(value);
+    return !isNaN(value) && (x | 0) === x;
+}
+
+function isValidPhone(p) {
+    var phoneRe = /^[+]?\d{11,13}$/;
+    return phoneRe.test(p);
+}
+
+function finish_login() {
+    fetch("/finishLogin", {
+            method: "POST",
+            credentials: "include"
+        })
+        .then(response => response.text())
+        .then((response) => {
+            window.expanse = true;
+            if(response == "0") {
+                setTimeout(() => {
+                    Swal.fire({
+                        "icon": "info",
+                        "title": "You would need to restart userbot in order to apply new session"
+                    })
+                }, 1000);
+            }
+            $(".blur").fadeOut(1500);
+            setTimeout(() => {
+                window.location.href = "/";
+            }, 8000);
+        })
+        .catch(() => {
+            error_state();
+            error_message("Login confirmation error");
+        });
+}
+
+function tg_code() {
+    fetch("/tgCode", {
+            method: "POST",
+            body: `${_tg_pass}\n${_phone}\n${_2fa_pass}`
+        })
+        .then((response) => {
+            if (!response.ok) {
+                if (response.status == 403) {
+                    error_state();
+                    Swal.showValidationMessage("Code is incorrect!");
+                } else if (response.status == 401) {
+                    switch_block("2fa");
+                } else if (response.status == 404) {
+                    error_state();
+                    Swal.showValidationMessage("Code is expired!");
+                } else {
+                    error_state();
+                    Swal.showValidationMessage("Internal server error");
+                }
+            } else {
+                finish_login();
+            }
+        })
+        .catch(error => {
+            Swal.showValidationMessage(
+                `Auth failed: ${error.toString()}`
+            )
+        })
+}
+
+function switch_block(block) {
+    cnt_btn.setAttribute("current-step", block);
+   try {
+        $(`#block_${_current_block}`)
+            .fadeOut(() => {
+                $(`#block_${block}`)
+                    .hide()
+                    .fadeIn();
+            });
+    } catch {
+        $(`#block_${block}`)
+            .hide()
+            .fadeIn();
+    }
+
+    _current_block = block;
+}
+
+function error_message(message) {
+    Swal.fire({
+        "icon": "error",
+        "title": message
+    });
+}
+
+function error_state() {
+    $("#blackhole").addClass("red_state");
+    cnt_btn.disabled = true;
+    setTimeout(() => {
+        cnt_btn.disabled = false;
+        $("#blackhole").removeClass("red_state");
+    }, 1000);
+}
+
+var _api_id = "",
+    _api_hash = "",
+    _phone = "",
+    _2fa_pass = "",
+    _tg_pass = "",
+_current_block = skip_creds ? "phone" : "api_id";
+
+const cnt_btn = document.querySelector("#continue_btn");
+
+function process_next() {
+    let step = cnt_btn.getAttribute("current-step");
+    if (step == "api_id") {
+        let api_id = document.querySelector("#api_id")
+            .value;
+        if (api_id.length < 4 || !isInt(api_id)) {
+            error_state();
+            return;
+        }
+
+        _api_id = parseInt(api_id, 10);
+        switch_block("api_hash");
+
+        return;
+    }
+
+    if (step == "api_hash") {
+        let api_hash = document.querySelector("#api_hash")
+            .value;
+        if (api_hash.length != 32) {
+            error_state();
+            return;
+        }
+
+        _api_hash = api_hash;
+        fetch("/setApi", {
+                method: "PUT",
+                body: _api_hash + _api_id,
+                credentials: "include"
+            })
+            .then((response) => {
+                if (!response.ok) {
+                    error_state();
+                    error_message("Error occured while saving credentials")
+                } else {
+                    switch_block("phone");
+                }
+            })
+            .catch(() => {
+                error_state();
+                error_message("Error occured while saving credentials")
+            });
+
+        return;
+    }
+
+    if (step == "phone") {
+        let phone = document.querySelector("#phone").value;
+        if (!isValidPhone(phone)) {
+            error_state();
+            return;
+        }
+
+        _phone = phone;
+        fetch("/sendTgCode", {
+                method: "POST",
+                body: _phone,
+                credentials: "include"
+            })
+            .then((response) => {
+                if (!response.ok) {
+                    error_state();
+                    error_message("Code send failed");
+                } else {
+                    Swal.fire({
+                        title: "Enter received code",
+                        input: "text",
+                        inputAttributes: {
+                            autocapitalize: "off"
+                        },
+                        showCancelButton: false,
+                        confirmButtonText: "Confirm",
+                        showLoaderOnConfirm: true,
+                        preConfirm: (login) => {
+                            _tg_pass = login
+                            tg_code();
+                        },
+                        allowOutsideClick: () => !Swal.isLoading()
+                    })
+                }
+            })
+            .catch(() => {
+                error_state();
+                error_message("Code send failed");
+            });
+    }
+
+    if (step == "2fa") {
+        let _2fa = document.querySelector("#_2fa")
+            .value;
+        _2fa_pass = _2fa;
+        tg_code();
+        return
+    }
+}
+
+cnt_btn.onclick = () => {
+    if (cnt_btn.disabled) return;
+    if (auth_required) return auth(() => {cnt_btn.click();});
+
+    process_next();
+}
+
+$("input").on("keyup", (e) => {
+    if (cnt_btn.disabled) return;
+    if (auth_required) return auth(() => {cnt_btn.click();});
+
+    if (e.key === "Enter" || e.keyCode === 13) {
+        process_next();
+    }
+});
